{"version":3,"sources":["../src/loose.ts","../src/resultClient.ts","../src/gen/types.gen.ts","../src/index.ts"],"sourcesContent":["// Factory producing a client with all CamundaKey<T>-branded string types downgraded to plain string.\n// Purely a type-level transformation: runtime behavior identical to createCamundaClient.\n\nimport { createCamundaClient } from './gen/CamundaClient';\n\nimport type { CancelablePromise } from './gen/CamundaClient';\n\n// Detect a branded string of the form string & { readonly __brand: ... }\ntype IsBrandedKey<T> = T extends string & { readonly __brand: infer _B } ? true : false;\n\n// Transform function parameters & return types recursively.\n// We handle promises, arrays, readonly arrays, objects, and functions.\n// Note: We relax types only (brand -> string) so casting is safe.\nexport type Loose<T> =\n  // Branded key -> plain string\n  IsBrandedKey<T> extends true\n    ? string\n    : // Preserve cancelable promise wrapper while loosening inner payload\n      T extends CancelablePromise<infer P>\n      ? CancelablePromise<Loose<P>>\n      : // Generic promise unwrap & rewrap\n        T extends Promise<infer P>\n        ? Promise<Loose<P>>\n        : // Arrays\n          T extends (infer U)[]\n          ? Loose<U>[]\n          : T extends ReadonlyArray<infer U>\n            ? ReadonlyArray<Loose<U>>\n            : // Functions\n              T extends (...a: infer A) => infer R\n              ? (...a: { [I in keyof A]: Loose<A[I]> }) => Loose<R>\n              : // Objects (exclude primitives/Date/etc.)\n                T extends object\n                ? { [K in keyof T]: Loose<T[K]> }\n                : // Fallback: leave as-is\n                  T;\n\n/**\n * Create a client where all branded key types are widened to string.\n * Use when integrating with external systems or when dynamic string keys are common and brand friction is unwanted.\n * For maximum type safety prefer the strict createCamundaClient.\n */\nexport function createCamundaClientLoose(\n  ...args: Parameters<typeof createCamundaClient>\n): Loose<ReturnType<typeof createCamundaClient>> {\n  const strict = createCamundaClient(...args);\n  return strict as unknown as Loose<ReturnType<typeof createCamundaClient>>;\n}\n\nexport type CamundaClientLoose = ReturnType<typeof createCamundaClientLoose>;\n","// Functional-style wrapper that converts thrown errors into Result objects.\nimport { createCamundaClient, CamundaOptions, CamundaClient } from './gen/CamundaClient';\n\nexport type Result<T, E = unknown> = { ok: true; value: T } | { ok: false; error: E };\nexport const isOk = <T, E>(r: Result<T, E>): r is { ok: true; value: T } => r.ok;\nexport const isErr = <T, E>(r: Result<T, E>): r is { ok: false; error: E } => !r.ok;\n\n// Narrow utility: detect a thenable\nfunction isPromise(v: any): v is Promise<unknown> {\n  return v && typeof v.then === 'function';\n}\n\n/**\n * @experimental This feature is under development and is not guaranteed to be fully tested or stable.\n * @description Factory returning a proxy that mirrors the CamundaClient surface but never throws.\n * All async returning methods (Promise or CancelablePromise) are wrapped into Promise<Result<..>>.\n * Synchronous utility methods (e.g. logger(), getConfig()) are passed through unchanged.\n * */\nexport function createCamundaResultClient(options?: CamundaOptions) {\n  const base = createCamundaClient(options);\n\n  const handler: ProxyHandler<any> = {\n    get(_target, prop, _recv) {\n      if (prop === 'inner') return base;\n      const value = (base as any)[prop];\n      if (typeof value !== 'function') return value;\n      return (...args: any[]) => {\n        try {\n          const out = value.apply(base, args);\n          if (isPromise(out)) {\n            return out\n              .then((v: any) => ({ ok: true, value: v }) as const)\n              .catch((e: unknown) => ({ ok: false, error: e }) as const);\n          }\n          return Promise.resolve({ ok: true, value: out } as const);\n        } catch (e) {\n          return Promise.resolve({ ok: false, error: e } as const);\n        }\n      };\n    },\n  };\n\n  return new Proxy({}, handler) as CamundaResultClient;\n}\n\n// Structural type describing the returned proxy (subset – only async operation methods mapped to Result).\n// We purposefully keep it simple; operation methods become (...args) => Promise<Result<Return>>.\nexport type CamundaResultClient = {\n  inner: CamundaClient;\n} & {\n  [K in keyof CamundaClient]: CamundaClient[K] extends (...a: infer A) => Promise<infer R>\n    ? (...a: A) => Promise<Result<R>>\n    : CamundaClient[K] extends (...a: infer A) => any\n      ? (...a: A) => Promise<Result<ReturnType<CamundaClient[K]>>> | ReturnType<CamundaClient[K]>\n      : CamundaClient[K];\n};\n","// This file is auto-generated by @hey-api/openapi-ts\n\nexport type CamundaKey< T extends string = string > = string & { readonly __brand: T };\n// branding-plugin patch: applied primitive branding\n\n/**\n * Zeebe Engine resource key (Java long serialized as string)\n */\nexport type LongKey = string;\n\n/**\n * The start cursor in a search query result set.\n */\nexport type StartCursor = CamundaKey<'StartCursor'>;\n\n/**\n * The end cursor in a search query result set.\n */\nexport type EndCursor = CamundaKey<'EndCursor'>;\n\n/**\n * System-generated key for a process instance.\n */\nexport type ProcessInstanceKey = CamundaKey<'ProcessInstanceKey'>;\n\n/**\n * Key for a deployment.\n */\nexport type DeploymentKey = CamundaKey<'DeploymentKey'>;\n\n/**\n * System-generated key for a user task.\n */\nexport type UserTaskKey = CamundaKey<'UserTaskKey'>;\n\n/**\n * System-generated key for a deployed process definition.\n */\nexport type ProcessDefinitionKey = CamundaKey<'ProcessDefinitionKey'>;\n\n/**\n * Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.\n */\nexport type ProcessDefinitionId = CamundaKey<'ProcessDefinitionId'>;\n\n/**\n * System-generated key for a element instance.\n */\nexport type ElementInstanceKey = CamundaKey<'ElementInstanceKey'>;\n\n/**\n * The model-defined id of an element.\n */\nexport type ElementId = CamundaKey<'ElementId'>;\n\n/**\n * System-generated key for a deployed form.\n */\nexport type FormKey = CamundaKey<'FormKey'>;\n\n/**\n * The user-defined id for the form\n */\nexport type FormId = CamundaKey<'FormId'>;\n\n/**\n * System-generated key for a variable.\n */\nexport type VariableKey = CamundaKey<'VariableKey'>;\n\n/**\n * The system-assigned key for this resource.\n */\nexport type ResourceKey = ProcessDefinitionKey | DecisionRequirementsKey | FormKey | DecisionDefinitionKey;\n\n/**\n * System-generated key for a scope.\n */\nexport type ScopeKey = CamundaKey<'ScopeKey'>;\n\n/**\n * System-generated key for a incident.\n */\nexport type IncidentKey = CamundaKey<'IncidentKey'>;\n\n/**\n * System-generated key for a job.\n */\nexport type JobKey = CamundaKey<'JobKey'>;\n\n/**\n * System-generated key for a message subscription.\n */\nexport type MessageSubscriptionKey = CamundaKey<'MessageSubscriptionKey'>;\n\n/**\n * System-generated key for a message correlation.\n */\nexport type MessageCorrelationKey = CamundaKey<'MessageCorrelationKey'>;\n\n/**\n * System-generated key for a decision definition.\n */\nexport type DecisionDefinitionKey = CamundaKey<'DecisionDefinitionKey'>;\n\n/**\n * Id of a decision definition, from the model. Only ids of decision definitions that are deployed are useful.\n */\nexport type DecisionDefinitionId = CamundaKey<'DecisionDefinitionId'>;\n\n/**\n * System-generated key for a decision evaluation instance.\n */\nexport type DecisionEvaluationInstanceKey = CamundaKey<'DecisionEvaluationInstanceKey'>;\n\n/**\n * System-generated key for a decision evaluation.\n */\nexport type DecisionEvaluationKey = CamundaKey<'DecisionEvaluationKey'>;\n\n/**\n * System-generated key for a deployed decision requirements definition.\n */\nexport type DecisionRequirementsKey = CamundaKey<'DecisionRequirementsKey'>;\n\n/**\n * System-generated key for an authorization.\n */\nexport type AuthorizationKey = CamundaKey<'AuthorizationKey'>;\n\n/**\n * System-generated key for an message.\n */\nexport type MessageKey = CamundaKey<'MessageKey'>;\n\n/**\n * System-generated key for a deployed decision instance.\n */\nexport type DecisionInstanceKey = CamundaKey<'DecisionInstanceKey'>;\n\n/**\n * System-generated key for an signal.\n */\nexport type SignalKey = CamundaKey<'SignalKey'>;\n\n/**\n * System-generated key for an batch operation.\n */\nexport type BatchOperationKey = CamundaKey<'BatchOperationKey'>;\n\nexport type TenantCreateRequest = {\n    /**\n     * The unique ID for the tenant. Must be 255 characters or less. Can contain letters, numbers, [`_`, `-`, `+`, `.`, `@`].\n     */\n    tenantId: string;\n    /**\n     * The name of the tenant.\n     */\n    name: string;\n    /**\n     * The description of the tenant.\n     */\n    description?: string;\n};\n\nexport type TenantCreateResult = {\n    tenantId?: TenantId;\n    /**\n     * The name of the tenant.\n     */\n    name?: string;\n    /**\n     * The description of the tenant.\n     */\n    description?: string;\n};\n\nexport type TenantUpdateRequest = {\n    /**\n     * The new name of the tenant.\n     */\n    name: string;\n    /**\n     * The new description of the tenant.\n     */\n    description: string;\n};\n\nexport type TenantUpdateResult = {\n    tenantId?: TenantId;\n    /**\n     * The name of the tenant.\n     */\n    name?: string;\n    /**\n     * The description of the tenant.\n     */\n    description?: string;\n};\n\n/**\n * Tenant search response item.\n */\nexport type TenantResult = {\n    /**\n     * The tenant name.\n     */\n    name?: string;\n    tenantId?: TenantId;\n    /**\n     * The tenant description.\n     */\n    description?: string;\n};\n\nexport type TenantSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'key' | 'name' | 'tenantId';\n    order?: SortOrderEnum;\n};\n\n/**\n * Tenant search request\n */\nexport type TenantSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<TenantSearchQuerySortRequest>;\n    /**\n     * The tenant search filters.\n     */\n    filter?: TenantFilter;\n};\n\n/**\n * Tenant filter request\n */\nexport type TenantFilter = {\n    tenantId?: TenantId;\n    /**\n     * The name of the tenant.\n     */\n    name?: string;\n};\n\n/**\n * Tenant search response.\n */\nexport type TenantSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching tenants.\n     */\n    items?: Array<TenantResult>;\n};\n\nexport type UserTaskSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'creationDate' | 'completionDate' | 'followUpDate' | 'dueDate' | 'priority' | 'name';\n    order?: SortOrderEnum;\n};\n\n/**\n * User task search query request.\n */\nexport type UserTaskSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<UserTaskSearchQuerySortRequest>;\n    /**\n     * The user task search filters.\n     */\n    filter?: UserTaskFilter;\n};\n\nexport type UserTaskVariableSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'value' | 'name' | 'tenantId' | 'variableKey' | 'scopeKey' | 'processInstanceKey';\n    order?: SortOrderEnum;\n};\n\n/**\n * User task search query request.\n */\nexport type UserTaskVariableSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<UserTaskVariableSearchQuerySortRequest>;\n    /**\n     * The user task variable search filters.\n     */\n    filter?: UserTaskVariableFilter;\n};\n\n/**\n * User task search query response.\n */\nexport type UserTaskSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching user tasks.\n     */\n    items: Array<UserTaskResult>;\n};\n\n/**\n * User task filter request.\n */\nexport type UserTaskFilter = {\n    /**\n     * The user task state.\n     */\n    state?: UserTaskStateFilterProperty;\n    /**\n     * The assignee of the user task.\n     */\n    assignee?: StringFilterProperty;\n    /**\n     * The priority of the user task.\n     */\n    priority?: IntegerFilterProperty;\n    /**\n     * The element ID of the user task.\n     */\n    elementId?: ElementId;\n    /**\n     * The task name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.\n     *\n     */\n    name?: string;\n    /**\n     * The candidate group for this user task.\n     */\n    candidateGroup?: StringFilterProperty;\n    /**\n     * The candidate user for this user task.\n     */\n    candidateUser?: StringFilterProperty;\n    /**\n     * Tenant ID of this user task.\n     */\n    tenantId?: StringFilterProperty;\n    /**\n     * The ID of the process definition.\n     */\n    processDefinitionId?: ProcessDefinitionId;\n    /**\n     * The user task creation date.\n     */\n    creationDate?: DateTimeFilterProperty;\n    /**\n     * The user task completion date.\n     */\n    completionDate?: DateTimeFilterProperty;\n    /**\n     * The user task follow-up date.\n     */\n    followUpDate?: DateTimeFilterProperty;\n    /**\n     * The user task due date.\n     */\n    dueDate?: DateTimeFilterProperty;\n    /**\n     * Process instance variables associated with the user task.\n     */\n    processInstanceVariables?: Array<VariableValueFilterProperty>;\n    /**\n     * Local variables associated with the user task.\n     */\n    localVariables?: Array<VariableValueFilterProperty>;\n    /**\n     * The key for this user task.\n     */\n    userTaskKey?: UserTaskKey;\n    /**\n     * The key of the process definition.\n     */\n    processDefinitionKey?: ProcessDefinitionKey;\n    /**\n     * The key of the process instance.\n     */\n    processInstanceKey?: ProcessInstanceKey;\n    /**\n     * The key of the element instance.\n     */\n    elementInstanceKey?: ElementInstanceKey;\n};\n\n/**\n * UserTaskStateEnum property with full advanced search capabilities.\n */\nexport type UserTaskStateFilterProperty = UserTaskStateEnum | AdvancedUserTaskStateFilter;\n\n/**\n * Advanced filter\n * Advanced UserTaskStateEnum filter.\n */\nexport type AdvancedUserTaskStateFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: UserTaskStateEnum;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: UserTaskStateEnum;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<UserTaskStateEnum>;\n    $like?: LikeFilter;\n};\n\nexport type VariableValueFilterProperty = {\n    /**\n     * Name of the variable.\n     */\n    name: string;\n    /**\n     * The value of the variable.\n     */\n    value: StringFilterProperty;\n};\n\n/**\n * The user task variable search filters.\n */\nexport type UserTaskVariableFilter = {\n    /**\n     * Name of the variable.\n     */\n    name?: StringFilterProperty;\n};\n\nexport type UserTaskResult = {\n    /**\n     * The name for this user task.\n     */\n    name?: string;\n    state?: UserTaskStateEnum;\n    /**\n     * The assignee of the user task.\n     */\n    assignee?: string;\n    /**\n     * The element ID of the user task.\n     */\n    elementId?: ElementId;\n    /**\n     * The candidate groups for this user task.\n     */\n    candidateGroups?: Array<string>;\n    /**\n     * The candidate users for this user task.\n     */\n    candidateUsers?: Array<string>;\n    /**\n     * The ID of the process definition.\n     */\n    processDefinitionId?: ProcessDefinitionId;\n    /**\n     * The creation date of a user task.\n     */\n    creationDate?: string;\n    /**\n     * The completion date of a user task.\n     */\n    completionDate?: string;\n    /**\n     * The follow date of a user task.\n     */\n    followUpDate?: string;\n    /**\n     * The due date of a user task.\n     */\n    dueDate?: string;\n    tenantId?: TenantId;\n    /**\n     * The external form reference.\n     */\n    externalFormReference?: string;\n    /**\n     * The version of the process definition.\n     */\n    processDefinitionVersion?: number;\n    /**\n     * Custom headers for the user task.\n     */\n    customHeaders?: {\n        [key: string]: string;\n    };\n    /**\n     * The priority of a user task. The higher the value the higher the priority.\n     */\n    priority?: number;\n    /**\n     * The key of the user task.\n     */\n    userTaskKey: UserTaskKey;\n    /**\n     * The key of the element instance.\n     */\n    elementInstanceKey?: ElementInstanceKey;\n    /**\n     * The name of the process definition.\n     */\n    processName?: string;\n    /**\n     * The key of the process definition.\n     */\n    processDefinitionKey?: ProcessDefinitionKey;\n    /**\n     * The key of the process instance.\n     */\n    processInstanceKey?: ProcessInstanceKey;\n    /**\n     * The key of the form.\n     */\n    formKey?: FormKey;\n};\n\n/**\n * The state of the user task.\n */\nexport type UserTaskStateEnum = 'CREATING' | 'CREATED' | 'ASSIGNING' | 'UPDATING' | 'COMPLETING' | 'COMPLETED' | 'CANCELING' | 'CANCELED' | 'FAILED';\n\nexport type VariableSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'value' | 'name' | 'tenantId' | 'variableKey' | 'scopeKey' | 'processInstanceKey';\n    order?: SortOrderEnum;\n};\n\n/**\n * Variable search query request.\n */\nexport type VariableSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<VariableSearchQuerySortRequest>;\n    /**\n     * The variable search filters.\n     */\n    filter?: VariableFilter;\n};\n\n/**\n * Variable filter request.\n */\nexport type VariableFilter = {\n    /**\n     * Name of the variable.\n     */\n    name?: StringFilterProperty;\n    /**\n     * The value of the variable.\n     */\n    value?: StringFilterProperty;\n    /**\n     * Tenant ID of this variable.\n     */\n    tenantId?: TenantId;\n    /**\n     * Whether the value is truncated or not.\n     */\n    isTruncated?: boolean;\n    /**\n     * The key for this variable.\n     */\n    variableKey?: VariableKeyFilterProperty;\n    /**\n     * The key of the scope of this variable.\n     */\n    scopeKey?: ScopeKeyFilterProperty;\n    /**\n     * The key of the process instance of this variable.\n     */\n    processInstanceKey?: ProcessInstanceKeyFilterProperty;\n};\n\n/**\n * Variable search query response.\n */\nexport type VariableSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching variables.\n     */\n    items: Array<VariableSearchResult>;\n};\n\n/**\n * Variable search response item.\n */\nexport type VariableSearchResult = VariableResultBase & {\n    /**\n     * Value of this variable. Can be truncated.\n     */\n    value: string;\n    /**\n     * Whether the value is truncated or not.\n     */\n    isTruncated: boolean;\n};\n\n/**\n * Variable search response item.\n */\nexport type VariableResult = VariableResultBase & {\n    /**\n     * Full value of this variable.\n     */\n    value: string;\n};\n\n/**\n * Variable response item.\n */\nexport type VariableResultBase = {\n    /**\n     * Name of this variable.\n     */\n    name: string;\n    /**\n     * Tenant ID of this variable.\n     */\n    tenantId: TenantId;\n    /**\n     * The key for this variable.\n     */\n    variableKey: VariableKey;\n    /**\n     * The key of the scope of this variable.\n     */\n    scopeKey: ScopeKey;\n    /**\n     * The key of the process instance of this variable.\n     */\n    processInstanceKey: ProcessInstanceKey;\n};\n\nexport type ProcessDefinitionSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'processDefinitionKey' | 'name' | 'resourceName' | 'version' | 'versionTag' | 'processDefinitionId' | 'tenantId';\n    order?: SortOrderEnum;\n};\n\nexport type ProcessDefinitionSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<ProcessDefinitionSearchQuerySortRequest>;\n    /**\n     * The process definition search filters.\n     */\n    filter?: ProcessDefinitionFilter;\n};\n\n/**\n * Process definition search filter.\n */\nexport type ProcessDefinitionFilter = {\n    /**\n     * Name of this process definition.\n     */\n    name?: StringFilterProperty;\n    /**\n     * Whether to only return the latest version of each process definition.\n     * When using this filter, pagination functionality is limited, you can only paginate forward using `after` and `limit`.\n     * The response contains no `startCursor` in the `page`, and requests ignore the `from` and `before` in the `page`.\n     *\n     */\n    isLatestVersion?: boolean;\n    /**\n     * Resource name of this process definition.\n     */\n    resourceName?: string;\n    /**\n     * Version of this process definition.\n     */\n    version?: number;\n    /**\n     * Version tag of this process definition.\n     */\n    versionTag?: string;\n    /**\n     * Process definition ID of this process definition.\n     */\n    processDefinitionId?: StringFilterProperty;\n    /**\n     * Tenant ID of this process definition.\n     */\n    tenantId?: TenantId;\n    /**\n     * The key for this process definition.\n     */\n    processDefinitionKey?: ProcessDefinitionKey;\n    /**\n     * Indicates whether the start event of the process has an associated Form Key.\n     */\n    hasStartForm?: boolean;\n};\n\nexport type ProcessDefinitionSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching process definitions.\n     */\n    items?: Array<ProcessDefinitionResult>;\n};\n\nexport type ProcessDefinitionResult = {\n    /**\n     * Name of this process definition.\n     */\n    name?: string;\n    /**\n     * Resource name for this process definition.\n     */\n    resourceName?: string;\n    /**\n     * Version of this process definition.\n     */\n    version?: number;\n    /**\n     * Version tag of this process definition.\n     */\n    versionTag?: string;\n    /**\n     * Process definition ID of this process definition.\n     */\n    processDefinitionId?: ProcessDefinitionId;\n    /**\n     * Tenant ID of this process definition.\n     */\n    tenantId?: TenantId;\n    /**\n     * The key for this process definition.\n     */\n    processDefinitionKey?: ProcessDefinitionKey;\n    /**\n     * Indicates whether the start event of the process has an associated Form Key.\n     */\n    hasStartForm?: boolean;\n};\n\nexport type ProcessInstanceSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'processInstanceKey' | 'processDefinitionId' | 'processDefinitionName' | 'processDefinitionVersion' | 'processDefinitionVersionTag' | 'processDefinitionKey' | 'parentProcessInstanceKey' | 'parentElementInstanceKey' | 'startDate' | 'endDate' | 'state' | 'hasIncident' | 'tenantId';\n    order?: SortOrderEnum;\n};\n\n/**\n * Process instance search request.\n */\nexport type ProcessInstanceSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<ProcessInstanceSearchQuerySortRequest>;\n    /**\n     * The process instance search filters.\n     */\n    filter?: ProcessInstanceFilter;\n};\n\nexport type ProcessInstanceIncidentSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<IncidentSearchQuerySortRequest>;\n};\n\n/**\n * Advanced filter\n * Advanced integer (int32) filter.\n */\nexport type AdvancedIntegerFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: number;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: number;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Greater than comparison with the provided value.\n     */\n    $gt?: number;\n    /**\n     * Greater than or equal comparison with the provided value.\n     */\n    $gte?: number;\n    /**\n     * Lower than comparison with the provided value.\n     */\n    $lt?: number;\n    /**\n     * Lower than or equal comparison with the provided value.\n     */\n    $lte?: number;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<number>;\n};\n\n/**\n * Integer property with advanced search capabilities.\n */\nexport type IntegerFilterProperty = number | AdvancedIntegerFilter;\n\n/**\n * Advanced filter\n * Basic advanced string filter.\n */\nexport type BasicStringFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: string;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: string;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<string>;\n    /**\n     * Checks if the property matches none of the provided values.\n     */\n    $notIn?: Array<string>;\n};\n\n/**\n * Advanced filter\n * Advanced string filter.\n */\nexport type AdvancedStringFilter = BasicStringFilter & {\n    $like?: LikeFilter;\n};\n\n/**\n * Advanced filter\n * Advanced ProcessInstanceStateEnum filter.\n */\nexport type AdvancedProcessInstanceStateFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: ProcessInstanceStateEnum;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: ProcessInstanceStateEnum;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<ProcessInstanceStateEnum>;\n    $like?: LikeFilter;\n};\n\n/**\n * Advanced filter\n * Advanced ElementInstanceStateEnum filter.\n */\nexport type AdvancedElementInstanceStateFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: ElementInstanceStateEnum;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: ElementInstanceStateEnum;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<ElementInstanceStateEnum>;\n    $like?: LikeFilter;\n};\n\n/**\n * Advanced filter\n * Advanced DecisionDefinitionKey filter.\n */\nexport type AdvancedDecisionDefinitionKeyFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: DecisionDefinitionKey;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: DecisionDefinitionKey;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<DecisionDefinitionKey>;\n    /**\n     * Checks if the property matches none of the provided values.\n     */\n    $notIn?: Array<DecisionDefinitionKey>;\n};\n\n/**\n * DecisionDefinitionKey property with full advanced search capabilities.\n */\nexport type DecisionDefinitionKeyFilterProperty = DecisionDefinitionKey | AdvancedDecisionDefinitionKeyFilter;\n\n/**\n * Advanced filter\n * Advanced date-time filter.\n */\nexport type AdvancedDateTimeFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: string;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: string;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Greater than comparison with the provided value.\n     */\n    $gt?: string;\n    /**\n     * Greater than or equal comparison with the provided value.\n     */\n    $gte?: string;\n    /**\n     * Lower than comparison with the provided value.\n     */\n    $lt?: string;\n    /**\n     * Lower than or equal comparison with the provided value.\n     */\n    $lte?: string;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<string>;\n};\n\n/**\n * String property with basic advanced search capabilities.\n */\nexport type BasicStringFilterProperty = string | BasicStringFilter;\n\n/**\n * String property with full advanced search capabilities.\n */\nexport type StringFilterProperty = string | AdvancedStringFilter;\n\n/**\n * Checks if the property matches the provided like value.\n *\n * Supported wildcard characters are:\n *\n * * `*`: matches zero, one, or multiple characters.\n * * `?`: matches one, single character.\n *\n * Wildcard characters can be escaped with backslash, for instance: `\\*`.\n *\n */\nexport type LikeFilter = string;\n\n/**\n * ProcessInstanceStateEnum property with full advanced search capabilities.\n */\nexport type ProcessInstanceStateFilterProperty = ProcessInstanceStateEnum | AdvancedProcessInstanceStateFilter;\n\n/**\n * ElementInstanceStateEnum property with full advanced search capabilities.\n */\nexport type ElementInstanceStateFilterProperty = ElementInstanceStateEnum | AdvancedElementInstanceStateFilter;\n\n/**\n * Date-time property with full advanced search capabilities.\n */\nexport type DateTimeFilterProperty = string | AdvancedDateTimeFilter;\n\n/**\n * Advanced filter\n * Advanced ProcessDefinitionKey filter.\n */\nexport type AdvancedProcessDefinitionKeyFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: ProcessDefinitionKey;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: ProcessDefinitionKey;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<ProcessDefinitionKey>;\n    /**\n     * Checks if the property matches none of the provided values.\n     */\n    $notIn?: Array<ProcessDefinitionKey>;\n};\n\n/**\n * ProcessDefinitionKey property with full advanced search capabilities.\n */\nexport type ProcessDefinitionKeyFilterProperty = ProcessDefinitionKey | AdvancedProcessDefinitionKeyFilter;\n\n/**\n * Advanced filter\n * Advanced ProcessInstanceKey filter.\n */\nexport type AdvancedProcessInstanceKeyFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: ProcessInstanceKey;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: ProcessInstanceKey;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<ProcessInstanceKey>;\n    /**\n     * Checks if the property matches none of the provided values.\n     */\n    $notIn?: Array<ProcessInstanceKey>;\n};\n\n/**\n * ProcessInstanceKey property with full advanced search capabilities.\n */\nexport type ProcessInstanceKeyFilterProperty = ProcessInstanceKey | AdvancedProcessInstanceKeyFilter;\n\n/**\n * Advanced filter\n * Advanced ElementInstanceKey filter.\n */\nexport type AdvancedElementInstanceKeyFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: ElementInstanceKey;\n    /**\n     * Checks for equality with the provided value.\n     */\n    $neq?: ElementInstanceKey;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<ElementInstanceKey>;\n    /**\n     * Checks if the property matches none of the provided values.\n     */\n    $notIn?: Array<ElementInstanceKey>;\n};\n\n/**\n * ElementInstanceKey property with full advanced search capabilities.\n */\nexport type ElementInstanceKeyFilterProperty = ElementInstanceKey | AdvancedElementInstanceKeyFilter;\n\n/**\n * Advanced filter\n * Advanced VariableKey filter.\n */\nexport type AdvancedVariableKeyFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: VariableKey;\n    /**\n     * Checks for equality with the provided value.\n     */\n    $neq?: VariableKey;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<VariableKey>;\n    /**\n     * Checks if the property matches none of the provided values.\n     */\n    $notIn?: Array<VariableKey>;\n};\n\n/**\n * VariableKey property with full advanced search capabilities.\n */\nexport type VariableKeyFilterProperty = VariableKey | AdvancedVariableKeyFilter;\n\n/**\n * Advanced filter\n * Advanced ScopeKey filter.\n */\nexport type AdvancedScopeKeyFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: ScopeKey;\n    /**\n     * Checks for equality with the provided value.\n     */\n    $neq?: ScopeKey;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<ScopeKey>;\n    /**\n     * Checks if the property matches none of the provided values.\n     */\n    $notIn?: Array<ScopeKey>;\n};\n\n/**\n * ScopeKey property with full advanced search capabilities.\n */\nexport type ScopeKeyFilterProperty = ScopeKey | AdvancedScopeKeyFilter;\n\n/**\n * Advanced filter\n * Advanced MessageSubscriptionKey filter.\n */\nexport type AdvancedMessageSubscriptionKeyFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: MessageSubscriptionKey;\n    /**\n     * Checks for equality with the provided value.\n     */\n    $neq?: MessageSubscriptionKey;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<MessageSubscriptionKey>;\n    /**\n     * Checks if the property matches none of the provided values.\n     */\n    $notIn?: Array<MessageSubscriptionKey>;\n};\n\n/**\n * MessageSubscriptionKey property with full advanced search capabilities.\n */\nexport type MessageSubscriptionKeyFilterProperty = MessageSubscriptionKey | AdvancedMessageSubscriptionKeyFilter;\n\n/**\n * Advanced filter\n * Advanced JobKey filter.\n */\nexport type AdvancedJobKeyFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: JobKey;\n    /**\n     * Checks for equality with the provided value.\n     */\n    $neq?: JobKey;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<JobKey>;\n    /**\n     * Checks if the property matches none of the provided values.\n     */\n    $notIn?: Array<JobKey>;\n};\n\n/**\n * JobKey property with full advanced search capabilities.\n */\nexport type JobKeyFilterProperty = JobKey | AdvancedJobKeyFilter;\n\n/**\n * Base process instance search filter.\n */\nexport type BaseProcessInstanceFilterFields = {\n    /**\n     * The start date.\n     */\n    startDate?: DateTimeFilterProperty;\n    /**\n     * The end date.\n     */\n    endDate?: DateTimeFilterProperty;\n    /**\n     * The process instance state.\n     */\n    state?: ProcessInstanceStateFilterProperty;\n    /**\n     * Whether this process instance has a related incident or not.\n     */\n    hasIncident?: boolean;\n    /**\n     * The tenant ID.\n     */\n    tenantId?: StringFilterProperty;\n    /**\n     * The process instance variables.\n     */\n    variables?: Array<VariableValueFilterProperty>;\n    /**\n     * The key of this process instance.\n     */\n    processInstanceKey?: ProcessInstanceKeyFilterProperty;\n    /**\n     * The parent process instance key.\n     */\n    parentProcessInstanceKey?: ProcessInstanceKeyFilterProperty;\n    /**\n     * The parent element instance key.\n     */\n    parentElementInstanceKey?: ElementInstanceKeyFilterProperty;\n    /**\n     * The batch operation ID.\n     */\n    batchOperationId?: StringFilterProperty;\n    /**\n     * The error message related to the process.\n     */\n    errorMessage?: StringFilterProperty;\n    /**\n     * Whether the process has failed jobs with retries left.\n     */\n    hasRetriesLeft?: boolean;\n    /**\n     * The state of the element instances associated with the process instance.\n     */\n    elementInstanceState?: ElementInstanceStateFilterProperty;\n    /**\n     * The element ID associated with the process instance.\n     */\n    elementId?: StringFilterProperty;\n    /**\n     * Whether the element instance has an incident or not.\n     */\n    hasElementInstanceIncident?: boolean;\n    /**\n     * The incident error hash code, associated with this process.\n     */\n    incidentErrorHashCode?: IntegerFilterProperty;\n    tags?: TagSet;\n};\n\n/**\n * Process definition statistics search filter.\n */\nexport type ProcessDefinitionStatisticsFilter = BaseProcessInstanceFilterFields & {\n    /**\n     * Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.\n     *\n     * Top-level fields and the `$or` clause are combined using AND logic — meaning: (top-level filters) AND (any of the `$or` filters) must match.\n     * <br>\n     * <em>Example:</em>\n     *\n     * ```json\n     * {\n     * \"state\": \"ACTIVE\",\n     * \"tenantId\": 123,\n     * \"$or\": [\n     * { \"processDefinitionId\": \"process_v1\" },\n     * { \"processDefinitionId\": \"process_v2\", \"hasIncident\": true }\n     * ]\n     * }\n     * ```\n     * This matches process instances that:\n     *\n     * <ul style=\"padding-left: 20px; margin-left: 20px;\">\n     * <li style=\"list-style-type: disc;\">are in <em>ACTIVE</em> state</li>\n     * <li style=\"list-style-type: disc;\">have tenant ID equal to <em>123</em></li>\n     * <li style=\"list-style-type: disc;\">and match either:\n     * <ul style=\"padding-left: 20px; margin-left: 20px;\">\n     * <li style=\"list-style-type: circle;\"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>\n     * <li style=\"list-style-type: circle;\"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>\n     * </ul>\n     * </li>\n     * </ul>\n     * <br>\n     * <p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.\n     *\n     */\n    $or?: Array<BaseProcessInstanceFilterFields>;\n};\n\n/**\n * Process instance search filter.\n */\nexport type ProcessInstanceFilterFields = BaseProcessInstanceFilterFields & {\n    /**\n     * The process definition ID.\n     */\n    processDefinitionId?: StringFilterProperty;\n    /**\n     * The process definition name.\n     */\n    processDefinitionName?: StringFilterProperty;\n    /**\n     * The process definition version.\n     */\n    processDefinitionVersion?: IntegerFilterProperty;\n    /**\n     * The process definition version tag.\n     */\n    processDefinitionVersionTag?: StringFilterProperty;\n    /**\n     * The process definition key.\n     */\n    processDefinitionKey?: ProcessDefinitionKeyFilterProperty;\n};\n\n/**\n * Process instance search filter.\n */\nexport type ProcessInstanceFilter = ProcessInstanceFilterFields & {\n    /**\n     * Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.\n     *\n     * Top-level fields and the `$or` clause are combined using AND logic — meaning: (top-level filters) AND (any of the `$or` filters) must match.\n     * <br>\n     * <em>Example:</em>\n     *\n     * ```json\n     * {\n     * \"state\": \"ACTIVE\",\n     * \"tenantId\": 123,\n     * \"$or\": [\n     * { \"processDefinitionId\": \"process_v1\" },\n     * { \"processDefinitionId\": \"process_v2\", \"hasIncident\": true }\n     * ]\n     * }\n     * ```\n     * This matches process instances that:\n     *\n     * <ul style=\"padding-left: 20px; margin-left: 20px;\">\n     * <li style=\"list-style-type: disc;\">are in <em>ACTIVE</em> state</li>\n     * <li style=\"list-style-type: disc;\">have tenant ID equal to <em>123</em></li>\n     * <li style=\"list-style-type: disc;\">and match either:\n     * <ul style=\"padding-left: 20px; margin-left: 20px;\">\n     * <li style=\"list-style-type: circle;\"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>\n     * <li style=\"list-style-type: circle;\"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>\n     * </ul>\n     * </li>\n     * </ul>\n     * <br>\n     * <p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.\n     *\n     */\n    $or?: Array<ProcessInstanceFilterFields>;\n};\n\n/**\n * Process instance search response.\n */\nexport type ProcessInstanceSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching process instances.\n     */\n    items: Array<ProcessInstanceResult>;\n};\n\n/**\n * Process instance search response item.\n */\nexport type ProcessInstanceResult = {\n    processDefinitionId: ProcessDefinitionId;\n    /**\n     * The process definition name.\n     */\n    processDefinitionName: string;\n    /**\n     * The process definition version.\n     */\n    processDefinitionVersion: number;\n    /**\n     * The process definition version tag.\n     */\n    processDefinitionVersionTag?: string;\n    /**\n     * The start date.\n     */\n    startDate: string;\n    /**\n     * The end date.\n     */\n    endDate?: string;\n    state: ProcessInstanceStateEnum;\n    /**\n     * Whether this process instance has a related incident or not.\n     */\n    hasIncident: boolean;\n    tenantId: TenantId;\n    /**\n     * The key of this process instance.\n     */\n    processInstanceKey: ProcessInstanceKey;\n    /**\n     * The process definition key.\n     */\n    processDefinitionKey: ProcessDefinitionKey;\n    /**\n     * The parent process instance key.\n     */\n    parentProcessInstanceKey?: ProcessInstanceKey;\n    /**\n     * The parent element instance key.\n     */\n    parentElementInstanceKey?: ElementInstanceKey;\n    tags?: TagSet;\n};\n\n/**\n * Process instance states\n */\nexport type ProcessInstanceStateEnum = 'ACTIVE' | 'COMPLETED' | 'TERMINATED';\n\n/**\n * Element states\n */\nexport type ElementInstanceStateEnum = 'ACTIVE' | 'COMPLETED' | 'TERMINATED';\n\nexport type ProcessInstanceCallHierarchyEntry = {\n    /**\n     * The key of the process instance.\n     */\n    processInstanceKey: ProcessInstanceKey;\n    /**\n     * The key of the process definition.\n     */\n    processDefinitionKey: ProcessDefinitionKey;\n    /**\n     * The name of the process definition (fall backs to the process definition ID if not available).\n     */\n    processDefinitionName: string;\n};\n\n/**\n * Process instance sequence flows query response.\n */\nexport type ProcessInstanceSequenceFlowsQueryResult = {\n    /**\n     * The sequence flows.\n     */\n    items?: Array<ProcessInstanceSequenceFlowResult>;\n};\n\n/**\n * Process instance sequence flow result.\n */\nexport type ProcessInstanceSequenceFlowResult = {\n    /**\n     * The sequence flow ID.\n     */\n    sequenceFlowId?: string;\n    /**\n     * The key of this process instance.\n     */\n    processInstanceKey?: ProcessInstanceKey;\n    /**\n     * The process definition key.\n     */\n    processDefinitionKey?: ProcessDefinitionKey;\n    /**\n     * The process definition ID.\n     */\n    processDefinitionId?: ProcessDefinitionId;\n    /**\n     * The element ID for this sequence flow, as provided in the BPMN process.\n     */\n    elementId?: ElementId;\n    tenantId?: TenantId;\n};\n\n/**\n * Process definition element statistics request.\n */\nexport type ProcessDefinitionElementStatisticsQuery = {\n    /**\n     * The process definition statistics search filters.\n     */\n    filter?: ProcessDefinitionStatisticsFilter;\n};\n\n/**\n * Process definition element statistics query response.\n */\nexport type ProcessDefinitionElementStatisticsQueryResult = {\n    /**\n     * The element statistics.\n     */\n    items?: Array<ProcessElementStatisticsResult>;\n};\n\n/**\n * Process instance element statistics query response.\n */\nexport type ProcessInstanceElementStatisticsQueryResult = {\n    /**\n     * The element statistics.\n     */\n    items?: Array<ProcessElementStatisticsResult>;\n};\n\n/**\n * Process element statistics response.\n */\nexport type ProcessElementStatisticsResult = {\n    /**\n     * The element ID for which the results are aggregated.\n     */\n    elementId?: ElementId;\n    /**\n     * The total number of active instances of the element.\n     */\n    active?: number;\n    /**\n     * The total number of canceled instances of the element.\n     */\n    canceled?: number;\n    /**\n     * The total number of incidents for the element.\n     */\n    incidents?: number;\n    /**\n     * The total number of completed instances of the element.\n     */\n    completed?: number;\n};\n\nexport type CancelProcessInstanceRequest = {\n    operationReference?: OperationReference;\n} | null;\n\nexport type ElementInstanceSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'elementInstanceKey' | 'processInstanceKey' | 'processDefinitionKey' | 'processDefinitionId' | 'startDate' | 'endDate' | 'elementId' | 'elementName' | 'type' | 'state' | 'incidentKey' | 'tenantId';\n    order?: SortOrderEnum;\n};\n\n/**\n * Element instance search request.\n */\nexport type ElementInstanceSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<ElementInstanceSearchQuerySortRequest>;\n    /**\n     * The element instance search filters.\n     */\n    filter?: ElementInstanceFilter;\n};\n\n/**\n * Element instance filter.\n */\nexport type ElementInstanceFilter = {\n    /**\n     * The process definition ID associated to this element instance.\n     */\n    processDefinitionId?: ProcessDefinitionId;\n    /**\n     * State of element instance as defined set of values.\n     */\n    state?: ElementInstanceStateFilterProperty;\n    /**\n     * Type of element as defined set of values.\n     */\n    type?: 'UNSPECIFIED' | 'PROCESS' | 'SUB_PROCESS' | 'EVENT_SUB_PROCESS' | 'AD_HOC_SUB_PROCESS' | 'AD_HOC_SUB_PROCESS_INNER_INSTANCE' | 'START_EVENT' | 'INTERMEDIATE_CATCH_EVENT' | 'INTERMEDIATE_THROW_EVENT' | 'BOUNDARY_EVENT' | 'END_EVENT' | 'SERVICE_TASK' | 'RECEIVE_TASK' | 'USER_TASK' | 'MANUAL_TASK' | 'TASK' | 'EXCLUSIVE_GATEWAY' | 'INCLUSIVE_GATEWAY' | 'PARALLEL_GATEWAY' | 'EVENT_BASED_GATEWAY' | 'SEQUENCE_FLOW' | 'MULTI_INSTANCE_BODY' | 'CALL_ACTIVITY' | 'BUSINESS_RULE_TASK' | 'SCRIPT_TASK' | 'SEND_TASK' | 'UNKNOWN';\n    /**\n     * The element ID for this element instance.\n     */\n    elementId?: ElementId;\n    /**\n     * The element name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.\n     *\n     */\n    elementName?: string;\n    /**\n     * Shows whether this element instance has an incident related to.\n     */\n    hasIncident?: boolean;\n    tenantId?: TenantId;\n    /**\n     * The assigned key, which acts as a unique identifier for this element instance.\n     */\n    elementInstanceKey?: ElementInstanceKey;\n    /**\n     * The process instance key associated to this element instance.\n     */\n    processInstanceKey?: ProcessInstanceKey;\n    /**\n     * The process definition key associated to this element instance.\n     */\n    processDefinitionKey?: ProcessDefinitionKey;\n    /**\n     * The key of incident if field incident is true.\n     */\n    incidentKey?: IncidentKey;\n    /**\n     * The start date of this element instance.\n     */\n    startDate?: DateTimeFilterProperty;\n    /**\n     * The end date of this element instance.\n     */\n    endDate?: DateTimeFilterProperty;\n    /**\n     * The scope key of this element instance. If provided with a process instance key it will return element instances that are immediate children of the process instance. If provided with an element instance key it will return element instances that are immediate children of the element instance.\n     *\n     */\n    elementInstanceScopeKey?: ElementInstanceKey | ProcessInstanceKey;\n};\n\nexport type ElementInstanceSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching element instances.\n     */\n    items?: Array<ElementInstanceResult>;\n};\n\nexport type ElementInstanceResult = {\n    /**\n     * The process definition ID associated to this element instance.\n     */\n    processDefinitionId: ProcessDefinitionId;\n    /**\n     * Date when element instance started.\n     */\n    startDate: string;\n    /**\n     * Date when element instance finished.\n     */\n    endDate?: string;\n    /**\n     * The element ID for this element instance.\n     */\n    elementId: ElementId;\n    /**\n     * The element name for this element instance.\n     */\n    elementName: string;\n    /**\n     * Type of element as defined set of values.\n     */\n    type: 'UNSPECIFIED' | 'PROCESS' | 'SUB_PROCESS' | 'EVENT_SUB_PROCESS' | 'AD_HOC_SUB_PROCESS' | 'AD_HOC_SUB_PROCESS_INNER_INSTANCE' | 'START_EVENT' | 'INTERMEDIATE_CATCH_EVENT' | 'INTERMEDIATE_THROW_EVENT' | 'BOUNDARY_EVENT' | 'END_EVENT' | 'SERVICE_TASK' | 'RECEIVE_TASK' | 'USER_TASK' | 'MANUAL_TASK' | 'TASK' | 'EXCLUSIVE_GATEWAY' | 'INCLUSIVE_GATEWAY' | 'PARALLEL_GATEWAY' | 'EVENT_BASED_GATEWAY' | 'SEQUENCE_FLOW' | 'MULTI_INSTANCE_BODY' | 'CALL_ACTIVITY' | 'BUSINESS_RULE_TASK' | 'SCRIPT_TASK' | 'SEND_TASK' | 'UNKNOWN';\n    /**\n     * State of element instance as defined set of values.\n     */\n    state: ElementInstanceStateEnum;\n    /**\n     * Shows whether this element instance has an incident. If true also an incidentKey is provided.\n     */\n    hasIncident: boolean;\n    /**\n     * The tenant ID of the incident.\n     */\n    tenantId: TenantId;\n    /**\n     * The assigned key, which acts as a unique identifier for this element instance.\n     */\n    elementInstanceKey: ElementInstanceKey;\n    /**\n     * The process instance key associated to this element instance.\n     */\n    processInstanceKey: ProcessInstanceKey;\n    /**\n     * The process definition key associated to this element instance.\n     */\n    processDefinitionKey: ProcessDefinitionKey;\n    /**\n     * Incident key associated with this element instance.\n     */\n    incidentKey?: IncidentKey;\n};\n\nexport type AdHocSubProcessActivateActivitiesInstruction = {\n    /**\n     * Activities to activate.\n     */\n    elements: Array<AdHocSubProcessActivateActivityReference>;\n    /**\n     * Whether to cancel remaining instances of the ad-hoc sub-process.\n     */\n    cancelRemainingInstances?: boolean;\n};\n\nexport type AdHocSubProcessActivateActivityReference = {\n    /**\n     * The ID of the element that should be activated.\n     */\n    elementId: ElementId;\n    /**\n     * Variables to be set when activating the element.\n     */\n    variables?: {\n        [key: string]: unknown;\n    };\n};\n\nexport type DecisionDefinitionSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'decisionDefinitionKey' | 'decisionDefinitionId' | 'name' | 'version' | 'decisionRequirementsId' | 'decisionRequirementsKey' | 'tenantId';\n    order?: SortOrderEnum;\n};\n\nexport type DecisionDefinitionSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<DecisionDefinitionSearchQuerySortRequest>;\n    /**\n     * The decision definition search filters.\n     */\n    filter?: DecisionDefinitionFilter;\n};\n\n/**\n * Decision definition search filter.\n */\nexport type DecisionDefinitionFilter = {\n    /**\n     * The DMN ID of the decision definition.\n     */\n    decisionDefinitionId?: DecisionDefinitionId;\n    /**\n     * The DMN name of the decision definition.\n     */\n    name?: string;\n    /**\n     * The assigned version of the decision definition.\n     */\n    version?: number;\n    /**\n     * the DMN ID of the decision requirements graph that the decision definition is part of.\n     */\n    decisionRequirementsId?: string;\n    /**\n     * The tenant ID of the decision definition.\n     */\n    tenantId?: TenantId;\n    /**\n     * The assigned key, which acts as a unique identifier for this decision definition.\n     */\n    decisionDefinitionKey?: DecisionDefinitionKey;\n    /**\n     * The assigned key of the decision requirements graph that the decision definition is part of.\n     */\n    decisionRequirementsKey?: DecisionRequirementsKey;\n};\n\nexport type IncidentSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'incidentKey' | 'processDefinitionKey' | 'processDefinitionId' | 'processInstanceKey' | 'errorType' | 'errorMessage' | 'elementId' | 'elementInstanceKey' | 'creationTime' | 'state' | 'jobKey' | 'tenantId';\n    order?: SortOrderEnum;\n};\n\nexport type IncidentSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<IncidentSearchQuerySortRequest>;\n    /**\n     * The incident search filters.\n     */\n    filter?: IncidentFilter;\n};\n\n/**\n * Incident search filter.\n */\nexport type IncidentFilter = {\n    /**\n     * The process definition ID associated to this incident.\n     */\n    processDefinitionId?: ProcessDefinitionId;\n    /**\n     * Incident error type with a defined set of values.\n     */\n    errorType?: 'UNSPECIFIED' | 'UNKNOWN' | 'IO_MAPPING_ERROR' | 'JOB_NO_RETRIES' | 'EXECUTION_LISTENER_NO_RETRIES' | 'TASK_LISTENER_NO_RETRIES' | 'AD_HOC_SUB_PROCESS_NO_RETRIES' | 'CONDITION_ERROR' | 'EXTRACT_VALUE_ERROR' | 'CALLED_ELEMENT_ERROR' | 'UNHANDLED_ERROR_EVENT' | 'MESSAGE_SIZE_EXCEEDED' | 'CALLED_DECISION_ERROR' | 'DECISION_EVALUATION_ERROR' | 'FORM_NOT_FOUND' | 'RESOURCE_NOT_FOUND';\n    /**\n     * Error message which describes the error in more detail.\n     */\n    errorMessage?: string;\n    /**\n     * The element ID associated to this incident.\n     */\n    elementId?: ElementId;\n    /**\n     * Date of incident creation.\n     */\n    creationTime?: string;\n    /**\n     * State of this incident with a defined set of values.\n     */\n    state?: 'ACTIVE' | 'MIGRATED' | 'RESOLVED' | 'PENDING';\n    /**\n     * The tenant ID of the incident.\n     */\n    tenantId?: TenantId;\n    /**\n     * The assigned key, which acts as a unique identifier for this incident.\n     */\n    incidentKey?: IncidentKey;\n    /**\n     * The process definition key associated to this incident.\n     */\n    processDefinitionKey?: ProcessDefinitionKey;\n    /**\n     * The process instance key associated to this incident.\n     */\n    processInstanceKey?: ProcessInstanceKey;\n    /**\n     * The element instance key associated to this incident.\n     */\n    elementInstanceKey?: ElementInstanceKey;\n    /**\n     * The job key, if exists, associated with this incident.\n     */\n    jobKey?: JobKey;\n};\n\nexport type IncidentSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching incidents.\n     */\n    items?: Array<IncidentResult>;\n};\n\nexport type CorrelatedMessageSubscriptionSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching correlated message subscriptions.\n     */\n    items?: Array<CorrelatedMessageSubscriptionResult>;\n};\n\nexport type CorrelatedMessageSubscriptionResult = {\n    /**\n     * The correlation key of the message.\n     */\n    correlationKey: string;\n    /**\n     * The time when the message was correlated.\n     */\n    correlationTime: string;\n    /**\n     * The element ID that received the message.\n     */\n    elementId: string;\n    /**\n     * The element instance key that received the message.\n     */\n    elementInstanceKey?: ElementInstanceKey;\n    /**\n     * The message key.\n     */\n    messageKey: MessageKey;\n    /**\n     * The name of the message.\n     */\n    messageName: string;\n    /**\n     * The partition ID that correlated the message.\n     */\n    partitionId: number;\n    /**\n     * The process definition ID associated with this correlated message subscription.\n     */\n    processDefinitionId: ProcessDefinitionId;\n    /**\n     * The process definition key associated with this correlated message subscription.\n     */\n    processDefinitionKey?: ProcessDefinitionKey;\n    /**\n     * The process instance key associated with this correlated message subscription.\n     */\n    processInstanceKey: ProcessInstanceKey;\n    /**\n     * The subscription key that received the message.\n     */\n    subscriptionKey: MessageSubscriptionKey;\n    /**\n     * The tenant ID associated with this correlated message subscription.\n     */\n    tenantId: TenantId;\n};\n\nexport type CorrelatedMessageSubscriptionSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<CorrelatedMessageSubscriptionSearchQuerySortRequest>;\n    /**\n     * The correlated message subscriptions search filters.\n     */\n    filter?: CorrelatedMessageSubscriptionFilter;\n};\n\nexport type CorrelatedMessageSubscriptionSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'correlationKey' | 'correlationTime' | 'elementId' | 'elementInstanceKey' | 'messageKey' | 'messageName' | 'partitionId' | 'processDefinitionId' | 'processDefinitionKey' | 'processInstanceKey' | 'subscriptionKey' | 'tenantId';\n    order?: SortOrderEnum;\n};\n\n/**\n * Correlated message subscriptions search filter.\n */\nexport type CorrelatedMessageSubscriptionFilter = {\n    /**\n     * The correlation key of the message.\n     */\n    correlationKey?: StringFilterProperty;\n    /**\n     * The time when the message was correlated.\n     */\n    correlationTime?: DateTimeFilterProperty;\n    /**\n     * The element ID that received the message.\n     */\n    elementId?: StringFilterProperty;\n    /**\n     * The element instance key that received the message.\n     */\n    elementInstanceKey?: ElementInstanceKeyFilterProperty;\n    /**\n     * The message key.\n     */\n    messageKey?: BasicStringFilterProperty;\n    /**\n     * The name of the message.\n     */\n    messageName?: StringFilterProperty;\n    /**\n     * The partition ID that correlated the message.\n     */\n    partitionId?: IntegerFilterProperty;\n    /**\n     * The process definition ID associated with this correlated message subscription.\n     */\n    processDefinitionId?: StringFilterProperty;\n    /**\n     * The process definition key associated with this correlated message subscription.\n     */\n    processDefinitionKey?: BasicStringFilterProperty;\n    /**\n     * The process instance key associated with this correlated message subscription.\n     */\n    processInstanceKey?: BasicStringFilterProperty;\n    /**\n     * The subscription key that received the message.\n     */\n    subscriptionKey?: BasicStringFilterProperty;\n    /**\n     * The tenant ID associated with this correlated message subscription.\n     */\n    tenantId?: StringFilterProperty;\n};\n\nexport type MessageSubscriptionSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching message subscriptions.\n     */\n    items?: Array<MessageSubscriptionResult>;\n};\n\nexport type MessageSubscriptionResult = {\n    /**\n     * The message subscription key associated with this message subscription.\n     */\n    messageSubscriptionKey?: MessageSubscriptionKey;\n    /**\n     * The process definition ID associated with this message subscription.\n     */\n    processDefinitionId?: ProcessDefinitionId;\n    /**\n     * The process definition key associated with this message subscription.\n     */\n    processDefinitionKey?: ProcessDefinitionKey;\n    /**\n     * The process instance key associated with this message subscription.\n     */\n    processInstanceKey?: ProcessInstanceKey;\n    /**\n     * The element ID associated with this message subscription.\n     */\n    elementId?: ElementId;\n    /**\n     * The element instance key associated with this message subscription.\n     */\n    elementInstanceKey?: ElementInstanceKey;\n    messageSubscriptionState?: MessageSubscriptionStateEnum;\n    /**\n     * The last updated date of the message subscription.\n     */\n    lastUpdatedDate?: string;\n    /**\n     * The name of the message associated with the message subscription.\n     */\n    messageName?: string;\n    /**\n     * The correlation key of the message subscription.\n     */\n    correlationKey?: MessageCorrelationKey;\n    tenantId?: TenantId;\n};\n\nexport type MessageSubscriptionSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'messageSubscriptionKey' | 'processDefinitionId' | 'processInstanceKey' | 'elementId' | 'elementInstanceKey' | 'messageSubscriptionState' | 'lastUpdatedDate' | 'messageName' | 'correlationKey' | 'tenantId';\n    order?: SortOrderEnum;\n};\n\nexport type MessageSubscriptionSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<MessageSubscriptionSearchQuerySortRequest>;\n    /**\n     * The incident search filters.\n     */\n    filter?: MessageSubscriptionFilter;\n};\n\n/**\n * Message subscription search filter.\n */\nexport type MessageSubscriptionFilter = {\n    /**\n     * The message subscription key associated with this message subscription.\n     */\n    messageSubscriptionKey?: MessageSubscriptionKeyFilterProperty;\n    /**\n     * The process definition ID associated with this message subscription.\n     */\n    processDefinitionId?: StringFilterProperty;\n    /**\n     * The process instance key associated with this message subscription.\n     */\n    processInstanceKey?: ProcessInstanceKeyFilterProperty;\n    /**\n     * The element ID associated with this message subscription.\n     */\n    elementId?: StringFilterProperty;\n    /**\n     * The element instance key associated with this message subscription.\n     */\n    elementInstanceKey?: ElementInstanceKeyFilterProperty;\n    /**\n     * The message subscription state.\n     */\n    messageSubscriptionState?: MessageSubscriptionStateFilterProperty;\n    /**\n     * The last updated date of the message subscription.\n     */\n    lastUpdatedDate?: DateTimeFilterProperty;\n    /**\n     * The name of the message associated with the message subscription.\n     */\n    messageName?: StringFilterProperty;\n    /**\n     * The correlation key of the message subscription.\n     */\n    correlationKey?: StringFilterProperty;\n    /**\n     * The unique external tenant ID.\n     */\n    tenantId?: StringFilterProperty;\n};\n\n/**\n * MessageSubscriptionStateEnum with full advanced search capabilities.\n */\nexport type MessageSubscriptionStateFilterProperty = MessageSubscriptionStateEnum | AdvancedMessageSubscriptionStateFilter;\n\n/**\n * The state of message subscription.\n */\nexport type MessageSubscriptionStateEnum = 'CORRELATED' | 'CREATED' | 'DELETED' | 'MIGRATED';\n\n/**\n * Advanced filter\n * Advanced MessageSubscriptionStateEnum filter\n */\nexport type AdvancedMessageSubscriptionStateFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: MessageSubscriptionStateEnum;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: MessageSubscriptionStateEnum;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<MessageSubscriptionStateEnum>;\n    $like?: LikeFilter;\n};\n\nexport type IncidentResult = {\n    /**\n     * The process definition ID associated to this incident.\n     */\n    processDefinitionId?: ProcessDefinitionId;\n    /**\n     * Incident error type with a defined set of values.\n     */\n    errorType?: 'UNSPECIFIED' | 'UNKNOWN' | 'IO_MAPPING_ERROR' | 'JOB_NO_RETRIES' | 'EXECUTION_LISTENER_NO_RETRIES' | 'TASK_LISTENER_NO_RETRIES' | 'AD_HOC_SUB_PROCESS_NO_RETRIES' | 'CONDITION_ERROR' | 'EXTRACT_VALUE_ERROR' | 'CALLED_ELEMENT_ERROR' | 'UNHANDLED_ERROR_EVENT' | 'MESSAGE_SIZE_EXCEEDED' | 'CALLED_DECISION_ERROR' | 'DECISION_EVALUATION_ERROR' | 'FORM_NOT_FOUND' | 'RESOURCE_NOT_FOUND';\n    /**\n     * Error message which describes the error in more detail.\n     */\n    errorMessage?: string;\n    /**\n     * The element ID associated to this incident.\n     */\n    elementId?: ElementId;\n    /**\n     * Date of incident creation.\n     */\n    creationTime?: string;\n    /**\n     * State of this incident with a defined set of values.\n     */\n    state?: 'ACTIVE' | 'MIGRATED' | 'RESOLVED' | 'PENDING';\n    /**\n     * The tenant ID of the incident.\n     */\n    tenantId?: TenantId;\n    /**\n     * The assigned key, which acts as a unique identifier for this incident.\n     */\n    incidentKey?: IncidentKey;\n    /**\n     * The process definition key associated to this incident.\n     */\n    processDefinitionKey?: ProcessDefinitionKey;\n    /**\n     * The process instance key associated to this incident.\n     */\n    processInstanceKey?: ProcessInstanceKey;\n    /**\n     * The element instance key associated to this incident.\n     */\n    elementInstanceKey?: ElementInstanceKey;\n    /**\n     * The job key, if exists, associated with this incident.\n     */\n    jobKey?: JobKey;\n};\n\nexport type DecisionDefinitionSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching decision definitions.\n     */\n    items?: Array<DecisionDefinitionResult>;\n};\n\nexport type DecisionDefinitionResult = {\n    /**\n     * The DMN ID of the decision definition.\n     */\n    decisionDefinitionId?: DecisionDefinitionId;\n    /**\n     * The DMN name of the decision definition.\n     */\n    name?: string;\n    /**\n     * The assigned version of the decision definition.\n     */\n    version?: number;\n    /**\n     * the DMN ID of the decision requirements graph that the decision definition is part of.\n     */\n    decisionRequirementsId?: string;\n    /**\n     * The tenant ID of the decision definition.\n     */\n    tenantId?: TenantId;\n    /**\n     * The assigned key, which acts as a unique identifier for this decision definition.\n     */\n    decisionDefinitionKey?: DecisionDefinitionKey;\n    /**\n     * The assigned key of the decision requirements graph that the decision definition is part of.\n     */\n    decisionRequirementsKey?: DecisionRequirementsKey;\n};\n\nexport type UsageMetricsResponse = UsageMetricsResponseItem & {\n    /**\n     * The amount of active tenants.\n     */\n    activeTenants?: number;\n    /**\n     * The usage metrics by tenants. Only available if request `withTenants` query parameter was `true`.\n     */\n    tenants?: {\n        [key: string]: UsageMetricsResponseItem;\n    };\n};\n\nexport type UsageMetricsResponseItem = {\n    /**\n     * The amount of created root process instances.\n     */\n    processInstances?: number;\n    /**\n     * The amount of executed decision instances.\n     */\n    decisionInstances?: number;\n    /**\n     * The amount of unique active task users.\n     */\n    assignees?: number;\n};\n\n/**\n * Specifies the type of permissions.\n */\nexport type PermissionTypeEnum = 'ACCESS' | 'CREATE' | 'CREATE_BATCH_OPERATION_CANCEL_PROCESS_INSTANCE' | 'CREATE_BATCH_OPERATION_DELETE_PROCESS_INSTANCE' | 'CREATE_BATCH_OPERATION_MIGRATE_PROCESS_INSTANCE' | 'CREATE_BATCH_OPERATION_MODIFY_PROCESS_INSTANCE' | 'CREATE_BATCH_OPERATION_RESOLVE_INCIDENT' | 'CREATE_BATCH_OPERATION_DELETE_DECISION_INSTANCE' | 'CREATE_BATCH_OPERATION_DELETE_DECISION_DEFINITION' | 'CREATE_BATCH_OPERATION_DELETE_PROCESS_DEFINITION' | 'CREATE_PROCESS_INSTANCE' | 'CREATE_DECISION_INSTANCE' | 'READ' | 'READ_PROCESS_INSTANCE' | 'READ_USER_TASK' | 'READ_DECISION_INSTANCE' | 'READ_PROCESS_DEFINITION' | 'READ_DECISION_DEFINITION' | 'READ_USAGE_METRIC' | 'UPDATE' | 'UPDATE_PROCESS_INSTANCE' | 'UPDATE_USER_TASK' | 'CANCEL_PROCESS_INSTANCE' | 'MODIFY_PROCESS_INSTANCE' | 'DELETE' | 'DELETE_PROCESS' | 'DELETE_DRD' | 'DELETE_FORM' | 'DELETE_RESOURCE' | 'DELETE_PROCESS_INSTANCE' | 'DELETE_DECISION_INSTANCE';\n\n/**\n * The type of resource to add/remove permissions to/from.\n */\nexport type ResourceTypeEnum = 'AUTHORIZATION' | 'MAPPING_RULE' | 'MESSAGE' | 'BATCH' | 'COMPONENT' | 'SYSTEM' | 'TENANT' | 'RESOURCE' | 'PROCESS_DEFINITION' | 'DECISION_REQUIREMENTS_DEFINITION' | 'DECISION_DEFINITION' | 'GROUP' | 'USER' | 'ROLE' | 'DOCUMENT';\n\n/**\n * The type of the owner of permissions.\n */\nexport type OwnerTypeEnum = 'USER' | 'CLIENT' | 'ROLE' | 'GROUP' | 'MAPPING_RULE' | 'UNSPECIFIED';\n\nexport type AuthorizationRequest = {\n    /**\n     * The ID of the owner of the permissions.\n     */\n    ownerId: string;\n    ownerType: OwnerTypeEnum;\n    /**\n     * The ID of the resource to add permissions to.\n     */\n    resourceId: string;\n    /**\n     * The type of resource to add permissions to.\n     */\n    resourceType: ResourceTypeEnum;\n    /**\n     * The permission types to add.\n     */\n    permissionTypes: Array<PermissionTypeEnum>;\n};\n\nexport type AuthorizationCreateResult = {\n    /**\n     * The key of the created authorization.\n     */\n    authorizationKey?: AuthorizationKey;\n};\n\nexport type AuthorizationSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'ownerId' | 'ownerType' | 'resourceId' | 'resourceType';\n    order?: SortOrderEnum;\n};\n\nexport type AuthorizationSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<AuthorizationSearchQuerySortRequest>;\n    /**\n     * The authorization search filters.\n     */\n    filter?: AuthorizationFilter;\n};\n\n/**\n * Authorization search filter.\n */\nexport type AuthorizationFilter = {\n    /**\n     * The ID of the owner of permissions.\n     */\n    ownerId?: string;\n    ownerType?: OwnerTypeEnum;\n    /**\n     * The IDs of the resource to search permissions for.\n     */\n    resourceIds?: Array<string>;\n    /**\n     * The type of resource to search permissions for.\n     */\n    resourceType?: ResourceTypeEnum;\n};\n\nexport type AuthorizationResult = {\n    /**\n     * The ID of the owner of permissions.\n     */\n    ownerId?: string;\n    ownerType?: OwnerTypeEnum;\n    /**\n     * The type of resource that the permissions relate to.\n     */\n    resourceType?: ResourceTypeEnum;\n    /**\n     * ID of the resource the permission relates to.\n     */\n    resourceId?: string;\n    /**\n     * Specifies the types of the permissions.\n     */\n    permissionTypes?: Array<PermissionTypeEnum>;\n    /**\n     * The key of the authorization.\n     */\n    authorizationKey?: AuthorizationKey;\n};\n\nexport type AuthorizationSearchResult = SearchQueryResponse & {\n    /**\n     * The matching authorizations.\n     */\n    items?: Array<AuthorizationResult>;\n};\n\nexport type UserRequest = {\n    /**\n     * The password of the user.\n     */\n    password: string;\n    /**\n     * The username of the user.\n     */\n    username: string;\n    /**\n     * The name of the user.\n     */\n    name?: string;\n    /**\n     * The email of the user.\n     */\n    email?: string;\n};\n\nexport type UserCreateResult = {\n    username?: Username;\n    /**\n     * The name of the user.\n     */\n    name?: string;\n    /**\n     * The email of the user.\n     */\n    email?: string;\n};\n\nexport type UserUpdateResult = {\n    username?: Username;\n    /**\n     * The name of the user.\n     */\n    name?: string;\n    /**\n     * The email of the user.\n     */\n    email?: string;\n};\n\nexport type UserSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'username' | 'name' | 'email';\n    order?: SortOrderEnum;\n};\n\nexport type UserSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<UserSearchQuerySortRequest>;\n    /**\n     * The user search filters.\n     */\n    filter?: UserFilter;\n};\n\nexport type MappingRuleSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'mappingRuleId' | 'claimName' | 'claimValue' | 'name';\n    order?: SortOrderEnum;\n};\n\nexport type MappingRuleSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<MappingRuleSearchQuerySortRequest>;\n    /**\n     * The mapping rule search filters.\n     */\n    filter?: MappingRuleFilter;\n};\n\n/**\n * User search filter.\n */\nexport type UserFilter = {\n    /**\n     * The username of the user.\n     */\n    username?: StringFilterProperty;\n    /**\n     * The name of the user.\n     */\n    name?: StringFilterProperty;\n    /**\n     * The email of the user.\n     */\n    email?: StringFilterProperty;\n};\n\n/**\n * Mapping rule search filter.\n */\nexport type MappingRuleFilter = {\n    /**\n     * The claim name to match against a token.\n     */\n    claimName?: string;\n    /**\n     * The value of the claim to match.\n     */\n    claimValue?: string;\n    /**\n     * The name of the mapping rule.\n     */\n    name?: string;\n    /**\n     * The ID of the mapping rule.\n     */\n    mappingRuleId?: string;\n};\n\nexport type CamundaUserResult = {\n    /**\n     * The username of the user.\n     */\n    username?: Username | null;\n    /**\n     * The display name of the user.\n     */\n    displayName?: string | null;\n    /**\n     * The email of the user.\n     */\n    email?: string | null;\n    /**\n     * The web components the user is authorized to use.\n     */\n    authorizedComponents?: Array<string>;\n    /**\n     * The tenants the user is a member of.\n     */\n    tenants: Array<TenantResult>;\n    /**\n     * The groups assigned to the user.\n     */\n    groups: Array<string>;\n    /**\n     * The roles assigned to the user.\n     */\n    roles: Array<string>;\n    /**\n     * The plan of the user.\n     */\n    salesPlanType: string;\n    /**\n     * The links to the components in the C8 stack.\n     */\n    c8Links: {\n        [key: string]: string;\n    };\n    /**\n     * Flag for understanding if the user is able to perform logout.\n     */\n    canLogout: boolean;\n};\n\nexport type UserResult = {\n    username?: Username;\n    /**\n     * The name of the user.\n     */\n    name?: string;\n    /**\n     * The email of the user.\n     */\n    email?: string;\n};\n\nexport type UserSearchResult = SearchQueryResponse & {\n    /**\n     * The matching users.\n     */\n    items: Array<UserResult>;\n};\n\nexport type UserUpdateRequest = {\n    /**\n     * The password of the user. If blank, the password is unchanged.\n     */\n    password?: string;\n    /**\n     * The name of the user.\n     */\n    name?: string;\n    /**\n     * The email of the user.\n     */\n    email?: string;\n};\n\nexport type TenantClientResult = {\n    /**\n     * The ID of the client.\n     */\n    clientId?: string;\n};\n\nexport type TenantClientSearchResult = SearchQueryResponse & {\n    /**\n     * The matching clients.\n     */\n    items?: Array<TenantClientResult>;\n};\n\nexport type TenantClientSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<TenantClientSearchQuerySortRequest>;\n};\n\nexport type TenantClientSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'clientId';\n    order?: SortOrderEnum;\n};\n\nexport type TenantUserResult = {\n    username?: Username;\n};\n\nexport type TenantUserSearchResult = SearchQueryResponse & {\n    /**\n     * The matching users.\n     */\n    items?: Array<TenantUserResult>;\n};\n\nexport type TenantUserSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<TenantUserSearchQuerySortRequest>;\n};\n\nexport type TenantUserSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'username';\n    order?: SortOrderEnum;\n};\n\nexport type TenantGroupResult = {\n    /**\n     * The groupId of the group.\n     */\n    groupId?: string;\n};\n\nexport type TenantGroupSearchResult = SearchQueryResponse & {\n    /**\n     * The matching groups.\n     */\n    items?: Array<TenantGroupResult>;\n};\n\nexport type TenantGroupSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<TenantGroupSearchQuerySortRequest>;\n};\n\nexport type TenantGroupSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'groupId';\n    order?: SortOrderEnum;\n};\n\nexport type RoleCreateRequest = {\n    /**\n     * The ID of the new role.\n     */\n    roleId: string;\n    /**\n     * The display name of the new role.\n     */\n    name: string;\n    /**\n     * The description of the new role.\n     */\n    description?: string;\n};\n\nexport type RoleCreateResult = {\n    /**\n     * The ID of the created role.\n     */\n    roleId?: string;\n    /**\n     * The display name of the created role.\n     */\n    name?: string;\n    /**\n     * The description of the created role.\n     */\n    description?: string;\n};\n\nexport type RoleUpdateRequest = {\n    /**\n     * The display name of the new role.\n     */\n    name: string;\n    /**\n     * The description of the new role.\n     */\n    description: string;\n};\n\nexport type RoleUpdateResult = {\n    /**\n     * The display name of the updated role.\n     */\n    name?: string;\n    /**\n     * The description of the updated role.\n     */\n    description?: string;\n    /**\n     * The ID of the updated role.\n     */\n    roleId?: string;\n};\n\n/**\n * Role search response item.\n */\nexport type RoleResult = {\n    /**\n     * The role name.\n     */\n    name?: string;\n    /**\n     * The role id.\n     */\n    roleId?: string;\n    /**\n     * The description of the role.\n     */\n    description?: string;\n};\n\nexport type RoleSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'name' | 'roleId';\n    order?: SortOrderEnum;\n};\n\n/**\n * Role search request.\n */\nexport type RoleSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<RoleSearchQuerySortRequest>;\n    /**\n     * The role search filters.\n     */\n    filter?: RoleFilter;\n};\n\n/**\n * Role filter request\n */\nexport type RoleFilter = {\n    /**\n     * The role ID search filters.\n     */\n    roleId?: string;\n    /**\n     * The role name search filters.\n     */\n    name?: string;\n};\n\n/**\n * Role search response.\n */\nexport type RoleSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching roles.\n     */\n    items?: Array<RoleResult>;\n};\n\nexport type RoleUserResult = {\n    username?: Username;\n};\n\nexport type RoleUserSearchResult = SearchQueryResponse & {\n    /**\n     * The matching users.\n     */\n    items?: Array<RoleUserResult>;\n};\n\nexport type RoleUserSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<RoleUserSearchQuerySortRequest>;\n};\n\nexport type RoleUserSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'username';\n    order?: SortOrderEnum;\n};\n\nexport type RoleClientResult = {\n    /**\n     * The ID of the client.\n     */\n    clientId?: string;\n};\n\nexport type RoleClientSearchResult = SearchQueryResponse & {\n    /**\n     * The matching clients.\n     */\n    items?: Array<RoleClientResult>;\n};\n\nexport type RoleClientSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<RoleClientSearchQuerySortRequest>;\n};\n\nexport type RoleClientSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'clientId';\n    order?: SortOrderEnum;\n};\n\nexport type RoleGroupResult = {\n    /**\n     * The id of the group.\n     */\n    groupId?: string;\n};\n\nexport type RoleGroupSearchResult = SearchQueryResponse & {\n    /**\n     * The matching groups.\n     */\n    items?: Array<RoleGroupResult>;\n};\n\nexport type RoleGroupSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<RoleGroupSearchQuerySortRequest>;\n};\n\nexport type RoleGroupSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'groupId';\n    order?: SortOrderEnum;\n};\n\nexport type GroupCreateRequest = {\n    /**\n     * The ID of the new group.\n     */\n    groupId: string;\n    /**\n     * The display name of the new group.\n     */\n    name: string;\n    /**\n     * The description of the new group.\n     */\n    description?: string;\n};\n\nexport type GroupCreateResult = {\n    /**\n     * The ID of the created group.\n     */\n    groupId?: string;\n    /**\n     * The display name of the created group.\n     */\n    name?: string;\n    /**\n     * The description of the created group.\n     */\n    description?: string;\n};\n\nexport type GroupUpdateRequest = {\n    /**\n     * The new name of the group.\n     */\n    name: string;\n    /**\n     * The new description of the group.\n     */\n    description: string;\n};\n\nexport type GroupUpdateResult = {\n    /**\n     * The unique external group ID.\n     */\n    groupId?: string;\n    /**\n     * The name of the group.\n     */\n    name?: string;\n    /**\n     * The description of the group.\n     */\n    description?: string;\n};\n\n/**\n * Group search response item.\n */\nexport type GroupResult = {\n    /**\n     * The group name.\n     */\n    name?: string;\n    /**\n     * The group ID.\n     */\n    groupId?: string;\n    /**\n     * The group description.\n     */\n    description?: string;\n};\n\nexport type GroupSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'name' | 'groupId';\n    order?: SortOrderEnum;\n};\n\n/**\n * Group search request.\n */\nexport type GroupSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<GroupSearchQuerySortRequest>;\n    /**\n     * The group search filters.\n     */\n    filter?: GroupFilter;\n};\n\n/**\n * Group filter request\n */\nexport type GroupFilter = {\n    /**\n     * The group ID search filters.\n     */\n    groupId?: StringFilterProperty;\n    /**\n     * The group name search filters.\n     */\n    name?: string;\n};\n\n/**\n * Group search response.\n */\nexport type GroupSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching groups.\n     */\n    items?: Array<GroupResult>;\n};\n\nexport type GroupUserResult = {\n    username?: Username;\n};\n\nexport type GroupUserSearchResult = SearchQueryResponse & {\n    /**\n     * The matching members.\n     */\n    items?: Array<GroupUserResult>;\n};\n\nexport type GroupUserSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<GroupUserSearchQuerySortRequest>;\n};\n\nexport type GroupUserSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'username';\n    order?: SortOrderEnum;\n};\n\nexport type GroupClientResult = {\n    /**\n     * The ID of the client.\n     */\n    clientId?: string;\n};\n\nexport type GroupClientSearchResult = SearchQueryResponse & {\n    /**\n     * The matching client IDs.\n     */\n    items?: Array<GroupClientResult>;\n};\n\nexport type GroupClientSearchQueryRequest = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<GroupClientSearchQuerySortRequest>;\n};\n\nexport type GroupClientSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'clientId';\n    order?: SortOrderEnum;\n};\n\nexport type MappingRuleCreateUpdateRequest = {\n    /**\n     * The name of the claim to map.\n     */\n    claimName: string;\n    /**\n     * The value of the claim to map.\n     */\n    claimValue: string;\n    /**\n     * The name of the mapping rule.\n     */\n    name: string;\n};\n\nexport type MappingRuleCreateRequest = MappingRuleCreateUpdateRequest & {\n    /**\n     * The unique ID of the mapping rule.\n     */\n    mappingRuleId: string;\n};\n\nexport type MappingRuleUpdateRequest = MappingRuleCreateUpdateRequest;\n\nexport type MappingRuleCreateUpdateResult = {\n    /**\n     * The name of the claim to map.\n     */\n    claimName?: string;\n    /**\n     * The value of the claim to map.\n     */\n    claimValue?: string;\n    /**\n     * The name of the mapping rule.\n     */\n    name?: string;\n    /**\n     * The unique ID of the mapping rule.\n     */\n    mappingRuleId?: string;\n};\n\nexport type MappingRuleCreateResult = MappingRuleCreateUpdateResult;\n\nexport type MappingRuleUpdateResult = MappingRuleCreateUpdateResult;\n\nexport type MappingRuleSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching mapping rules.\n     */\n    items?: Array<MappingRuleResult>;\n};\n\nexport type MappingRuleResult = {\n    /**\n     * The name of the claim to map.\n     */\n    claimName?: string;\n    /**\n     * The value of the claim to map.\n     */\n    claimValue?: string;\n    /**\n     * The name of the mapping rule.\n     */\n    name?: string;\n    /**\n     * The ID of the mapping rule.\n     */\n    mappingRuleId?: string;\n};\n\n/**\n * The response of a topology request.\n */\nexport type TopologyResponse = {\n    /**\n     * A list of brokers that are part of this cluster.\n     */\n    brokers: Array<BrokerInfo>;\n    /**\n     * The number of brokers in the cluster.\n     */\n    clusterSize: number;\n    /**\n     * The number of partitions are spread across the cluster.\n     */\n    partitionsCount: number;\n    /**\n     * The configured replication factor for this cluster.\n     */\n    replicationFactor: number;\n    /**\n     * The version of the Zeebe Gateway.\n     */\n    gatewayVersion: string;\n    /**\n     * ID of the last completed change\n     */\n    lastCompletedChangeId: string;\n};\n\n/**\n * The response of a license request.\n */\nexport type LicenseResponse = {\n    /**\n     * True if the Camunda license is valid, false if otherwise\n     */\n    validLicense: boolean;\n    /**\n     * Will return the license type property of the Camunda license\n     */\n    licenseType: string;\n    /**\n     * Will be false when a license contains a non-commerical=true property\n     */\n    isCommercial: boolean;\n    /**\n     * The date when the Camunda license expires\n     */\n    expiresAt?: string | null;\n};\n\n/**\n * Provides information on a broker node.\n */\nexport type BrokerInfo = {\n    /**\n     * The unique (within a cluster) node ID for the broker.\n     */\n    nodeId: number;\n    /**\n     * The hostname for reaching the broker.\n     */\n    host: string;\n    /**\n     * The port for reaching the broker.\n     */\n    port: number;\n    /**\n     * A list of partitions managed or replicated on this broker.\n     */\n    partitions: Array<Partition>;\n    /**\n     * The broker version.\n     */\n    version: string;\n};\n\n/**\n * Provides information on a partition within a broker node.\n */\nexport type Partition = {\n    /**\n     * The unique ID of this partition.\n     */\n    partitionId: number;\n    /**\n     * Describes the Raft role of the broker for a given partition.\n     */\n    role: 'leader' | 'follower' | 'inactive';\n    /**\n     * Describes the current health of the partition.\n     */\n    health: 'healthy' | 'unhealthy' | 'dead';\n};\n\nexport type UserTaskCompletionRequest = {\n    /**\n     * The variables to complete the user task with.\n     */\n    variables?: {\n        [key: string]: unknown;\n    } | null;\n    /**\n     * A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to \"complete\".\n     *\n     */\n    action?: string | null;\n};\n\nexport type UserTaskAssignmentRequest = {\n    /**\n     * The assignee for the user task. The assignee must not be empty or `null`.\n     */\n    assignee: string;\n    /**\n     * By default, the task is reassigned if it was already assigned. Set this to `false` to return an error in such cases. The task must then first be unassigned to be assigned again. Use this when you have users picking from group task queues to prevent race conditions.\n     *\n     */\n    allowOverride?: boolean | null;\n    /**\n     * A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to \"assign\".\n     *\n     */\n    action?: string | null;\n};\n\nexport type UserTaskUpdateRequest = {\n    changeset?: Changeset;\n    /**\n     * A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to \"update\".\n     *\n     */\n    action?: string | null;\n};\n\n/**\n * JSON object with changed task attribute values.\n *\n * The following attributes can be adjusted with this endpoint, additional attributes\n * will be ignored:\n *\n * * `candidateGroups` - reset by providing an empty list\n * * `candidateUsers` - reset by providing an empty list\n * * `dueDate` - reset by providing an empty String\n * * `followUpDate` - reset by providing an empty String\n * * `priority` - minimum 0, maximum 100, default 50\n *\n * Providing any of those attributes with a `null` value or omitting it preserves\n * the persisted attribute's value.\n *\n * The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.\n * This ensures correct event emission for assignee changes.\n *\n */\nexport type Changeset = {\n    /**\n     * The due date of the task. Reset by providing an empty String.\n     */\n    dueDate?: string | null;\n    /**\n     * The follow-up date of the task. Reset by providing an empty String.\n     */\n    followUpDate?: string | null;\n    /**\n     * The list of candidate users of the task. Reset by providing an empty list.\n     */\n    candidateUsers?: Array<string> | null;\n    /**\n     * The list of candidate groups of the task. Reset by providing an empty list.\n     */\n    candidateGroups?: Array<string> | null;\n    /**\n     * The priority of the task.\n     */\n    priority?: number | null;\n    [key: string]: unknown | (string | null) | (string | null) | (Array<string> | null) | (Array<string> | null) | (number | null) | undefined;\n} | null;\n\nexport type ClockPinRequest = {\n    /**\n     * The exact time in epoch milliseconds to which the clock should be pinned.\n     */\n    timestamp: number;\n};\n\nexport type JobActivationRequest = {\n    /**\n     * The job type, as defined in the BPMN process (e.g. <zeebe:taskDefinition type=\"payment-service\" />).\n     *\n     */\n    type: string;\n    /**\n     * The name of the worker activating the jobs, mostly used for logging purposes.\n     */\n    worker?: string;\n    /**\n     * A job returned after this call will not be activated by another call until the timeout (in ms) has been reached.\n     *\n     */\n    timeout: number;\n    /**\n     * The maximum jobs to activate by this request.\n     */\n    maxJobsToActivate: number;\n    /**\n     * A list of variables to fetch as the job variables; if empty, all visible variables at the time of activation for the scope of the job will be returned.\n     *\n     */\n    fetchVariable?: Array<string>;\n    /**\n     * The request will be completed when at least one job is activated or after the requestTimeout (in ms). If the requestTimeout = 0, a default timeout is used. If the requestTimeout < 0, long polling is disabled and the request is completed immediately, even when no job is activated.\n     *\n     */\n    requestTimeout?: number;\n    /**\n     * A list of IDs of tenants for which to activate jobs.\n     */\n    tenantIds?: Array<TenantId>;\n};\n\n/**\n * The list of activated jobs\n */\nexport type JobActivationResult = {\n    /**\n     * The activated jobs.\n     */\n    jobs: Array<ActivatedJobResult>;\n};\n\nexport type ActivatedJobResult = {\n    /**\n     * The type of the job (should match what was requested).\n     */\n    type: string;\n    /**\n     * The bpmn process ID of the job's process definition.\n     */\n    processDefinitionId: ProcessDefinitionId;\n    /**\n     * The version of the job's process definition.\n     */\n    processDefinitionVersion: number;\n    /**\n     * The associated task element ID.\n     */\n    elementId: ElementId;\n    /**\n     * A set of custom headers defined during modelling; returned as a serialized JSON document.\n     */\n    customHeaders: {\n        [key: string]: unknown;\n    };\n    /**\n     * The name of the worker which activated this job.\n     */\n    worker: string;\n    /**\n     * The amount of retries left to this job (should always be positive).\n     */\n    retries: number;\n    /**\n     * When the job can be activated again, sent as a UNIX epoch timestamp.\n     */\n    deadline: number;\n    /**\n     * All variables visible to the task scope, computed at activation time.\n     */\n    variables: {\n        [key: string]: unknown;\n    };\n    /**\n     * The ID of the tenant that owns the job.\n     */\n    tenantId: TenantId;\n    /**\n     * The key, a unique identifier for the job.\n     */\n    jobKey: JobKey;\n    /**\n     * The job's process instance key.\n     */\n    processInstanceKey: ProcessInstanceKey;\n    /**\n     * The key of the job's process definition.\n     */\n    processDefinitionKey: ProcessDefinitionKey;\n    /**\n     * The unique key identifying the associated task, unique within the scope of the process instance.\n     *\n     */\n    elementInstanceKey: ElementInstanceKey;\n    kind: JobKindEnum;\n    listenerEventType: JobListenerEventTypeEnum;\n    userTask?: UserTaskProperties;\n    tags?: TagSet;\n};\n\n/**\n * Contains properties of a user task.\n */\nexport type UserTaskProperties = {\n    /**\n     * The action performed on the user task.\n     */\n    action?: string;\n    /**\n     * The user assigned to the task.\n     */\n    assignee?: string | null;\n    /**\n     * The groups eligible to claim the task.\n     */\n    candidateGroups?: Array<string>;\n    /**\n     * The users eligible to claim the task.\n     */\n    candidateUsers?: Array<string>;\n    /**\n     * The attributes that were changed in the task.\n     */\n    changedAttributes?: Array<string>;\n    /**\n     * The due date of the user task in ISO 8601 format.\n     */\n    dueDate?: string | null;\n    /**\n     * The follow-up date of the user task in ISO 8601 format.\n     */\n    followUpDate?: string | null;\n    /**\n     * The key of the form associated with the user task.\n     */\n    formKey?: FormKey;\n    /**\n     * The priority of the user task.\n     */\n    priority?: number | null;\n    /**\n     * The unique key identifying the user task.\n     */\n    userTaskKey?: UserTaskKey | null;\n};\n\nexport type JobFailRequest = {\n    /**\n     * The amount of retries the job should have left\n     *\n     */\n    retries?: number;\n    /**\n     * An optional message describing why the job failed. This is particularly useful if a job runs out of retries and an incident is raised, as this message can help explain why an incident was raised.\n     *\n     */\n    errorMessage?: string;\n    /**\n     * The backoff timeout (in ms) for the next retry.\n     *\n     */\n    retryBackOff?: number;\n    /**\n     * JSON object that will instantiate the variables at the local scope of the job's associated task.\n     *\n     */\n    variables?: {\n        [key: string]: unknown;\n    };\n};\n\nexport type JobErrorRequest = {\n    /**\n     * The error code that will be matched with an error catch event.\n     *\n     */\n    errorCode: string;\n    /**\n     * An error message that provides additional context.\n     *\n     */\n    errorMessage?: string | null;\n    /**\n     * JSON object that will instantiate the variables at the local scope of the error catch event that catches the thrown error.\n     *\n     */\n    variables?: {\n        [key: string]: unknown;\n    } | null;\n};\n\nexport type JobCompletionRequest = {\n    /**\n     * The variables to complete the job with.\n     */\n    variables?: {\n        [key: string]: unknown;\n    } | null;\n    result?: JobResult;\n};\n\nexport type JobResult = (({\n    type: 'userTask';\n} & JobResultUserTask) | ({\n    type: 'adHocSubProcess';\n} & JobResultAdHocSubProcess)) & {\n    /**\n     * Used to distinguish between different types of job results.\n     */\n    type: 'userTask' | 'adHocSubProcess';\n};\n\nexport type JobResultUserTask = {\n    /**\n     * Indicates whether the worker denies the work, i.e. explicitly doesn't approve it. For example, a user task listener can deny the completion of a task by setting this flag to true. In this example, the completion of a task is represented by a job that the worker can complete as denied. As a result, the completion request is rejected and the task remains active. Defaults to false.\n     *\n     */\n    denied?: boolean | null;\n    /**\n     * The reason provided by the user task listener for denying the work.\n     */\n    deniedReason?: string | null;\n    corrections?: JobResultCorrections;\n} | null;\n\n/**\n * JSON object with attributes that were corrected by the worker.\n *\n * The following attributes can be corrected, additional attributes will be ignored:\n *\n * * `assignee` - clear by providing an empty String\n * * `dueDate` - clear by providing an empty String\n * * `followUpDate` - clear by providing an empty String\n * * `candidateGroups` - clear by providing an empty list\n * * `candidateUsers` - clear by providing an empty list\n * * `priority` - minimum 0, maximum 100, default 50\n *\n * Providing any of those attributes with a `null` value or omitting it preserves\n * the persisted attribute's value.\n *\n */\nexport type JobResultCorrections = {\n    /**\n     * Assignee of the task.\n     */\n    assignee?: string | null;\n    /**\n     * The due date of the task.\n     */\n    dueDate?: string | null;\n    /**\n     * The follow-up date of the task.\n     */\n    followUpDate?: string | null;\n    /**\n     * The list of candidate users of the task.\n     */\n    candidateUsers?: Array<string> | null;\n    /**\n     * The list of candidate groups of the task.\n     */\n    candidateGroups?: Array<string> | null;\n    /**\n     * The priority of the task.\n     */\n    priority?: number | null;\n} | null;\n\nexport type JobResultAdHocSubProcess = {\n    /**\n     * Indicates which elements need to be activated in the ad-hoc subprocess.\n     */\n    activateElements?: Array<JobResultActivateElement>;\n    /**\n     * Indicates whether the completion condition of the ad-hoc subprocess is fulfilled.\n     */\n    isCompletionConditionFulfilled?: boolean;\n    /**\n     * Indicates whether the remaining instances of the ad-hoc subprocess should be canceled.\n     */\n    isCancelRemainingInstances?: boolean;\n} | null;\n\nexport type JobResultActivateElement = {\n    /**\n     * The ID of the element to activate.\n     */\n    elementId?: ElementId;\n    /**\n     * JSON document that will create the variables on the scope of the activated element.\n     * It must be a JSON object, as variables will be mapped in a key-value fashion.\n     *\n     */\n    variables?: {\n        [key: string]: unknown;\n    } | null;\n};\n\nexport type JobUpdateRequest = {\n    changeset: JobChangeset;\n    operationReference?: OperationReference;\n};\n\n/**\n * JSON object with changed job attribute values.\n *\n * The following attributes can be adjusted with this endpoint, additional attributes\n * will be ignored:\n *\n * * `retries` - The new amount of retries for the job; must be a positive number.\n * * `timeout` - The duration of the new timeout in ms, starting from the current moment.\n *\n * Providing any of those attributes with a null value or omitting it preserves the persisted attribute’s value.\n *\n * The job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.\n *\n */\nexport type JobChangeset = {\n    /**\n     * The new amount of retries for the job; must be a positive number.\n     */\n    retries?: number | null;\n    /**\n     * The duration of the new timeout in ms, starting from the current moment.\n     */\n    timeout?: number | null;\n};\n\n/**\n * Job search request.\n */\nexport type JobSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<JobSearchQuerySortRequest>;\n    /**\n     * The job search filters.\n     */\n    filter?: JobFilter;\n};\n\nexport type JobSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'deadline' | 'deniedReason' | 'elementId' | 'elementInstanceKey' | 'endTime' | 'errorCode' | 'errorMessage' | 'hasFailedWithRetriesLeft' | 'isDenied' | 'jobKey' | 'kind' | 'listenerEventType' | 'processDefinitionId' | 'processDefinitionKey' | 'processInstanceKey' | 'retries' | 'state' | 'tenantId' | 'type' | 'worker';\n    order?: SortOrderEnum;\n};\n\n/**\n * Job search filter.\n */\nexport type JobFilter = {\n    /**\n     * When the job can next be activated.\n     */\n    deadline?: DateTimeFilterProperty | null;\n    /**\n     * The reason provided by the user task listener for denying the work.\n     */\n    deniedReason?: StringFilterProperty;\n    /**\n     * The element ID associated with the job.\n     */\n    elementId?: StringFilterProperty;\n    /**\n     * The element instance key associated with the job.\n     */\n    elementInstanceKey?: ElementInstanceKeyFilterProperty;\n    /**\n     * When the job ended.\n     */\n    endTime?: DateTimeFilterProperty;\n    /**\n     * The error code provided for the failed job.\n     */\n    errorCode?: StringFilterProperty;\n    /**\n     * The error message that provides additional context for a failed job.\n     */\n    errorMessage?: StringFilterProperty;\n    /**\n     * Indicates whether the job has failed with retries left.\n     */\n    hasFailedWithRetriesLeft?: boolean;\n    /**\n     * Indicates whether the user task listener denies the work.\n     */\n    isDenied?: boolean | null;\n    /**\n     * The key, a unique identifier for the job.\n     */\n    jobKey?: JobKeyFilterProperty;\n    /**\n     * The kind of the job.\n     */\n    kind?: JobKindFilterProperty;\n    /**\n     * The listener event type of the job.\n     */\n    listenerEventType?: JobListenerEventTypeFilterProperty;\n    /**\n     * The process definition ID associated with the job.\n     */\n    processDefinitionId?: StringFilterProperty;\n    /**\n     * The process definition key associated with the job.\n     */\n    processDefinitionKey?: ProcessDefinitionKeyFilterProperty;\n    /**\n     * The process instance key associated with the job.\n     */\n    processInstanceKey?: ProcessInstanceKeyFilterProperty;\n    /**\n     * The number of retries left.\n     */\n    retries?: IntegerFilterProperty;\n    /**\n     * The state of the job.\n     */\n    state?: JobStateFilterProperty;\n    /**\n     * The tenant ID.\n     */\n    tenantId?: StringFilterProperty;\n    /**\n     * The type of the job.\n     */\n    type?: StringFilterProperty;\n    /**\n     * The name of the worker for this job.\n     */\n    worker?: StringFilterProperty;\n};\n\n/**\n * Job search response.\n */\nexport type JobSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching jobs.\n     */\n    items: Array<JobSearchResult>;\n};\n\nexport type JobSearchResult = {\n    /**\n     * A set of custom headers defined during modelling.\n     */\n    customHeaders: {\n        [key: string]: string;\n    };\n    /**\n     * If the job has been activated, when it will next be available to be activated.\n     */\n    deadline?: string | null;\n    /**\n     * The reason provided by the user task listener for denying the work.\n     */\n    deniedReason?: string | null;\n    /**\n     * The element ID associated with the job.\n     */\n    elementId: ElementId;\n    /**\n     * The element instance key associated with the job.\n     */\n    elementInstanceKey: ElementInstanceKey;\n    /**\n     * When the job ended.\n     */\n    endTime?: string;\n    /**\n     * The error code provided for a failed job.\n     */\n    errorCode?: string | null;\n    /**\n     * The error message that provides additional context for a failed job.\n     */\n    errorMessage?: string | null;\n    /**\n     * Indicates whether the job has failed with retries left.\n     */\n    hasFailedWithRetriesLeft?: boolean;\n    /**\n     * Indicates whether the user task listener denies the work.\n     */\n    isDenied?: boolean | null;\n    /**\n     * The key, a unique identifier for the job.\n     */\n    jobKey: JobKey;\n    kind: JobKindEnum;\n    listenerEventType: JobListenerEventTypeEnum;\n    /**\n     * The process definition ID associated with the job.\n     */\n    processDefinitionId: ProcessDefinitionId;\n    /**\n     * The process definition key associated with the job.\n     */\n    processDefinitionKey: ProcessDefinitionKey;\n    /**\n     * The process instance key associated with the job.\n     */\n    processInstanceKey: ProcessInstanceKey;\n    /**\n     * The amount of retries left to this job.\n     */\n    retries: number;\n    state: JobStateEnum;\n    tenantId: TenantId;\n    /**\n     * The type of the job.\n     */\n    type: string;\n    /**\n     * The name of the worker of this job.\n     */\n    worker: string;\n};\n\n/**\n * The state of the job.\n */\nexport type JobStateEnum = 'CANCELED' | 'COMPLETED' | 'CREATED' | 'ERROR_THROWN' | 'FAILED' | 'MIGRATED' | 'RETRIES_UPDATED' | 'TIMED_OUT';\n\n/**\n * The job kind.\n */\nexport type JobKindEnum = 'BPMN_ELEMENT' | 'EXECUTION_LISTENER' | 'TASK_LISTENER' | 'AD_HOC_SUB_PROCESS';\n\n/**\n * The listener event type of the job.\n */\nexport type JobListenerEventTypeEnum = 'ASSIGNING' | 'CANCELING' | 'COMPLETING' | 'CREATING' | 'END' | 'START' | 'UNSPECIFIED' | 'UPDATING';\n\n/**\n * JobStateEnum property with full advanced search capabilities.\n */\nexport type JobStateFilterProperty = JobStateEnum | AdvancedJobStateFilter;\n\n/**\n * Advanced filter\n * Advanced JobStateEnum filter.\n */\nexport type AdvancedJobStateFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: JobStateEnum;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: JobStateEnum;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<JobStateEnum>;\n    $like?: LikeFilter;\n};\n\n/**\n * JobKindEnum property with full advanced search capabilities.\n */\nexport type JobKindFilterProperty = JobKindEnum | AdvancedJobKindFilter;\n\n/**\n * Advanced filter\n * Advanced JobKindEnum filter.\n */\nexport type AdvancedJobKindFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: JobKindEnum;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: JobKindEnum;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<JobKindEnum>;\n    $like?: LikeFilter;\n};\n\n/**\n * JobListenerEventTypeEnum property with full advanced search capabilities.\n */\nexport type JobListenerEventTypeFilterProperty = JobListenerEventTypeEnum | AdvancedJobListenerEventTypeFilter;\n\n/**\n * Advanced filter\n * Advanced JobListenerEventTypeEnum filter.\n */\nexport type AdvancedJobListenerEventTypeFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: JobListenerEventTypeEnum;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: JobListenerEventTypeEnum;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<JobListenerEventTypeEnum>;\n    $like?: LikeFilter;\n};\n\n/**\n * A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.\n *\n */\nexport type ProblemDetail = {\n    /**\n     * A URI identifying the problem type.\n     */\n    type?: string;\n    /**\n     * A summary of the problem type.\n     */\n    title?: string;\n    /**\n     * The HTTP status code for this problem.\n     */\n    status?: number;\n    /**\n     * An explanation of the problem in more detail.\n     */\n    detail?: string;\n    /**\n     * A URI path identifying the origin of the problem.\n     */\n    instance?: string;\n};\n\nexport type SearchQueryRequest = {\n    /**\n     * Pagination criteria.\n     */\n    page?: SearchQueryPageRequest;\n};\n\n/**\n * Pagination criteria. Can use offset-based pagination (from/limit) OR cursor-based pagination (after/before + limit), but not both.\n */\nexport type SearchQueryPageRequest = OffsetPagination | CursorForwardPagination | CursorBackwardPagination;\n\n/**\n * Offset-based pagination\n */\nexport type OffsetPagination = {\n    /**\n     * The index of items to start searching from.\n     */\n    from?: number;\n    /**\n     * The maximum number of items to return in one request.\n     */\n    limit?: number;\n};\n\n/**\n * Cursor-based forward pagination\n */\nexport type CursorForwardPagination = {\n    /**\n     * Use the `endCursor` value from the previous response to fetch the next page of results.\n     */\n    after: EndCursor;\n    /**\n     * The maximum number of items to return in one request.\n     */\n    limit?: number;\n};\n\n/**\n * Cursor-based backward pagination\n */\nexport type CursorBackwardPagination = {\n    /**\n     * Use the `startCursor` value from the previous response to fetch the previous page of results.\n     */\n    before: StartCursor;\n    /**\n     * The maximum number of items to return in one request.\n     */\n    limit?: number;\n};\n\nexport type SearchQueryResponse = {\n    /**\n     * Pagination information about the search results.\n     */\n    page: SearchQueryPageResponse;\n};\n\n/**\n * Pagination information about the search results.\n */\nexport type SearchQueryPageResponse = {\n    /**\n     * Total items matching the criteria.\n     */\n    totalItems: number;\n    /**\n     * Indicates if more results exist beyond the reported totalItems value. Due to system limitations, the totalItems value can be capped.\n     *\n     */\n    hasMoreTotalItems?: boolean;\n    /**\n     * The cursor value for getting the previous page of results. Use this in the `before` field of an ensuing request.\n     */\n    startCursor?: StartCursor;\n    /**\n     * The cursor value for getting the next page of results. Use this in the `after` field of an ensuing request.\n     */\n    endCursor?: EndCursor;\n};\n\nexport type DecisionRequirementsSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'decisionRequirementsKey' | 'decisionRequirementsName' | 'version' | 'decisionRequirementsId' | 'tenantId';\n    order?: SortOrderEnum;\n};\n\nexport type DecisionRequirementsSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<DecisionRequirementsSearchQuerySortRequest>;\n    /**\n     * The decision definition search filters.\n     */\n    filter?: DecisionRequirementsFilter;\n};\n\n/**\n * Decision requirements search filter.\n */\nexport type DecisionRequirementsFilter = {\n    /**\n     * The DMN name of the decision requirements.\n     */\n    decisionRequirementsName?: string;\n    /**\n     * The assigned version of the decision requirements.\n     */\n    version?: number;\n    /**\n     * the DMN ID of the decision requirements.\n     */\n    decisionRequirementsId?: string;\n    /**\n     * The tenant ID of the decision requirements.\n     */\n    tenantId?: TenantId;\n    /**\n     * The assigned key, which acts as a unique identifier for this decision requirements.\n     */\n    decisionRequirementsKey?: DecisionRequirementsKey;\n    /**\n     * The name of the resource from which the decision requirements were parsed.\n     */\n    resourceName?: string;\n};\n\nexport type DecisionRequirementsSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching decision requirements.\n     */\n    items?: Array<DecisionRequirementsResult>;\n};\n\nexport type DecisionRequirementsResult = {\n    /**\n     * The DMN name of the decision requirements.\n     */\n    decisionRequirementsName?: string;\n    /**\n     * The assigned version of the decision requirements.\n     */\n    version?: number;\n    /**\n     * The DMN ID of the decision requirements.\n     */\n    decisionRequirementsId?: string;\n    /**\n     * The name of the resource from which this decision requirements was parsed.\n     */\n    resourceName?: string;\n    /**\n     * The tenant ID of the decision requirements.\n     */\n    tenantId?: TenantId;\n    /**\n     * The assigned key, which acts as a unique identifier for this decision requirements.\n     */\n    decisionRequirementsKey?: DecisionRequirementsKey;\n};\n\nexport type DecisionEvaluationInstruction = DecisionEvaluationById | DecisionEvaluationByKey;\n\n/**\n * Decision evaluation by ID\n */\nexport type DecisionEvaluationById = {\n    /**\n     * The ID of the decision to be evaluated.\n     * When using the decision ID, the latest\n     * deployed version of the decision is used.\n     *\n     */\n    decisionDefinitionId: DecisionDefinitionId;\n    /**\n     * The message variables as JSON document.\n     */\n    variables?: {\n        [key: string]: unknown;\n    };\n    /**\n     * The tenant ID of the decision.\n     */\n    tenantId?: TenantId;\n};\n\n/**\n * Decision evaluation by key\n */\nexport type DecisionEvaluationByKey = {\n    decisionDefinitionKey: DecisionDefinitionKey;\n    /**\n     * The message variables as JSON document.\n     */\n    variables?: {\n        [key: string]: unknown;\n    };\n    /**\n     * The tenant ID of the decision.\n     */\n    tenantId?: TenantId;\n};\n\nexport type EvaluateDecisionResult = {\n    /**\n     * The ID of the decision which was evaluated.\n     */\n    decisionDefinitionId: DecisionDefinitionId;\n    /**\n     * The name of the decision which was evaluated.\n     */\n    decisionDefinitionName: string;\n    /**\n     * The version of the decision which was evaluated.\n     */\n    decisionDefinitionVersion: number;\n    /**\n     * The ID of the decision requirements graph that the decision which was evaluated is part of.\n     */\n    decisionRequirementsId: string;\n    /**\n     * JSON document that will instantiate the result of the decision which was evaluated.\n     *\n     */\n    output: string;\n    /**\n     * The ID of the decision which failed during evaluation.\n     */\n    failedDecisionDefinitionId: DecisionDefinitionId;\n    /**\n     * Message describing why the decision which was evaluated failed.\n     */\n    failureMessage: string;\n    /**\n     * The tenant ID of the evaluated decision.\n     */\n    tenantId: TenantId;\n    /**\n     * The unique key identifying the decision which was evaluated.\n     */\n    decisionDefinitionKey: DecisionDefinitionKey;\n    /**\n     * The unique key identifying the decision requirements graph that the decision which was evaluated is part of.\n     */\n    decisionRequirementsKey: DecisionRequirementsKey;\n    /**\n     * Deprecated, please refer to `decisionEvaluationKey`.\n     * @deprecated\n     */\n    decisionInstanceKey?: DecisionInstanceKey;\n    /**\n     * The unique key identifying this decision evaluation.\n     */\n    decisionEvaluationKey: DecisionEvaluationKey;\n    /**\n     * Decisions that were evaluated within the requested decision evaluation.\n     */\n    evaluatedDecisions: Array<EvaluatedDecisionResult>;\n};\n\n/**\n * A decision that was evaluated.\n */\nexport type EvaluatedDecisionResult = {\n    /**\n     * The ID of the decision which was evaluated.\n     */\n    decisionDefinitionId?: DecisionDefinitionId;\n    /**\n     * The name of the decision which was evaluated.\n     */\n    decisionDefinitionName?: string;\n    /**\n     * The version of the decision which was evaluated.\n     */\n    decisionDefinitionVersion?: number;\n    /**\n     * The type of the decision which was evaluated.\n     */\n    decisionDefinitionType?: string;\n    /**\n     * JSON document that will instantiate the result of the decision which was evaluated.\n     *\n     */\n    output?: string;\n    /**\n     * The tenant ID of the evaluated decision.\n     */\n    tenantId?: TenantId;\n    /**\n     * The decision rules that matched within this decision evaluation.\n     */\n    matchedRules?: Array<MatchedDecisionRuleItem>;\n    /**\n     * The decision inputs that were evaluated within this decision evaluation.\n     */\n    evaluatedInputs?: Array<EvaluatedDecisionInputItem>;\n    /**\n     * The unique key identifying the decision which was evaluate.\n     */\n    decisionDefinitionKey?: DecisionDefinitionKey;\n    /**\n     * The unique key identifying this decision evaluation instance.\n     */\n    decisionEvaluationInstanceKey?: DecisionEvaluationInstanceKey;\n};\n\n/**\n * A decision rule that matched within this decision evaluation.\n */\nexport type MatchedDecisionRuleItem = {\n    /**\n     * The ID of the matched rule.\n     */\n    ruleId?: string;\n    /**\n     * The index of the matched rule.\n     */\n    ruleIndex?: number;\n    /**\n     * The evaluated decision outputs.\n     */\n    evaluatedOutputs?: Array<EvaluatedDecisionOutputItem>;\n};\n\n/**\n * A decision input that was evaluated within this decision evaluation.\n */\nexport type EvaluatedDecisionInputItem = {\n    /**\n     * The ID of the evaluated decision input.\n     */\n    inputId?: string;\n    /**\n     * The name of the evaluated decision input.\n     */\n    inputName?: string;\n    /**\n     * The value of the evaluated decision input.\n     */\n    inputValue?: string;\n};\n\n/**\n * The evaluated decision outputs.\n */\nexport type EvaluatedDecisionOutputItem = {\n    /**\n     * The ID of the evaluated decision output.\n     */\n    outputId?: string;\n    /**\n     * The name of the evaluated decision output.\n     */\n    outputName?: string;\n    /**\n     * The value of the evaluated decision output.\n     */\n    outputValue?: string;\n};\n\nexport type DecisionInstanceSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'decisionDefinitionId' | 'decisionDefinitionKey' | 'decisionDefinitionName' | 'decisionDefinitionType' | 'decisionDefinitionVersion' | 'decisionEvaluationInstanceKey' | 'decisionEvaluationKey' | 'elementInstanceKey' | 'evaluationDate' | 'evaluationFailure' | 'processDefinitionKey' | 'processInstanceKey' | 'state' | 'tenantId';\n    order?: SortOrderEnum;\n};\n\nexport type DecisionInstanceSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<DecisionInstanceSearchQuerySortRequest>;\n    /**\n     * The decision instance search filters.\n     */\n    filter?: DecisionInstanceFilter;\n};\n\n/**\n * Decision instance search filter.\n */\nexport type DecisionInstanceFilter = {\n    decisionEvaluationInstanceKey?: DecisionEvaluationInstanceKey;\n    state?: DecisionInstanceStateEnum;\n    /**\n     * The evaluation failure of the decision instance.\n     */\n    evaluationFailure?: string;\n    /**\n     * The evaluation date of the decision instance.\n     */\n    evaluationDate?: DateTimeFilterProperty;\n    /**\n     * The ID of the DMN decision.\n     */\n    decisionDefinitionId?: DecisionDefinitionId;\n    /**\n     * The name of the DMN decision.\n     */\n    decisionDefinitionName?: string;\n    /**\n     * The version of the decision.\n     */\n    decisionDefinitionVersion?: number;\n    decisionDefinitionType?: DecisionDefinitionTypeEnum;\n    /**\n     * The tenant ID of the decision instance.\n     */\n    tenantId?: TenantId;\n    /**\n     * The key of the parent decision evaluation. Note that this is not the identifier of an individual decision instance; the `decisionEvaluationInstanceKey` is the identifier for a decision instance.\n     *\n     */\n    decisionEvaluationKey?: DecisionEvaluationKey;\n    /**\n     * The key of the process definition.\n     */\n    processDefinitionKey?: ProcessDefinitionKey;\n    /**\n     * The key of the process instance.\n     */\n    processInstanceKey?: ProcessInstanceKey;\n    /**\n     * The key of the decision.\n     */\n    decisionDefinitionKey?: DecisionDefinitionKeyFilterProperty;\n    /**\n     * The key of the element instance this decision instance is linked to.\n     */\n    elementInstanceKey?: ElementInstanceKeyFilterProperty;\n};\n\nexport type DecisionInstanceSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching decision instances.\n     */\n    items?: Array<DecisionInstanceResult>;\n};\n\nexport type DecisionInstanceResult = {\n    decisionEvaluationInstanceKey?: DecisionEvaluationInstanceKey;\n    state?: DecisionInstanceStateEnum;\n    /**\n     * The evaluation date of the decision instance.\n     */\n    evaluationDate?: string;\n    /**\n     * The evaluation failure of the decision instance.\n     */\n    evaluationFailure?: string;\n    /**\n     * The ID of the DMN decision.\n     */\n    decisionDefinitionId?: DecisionDefinitionId;\n    /**\n     * The name of the DMN decision.\n     */\n    decisionDefinitionName?: string;\n    /**\n     * The version of the decision.\n     */\n    decisionDefinitionVersion?: number;\n    decisionDefinitionType?: DecisionDefinitionTypeEnum;\n    /**\n     * The result of the decision instance.\n     */\n    result?: string;\n    /**\n     * The tenant ID of the decision instance.\n     */\n    tenantId?: TenantId;\n    /**\n     * The key of the decision evaluation where this instance was created.\n     */\n    decisionEvaluationKey?: DecisionEvaluationKey;\n    /**\n     * The key of the process definition.\n     */\n    processDefinitionKey?: ProcessDefinitionKey;\n    /**\n     * The key of the process instance.\n     */\n    processInstanceKey?: ProcessInstanceKey;\n    /**\n     * The key of the decision.\n     */\n    decisionDefinitionKey?: DecisionDefinitionKey;\n    /**\n     * The key of the element instance this decision instance is linked to.\n     */\n    elementInstanceKey?: ElementInstanceKey;\n};\n\nexport type DecisionInstanceGetQueryResult = DecisionInstanceResult & {\n    /**\n     * The evaluated inputs of the decision instance.\n     *\n     */\n    evaluatedInputs?: Array<EvaluatedDecisionInputItem>;\n    /**\n     * The matched rules of the decision instance.\n     *\n     */\n    matchedRules?: Array<MatchedDecisionRuleItem>;\n};\n\n/**\n * The type of the decision.\n */\nexport type DecisionDefinitionTypeEnum = 'DECISION_TABLE' | 'LITERAL_EXPRESSION' | 'UNSPECIFIED' | 'UNKNOWN';\n\n/**\n * The state of the decision instance.\n */\nexport type DecisionInstanceStateEnum = 'EVALUATED' | 'FAILED' | 'UNSPECIFIED' | 'UNKNOWN';\n\n/**\n * The order in which to sort the related field.\n */\nexport type SortOrderEnum = 'ASC' | 'DESC';\n\n/**\n * A reference key chosen by the user that will be part of all records resulting from this operation.\n * Must be > 0 if provided.\n *\n */\nexport type OperationReference = number;\n\nexport type MessageCorrelationRequest = {\n    /**\n     * The message name as defined in the BPMN process\n     *\n     */\n    name: string;\n    /**\n     * The correlation key of the message.\n     */\n    correlationKey?: string;\n    /**\n     * The message variables as JSON document\n     */\n    variables?: {\n        [key: string]: unknown;\n    };\n    /**\n     * the tenant for which the message is published\n     */\n    tenantId?: TenantId;\n};\n\n/**\n * The message key of the correlated message, as well as the first process instance key it\n * correlated with.\n *\n */\nexport type MessageCorrelationResult = {\n    /**\n     * The tenant ID of the correlated message\n     */\n    tenantId?: TenantId;\n    /**\n     * The key of the correlated message\n     */\n    messageKey?: MessageCorrelationKey;\n    /**\n     * The key of the first process instance the message correlated with\n     */\n    processInstanceKey?: ProcessInstanceKey;\n};\n\nexport type MessagePublicationRequest = {\n    /**\n     * The name of the message.\n     */\n    name: string;\n    /**\n     * The correlation key of the message.\n     */\n    correlationKey?: string;\n    /**\n     * Timespan (in ms) to buffer the message on the broker.\n     */\n    timeToLive?: number;\n    /**\n     * The unique ID of the message. This is used to ensure only one message with the given ID\n     * will be published during the lifetime of the message (if `timeToLive` is set).\n     *\n     */\n    messageId?: string;\n    /**\n     * The message variables as JSON document.\n     */\n    variables?: {\n        [key: string]: unknown;\n    };\n    /**\n     * The tenant of the message sender.\n     */\n    tenantId?: TenantId;\n};\n\n/**\n * The message key of the published message.\n */\nexport type MessagePublicationResult = {\n    /**\n     * The tenant ID of the message.\n     */\n    tenantId?: TenantId;\n    /**\n     * The key of the message\n     */\n    messageKey?: MessageKey;\n};\n\nexport type DocumentReference = {\n    /**\n     * Document discriminator. Always set to \"camunda\".\n     */\n    'camunda.document.type'?: 'camunda';\n    /**\n     * The ID of the document store.\n     */\n    storeId?: string;\n    /**\n     * The ID of the document.\n     */\n    documentId?: DocumentId;\n    /**\n     * The hash of the document.\n     */\n    contentHash?: string;\n    metadata?: DocumentMetadata;\n};\n\nexport type DocumentCreationFailureDetail = {\n    /**\n     * The name of the file.\n     */\n    fileName?: string;\n    /**\n     * The detail of the failure.\n     */\n    detail?: string;\n};\n\nexport type DocumentCreationBatchResponse = {\n    /**\n     * Documents that were successfully created.\n     */\n    createdDocuments?: Array<DocumentReference>;\n    /**\n     * Documents that failed creation.\n     */\n    failedDocuments?: Array<DocumentCreationFailureDetail>;\n};\n\n/**\n * Document Id that uniquely identifies a document.\n */\nexport type DocumentId = CamundaKey<'DocumentId'>;\n\n/**\n * Information about the document.\n */\nexport type DocumentMetadata = {\n    /**\n     * The content type of the document.\n     */\n    contentType?: string;\n    /**\n     * The name of the file.\n     */\n    fileName?: string;\n    /**\n     * The date and time when the document expires.\n     */\n    expiresAt?: string;\n    /**\n     * The size of the document in bytes.\n     */\n    size?: number;\n    /**\n     * The ID of the process definition that created the document.\n     */\n    processDefinitionId?: ProcessDefinitionId;\n    /**\n     * The key of the process instance that created the document.\n     */\n    processInstanceKey?: ProcessInstanceKey;\n    /**\n     * Custom properties of the document.\n     */\n    customProperties?: {\n        [key: string]: unknown;\n    };\n};\n\nexport type DocumentLinkRequest = {\n    /**\n     * The time-to-live of the document link in ms.\n     */\n    timeToLive?: number;\n};\n\nexport type DocumentLink = {\n    /**\n     * The link to the document.\n     */\n    url?: string;\n    /**\n     * The date and time when the link expires.\n     */\n    expiresAt?: string;\n};\n\nexport type DeploymentResult = {\n    /**\n     * The tenant ID associated with the deployment.\n     */\n    tenantId: TenantId;\n    /**\n     * The unique key identifying the deployment.\n     */\n    deploymentKey: DeploymentKey;\n    /**\n     * Items deployed by the request.\n     */\n    deployments: Array<DeploymentMetadataResult>;\n};\n\nexport type DeploymentMetadataResult = {\n    processDefinition?: DeploymentProcessResult;\n    decisionDefinition?: DeploymentDecisionResult;\n    decisionRequirements?: DeploymentDecisionRequirementsResult;\n    form?: DeploymentFormResult;\n    resource?: DeploymentResourceResult;\n};\n\n/**\n * A deployed process.\n */\nexport type DeploymentProcessResult = {\n    /**\n     * The bpmn process ID, as parsed during deployment, together with the version forms a\n     * unique identifier for a specific process definition.\n     *\n     */\n    processDefinitionId: ProcessDefinitionId;\n    /**\n     * The assigned process version.\n     */\n    processDefinitionVersion: number;\n    /**\n     * The resource name from which this process was parsed.\n     */\n    resourceName: string;\n    /**\n     * The tenant ID of the deployed process.\n     */\n    tenantId: TenantId;\n    /**\n     * The assigned key, which acts as a unique identifier for this process.\n     */\n    processDefinitionKey: ProcessDefinitionKey;\n};\n\n/**\n * A deployed decision.\n */\nexport type DeploymentDecisionResult = {\n    /**\n     * The dmn decision ID, as parsed during deployment, together with the version forms a\n     * unique identifier for a specific decision.\n     *\n     */\n    decisionDefinitionId?: DecisionDefinitionId;\n    /**\n     * The assigned decision version.\n     */\n    version?: number;\n    /**\n     * The DMN name of the decision, as parsed during deployment.\n     */\n    name?: string;\n    /**\n     * The tenant ID of the deployed decision.\n     */\n    tenantId?: TenantId;\n    /**\n     * The dmn ID of the decision requirements graph that this decision is part of, as parsed during deployment.\n     *\n     */\n    decisionRequirementsId?: string;\n    /**\n     * The assigned decision key, which acts as a unique identifier for this decision.\n     *\n     */\n    decisionDefinitionKey?: DecisionDefinitionKey;\n    /**\n     * The assigned key of the decision requirements graph that this decision is part of.\n     *\n     */\n    decisionRequirementsKey?: DecisionRequirementsKey;\n};\n\n/**\n * Deployed decision requirements.\n */\nexport type DeploymentDecisionRequirementsResult = {\n    /**\n     * The dmn decision requirements ID, as parsed during deployment; together with the versions forms a unique identifier for a specific decision.\n     *\n     */\n    decisionRequirementsId?: string;\n    /**\n     * The assigned decision requirements version.\n     */\n    version?: number;\n    /**\n     * The DMN name of the decision requirements, as parsed during deployment.\n     */\n    decisionRequirementsName?: string;\n    /**\n     * The tenant ID of the deployed decision requirements.\n     */\n    tenantId?: TenantId;\n    /**\n     * The resource name from which this decision requirements was parsed.\n     */\n    resourceName?: string;\n    /**\n     * The assigned decision requirements key, which acts as a unique identifier for this decision requirements.\n     *\n     */\n    decisionRequirementsKey?: DecisionRequirementsKey;\n};\n\n/**\n * A deployed form.\n */\nexport type DeploymentFormResult = {\n    /**\n     * The form ID, as parsed during deployment, together with the version forms a\n     * unique identifier for a specific form.\n     *\n     */\n    formId?: FormId;\n    /**\n     * The assigned form version.\n     */\n    version?: number;\n    /**\n     * The resource name from which this form was parsed.\n     */\n    resourceName?: string;\n    tenantId?: TenantId;\n    /**\n     * The assigned key, which acts as a unique identifier for this form.\n     */\n    formKey?: FormKey;\n};\n\n/**\n * A deployed Resource.\n */\nexport type DeploymentResourceResult = {\n    /**\n     * The resource ID, as parsed during deployment, together with the version forms a\n     * unique identifier for a specific form.\n     *\n     */\n    resourceId?: string;\n    /**\n     * The assigned resource version.\n     */\n    version?: number;\n    /**\n     * The resource name from which this resource was parsed.\n     */\n    resourceName?: string;\n    tenantId?: TenantId;\n    /**\n     * The assigned key, which acts as a unique identifier for this Resource.\n     */\n    resourceKey?: ResourceKey;\n};\n\nexport type IncidentResolutionRequest = {\n    operationReference?: OperationReference;\n};\n\n/**\n * Instructions for creating a process instance. The process definition can be specified\n * either by ID or by key.\n *\n */\nexport type ProcessInstanceCreationInstruction = ProcessInstanceCreationInstructionById | ProcessInstanceCreationInstructionByKey;\n\n/**\n * Process creation by ID\n */\nexport type ProcessInstanceCreationInstructionById = {\n    /**\n     * The BPMN process ID of the process definition to start an instance of.\n     *\n     */\n    processDefinitionId: ProcessDefinitionId;\n    /**\n     * The version of the process. By default, the latest version of the process is used.\n     *\n     */\n    processDefinitionVersion?: number;\n    /**\n     * JSON object that will instantiate the variables for the root variable scope\n     * of the process instance.\n     *\n     */\n    variables?: {\n        [key: string]: unknown;\n    };\n    /**\n     * The tenant ID of the process definition.\n     */\n    tenantId?: TenantId;\n    operationReference?: OperationReference;\n    /**\n     * List of start instructions. By default, the process instance will start at\n     * the start event. If provided, the process instance will apply start instructions\n     * after it has been created.\n     *\n     */\n    startInstructions?: Array<ProcessInstanceCreationStartInstruction>;\n    /**\n     * Runtime instructions (alpha). List of instructions that affect the runtime behavior of\n     * the process instance. Refer to specific instruction types for more details.\n     *\n     * This parameter is an alpha feature and may be subject to change\n     * in future releases.\n     *\n     */\n    runtimeInstructions?: Array<ProcessInstanceCreationRuntimeInstruction>;\n    /**\n     * Wait for the process instance to complete. If the process instance completion does\n     * not occur within the requestTimeout, the request will be closed. This can lead to a 504\n     * response status. Disabled by default.\n     *\n     */\n    awaitCompletion?: boolean;\n    /**\n     * List of variables by name to be included in the response when awaitCompletion is set to true.\n     * If empty, all visible variables in the root scope will be returned.\n     *\n     */\n    fetchVariables?: Array<string>;\n    /**\n     * Timeout (in ms) the request waits for the process to complete. By default or\n     * when set to 0, the generic request timeout configured in the cluster is applied.\n     *\n     */\n    requestTimeout?: number;\n    tags?: TagSet;\n};\n\n/**\n * Process creation by key\n */\nexport type ProcessInstanceCreationInstructionByKey = {\n    /**\n     * The unique key identifying the process definition, for example, returned for a process in the\n     * deploy resources endpoint.\n     *\n     */\n    processDefinitionKey: ProcessDefinitionKey;\n    /**\n     * JSON object that will instantiate the variables for the root variable scope\n     * of the process instance.\n     *\n     */\n    variables?: {\n        [key: string]: unknown;\n    };\n    /**\n     * The tenant ID of the process definition.\n     */\n    tenantId?: TenantId;\n    operationReference?: OperationReference;\n    /**\n     * List of start instructions. By default, the process instance will start at\n     * the start event. If provided, the process instance will apply start instructions\n     * after it has been created.\n     *\n     */\n    startInstructions?: Array<ProcessInstanceCreationStartInstruction>;\n    /**\n     * Runtime instructions (alpha). List of instructions that affect the runtime behavior of\n     * the process instance. Refer to specific instruction types for more details.\n     *\n     * This parameter is an alpha feature and may be subject to change\n     * in future releases.\n     *\n     */\n    runtimeInstructions?: Array<ProcessInstanceCreationRuntimeInstruction>;\n    /**\n     * Wait for the process instance to complete. If the process instance completion does\n     * not occur within the requestTimeout, the request will be closed. This can lead to a 504\n     * response status. Disabled by default.\n     *\n     */\n    awaitCompletion?: boolean;\n    /**\n     * List of variables by name to be included in the response when awaitCompletion is set to true.\n     * If empty, all visible variables in the root scope will be returned.\n     *\n     */\n    fetchVariables?: Array<string>;\n    /**\n     * Timeout (in ms) the request waits for the process to complete. By default or\n     * when set to 0, the generic request timeout configured in the cluster is applied.\n     *\n     */\n    requestTimeout?: number;\n    tags?: TagSet;\n};\n\nexport type ProcessInstanceCreationStartInstruction = {\n    /**\n     * Future extensions might include:\n     * - different types of start instructions\n     * - ability to set local variables for different flow scopes\n     *\n     * For now, however, the start instruction is implicitly a \"startBeforeElement\" instruction\n     *\n     */\n    elementId: ElementId;\n};\n\nexport type ProcessInstanceCreationRuntimeInstruction = ({\n    type: 'TERMINATE_PROCESS_INSTANCE';\n} & ProcessInstanceCreationTerminateInstruction) & {\n    /**\n     * The type of the runtime instruction\n     */\n    type: 'TERMINATE_PROCESS_INSTANCE';\n};\n\n/**\n * Terminates the process instance after a specific BPMN element is completed or terminated.\n *\n */\nexport type ProcessInstanceCreationTerminateInstruction = {\n    /**\n     * The ID of the element that, once completed or terminated, will cause the process to be terminated.\n     *\n     */\n    afterElementId: ElementId;\n};\n\nexport type CreateProcessInstanceResult = {\n    /**\n     * The BPMN process ID of the process definition which was used to create the process.\n     * instance\n     *\n     */\n    processDefinitionId: ProcessDefinitionId;\n    /**\n     * The version of the process definition which was used to create the process instance.\n     *\n     */\n    processDefinitionVersion: number;\n    /**\n     * The tenant ID of the created process instance.\n     */\n    tenantId: TenantId;\n    /**\n     * All the variables visible in the root scope.\n     */\n    variables: {\n        [key: string]: unknown;\n    };\n    /**\n     * The key of the process definition which was used to create the process instance.\n     *\n     */\n    processDefinitionKey: ProcessDefinitionKey;\n    /**\n     * The unique identifier of the created process instance; to be used wherever a request\n     * needs a process instance key (e.g. CancelProcessInstanceRequest).\n     *\n     */\n    processInstanceKey: ProcessInstanceKey;\n    tags?: TagSet;\n};\n\nexport type ProcessInstanceMigrationBatchOperationRequest = {\n    filter: ProcessInstanceFilter;\n    migrationPlan: ProcessInstanceMigrationBatchOperationPlan;\n};\n\n/**\n * The migration instructions describe how to migrate a process instance from one process definition to another.\n *\n */\nexport type ProcessInstanceMigrationBatchOperationPlan = {\n    /**\n     * Element mappings from the source process instance to the target process instance.\n     */\n    mappingInstructions: Array<MigrateProcessInstanceMappingInstruction>;\n    /**\n     * The key of process definition to migrate the process instance to.\n     */\n    targetProcessDefinitionKey: ProcessDefinitionKey;\n};\n\n/**\n * The migration instructions describe how to migrate a process instance from one process definition to another.\n *\n */\nexport type ProcessInstanceMigrationInstruction = {\n    /**\n     * Element mappings from the source process instance to the target process instance.\n     */\n    mappingInstructions: Array<MigrateProcessInstanceMappingInstruction>;\n    operationReference?: OperationReference;\n    /**\n     * The key of process definition to migrate the process instance to.\n     */\n    targetProcessDefinitionKey: ProcessDefinitionKey;\n};\n\n/**\n * The mapping instructions describe how to map elements from the source process definition to the target process definition.\n *\n */\nexport type MigrateProcessInstanceMappingInstruction = {\n    /**\n     * The element ID to migrate from.\n     */\n    sourceElementId: ElementId;\n    /**\n     * The element ID to migrate into.\n     */\n    targetElementId: ElementId;\n};\n\nexport type ProcessInstanceModificationInstruction = {\n    operationReference?: OperationReference;\n    /**\n     * Instructions describing which elements should be activated in which scopes and which variables should be created.\n     */\n    activateInstructions?: Array<ProcessInstanceModificationActivateInstruction>;\n    /**\n     * Instructions describing which elements should be terminated.\n     */\n    terminateInstructions?: Array<ProcessInstanceModificationTerminateInstruction>;\n};\n\n/**\n * Instructions describing an element that should be activated.\n */\nexport type ProcessInstanceModificationActivateInstruction = {\n    /**\n     * The ID of the element that should be activated.\n     */\n    elementId: ElementId;\n    /**\n     * Instructions describing which variables should be created.\n     */\n    variableInstructions?: Array<ModifyProcessInstanceVariableInstruction>;\n    /**\n     * The key of the ancestor scope the element instance should be created in.\n     * Set to -1 to create the new element instance within an existing element instance of the\n     * flow scope.\n     *\n     */\n    ancestorElementInstanceKey?: string | ElementInstanceKey;\n};\n\n/**\n * Instructions describing which variables should be created.\n */\nexport type ModifyProcessInstanceVariableInstruction = {\n    /**\n     * JSON document that will instantiate the variables for the root variable scope of the process instance.\n     * It must be a JSON object, as variables will be mapped in a key-value fashion.\n     *\n     */\n    variables: {\n        [key: string]: unknown;\n    };\n    /**\n     * The ID of the element in which scope the variables should be created.\n     * Leave empty to create the variables in the global scope of the process instance\n     *\n     */\n    scopeId?: string;\n};\n\n/**\n * Instructions describing which elements should be terminated.\n */\nexport type ProcessInstanceModificationTerminateInstruction = {\n    /**\n     * The ID of the element that should be terminated.\n     */\n    elementInstanceKey: ElementInstanceKey;\n};\n\nexport type SetVariableRequest = {\n    /**\n     * JSON object representing the variables to set in the element’s scope.\n     */\n    variables: {\n        [key: string]: unknown;\n    };\n    /**\n     * If set to true, the variables are merged strictly into the local scope (as specified by the `elementInstanceKey`).\n     * Otherwise, the variables are propagated to upper scopes and set at the outermost one.\n     *\n     * Let’s consider the following example:\n     *\n     * There are two scopes '1' and '2'.\n     * Scope '1' is the parent scope of '2'. The effective variables of the scopes are:\n     * 1 => { \"foo\" : 2 }\n     * 2 => { \"bar\" : 1 }\n     *\n     * An update request with elementInstanceKey as '2', variables { \"foo\" : 5 }, and local set\n     * to true leaves scope '1' unchanged and adjusts scope '2' to { \"bar\" : 1, \"foo\" 5 }.\n     *\n     * By default, with local set to false, scope '1' will be { \"foo\": 5 }\n     * and scope '2' will be { \"bar\" : 1 }.\n     *\n     */\n    local?: boolean;\n    operationReference?: OperationReference;\n};\n\nexport type DeleteResourceRequest = {\n    operationReference?: OperationReference;\n} | null;\n\nexport type SignalBroadcastRequest = {\n    /**\n     * The name of the signal to broadcast.\n     */\n    signalName: string;\n    /**\n     * The signal variables as a JSON object.\n     */\n    variables?: {\n        [key: string]: unknown;\n    };\n    /**\n     * The ID of the tenant that owns the signal.\n     */\n    tenantId?: TenantId;\n};\n\nexport type SignalBroadcastResult = {\n    /**\n     * The tenant ID of the signal that was broadcast.\n     */\n    tenantId: TenantId;\n    /**\n     * The unique ID of the signal that was broadcast.\n     */\n    signalKey: SignalKey;\n};\n\nexport type FormResult = {\n    /**\n     * The tenant ID of the form.\n     */\n    tenantId?: TenantId;\n    /**\n     * The user-provided identifier of the form.\n     */\n    formId?: FormId;\n    /**\n     * The form content.\n     */\n    schema?: {\n        [key: string]: unknown;\n    };\n    /**\n     * The version of the the deployed form.\n     */\n    version?: number;\n    /**\n     * The assigned key, which acts as a unique identifier for this form.\n     */\n    formKey?: FormKey;\n};\n\nexport type ResourceResult = {\n    /**\n     * The resource name from which this resource was parsed.\n     */\n    resourceName?: string;\n    /**\n     * The assigned resource version.\n     */\n    version?: number;\n    /**\n     * The version tag of this resource.\n     */\n    versionTag?: string;\n    /**\n     * The resource ID of this resource.\n     */\n    resourceId?: string;\n    /**\n     * The tenant ID of this resource.\n     */\n    tenantId?: TenantId;\n    /**\n     * The unique key of this resource.\n     */\n    resourceKey?: ResourceKey;\n};\n\n/**\n * The type of the batch operation.\n */\nexport type BatchOperationTypeEnum = 'CANCEL_PROCESS_INSTANCE' | 'RESOLVE_INCIDENT' | 'MIGRATE_PROCESS_INSTANCE' | 'MODIFY_PROCESS_INSTANCE' | 'DELETE_PROCESS_INSTANCE' | 'ADD_VARIABLE' | 'UPDATE_VARIABLE' | 'DELETE_DECISION_DEFINITION' | 'DELETE_PROCESS_DEFINITION';\n\n/**\n * The created batch operation.\n */\nexport type BatchOperationCreatedResult = {\n    /**\n     * Key of the batch operation.\n     */\n    batchOperationKey?: BatchOperationKey;\n    batchOperationType?: BatchOperationTypeEnum;\n};\n\nexport type BatchOperationSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'batchOperationKey' | 'operationType' | 'state' | 'startDate' | 'endDate';\n    order?: SortOrderEnum;\n};\n\n/**\n * Batch operation search request.\n */\nexport type BatchOperationSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<BatchOperationSearchQuerySortRequest>;\n    /**\n     * The batch operation search filters.\n     */\n    filter?: BatchOperationFilter;\n};\n\n/**\n * Batch operation filter request.\n */\nexport type BatchOperationFilter = {\n    /**\n     * The key (or operate legacy ID) of the batch operation.\n     */\n    batchOperationKey?: BasicStringFilterProperty;\n    /**\n     * The type of the batch operation.\n     */\n    operationType?: BatchOperationTypeFilterProperty;\n    /**\n     * The state of the batch operation.\n     */\n    state?: BatchOperationStateFilterProperty;\n};\n\n/**\n * BatchOperationTypeEnum property with full advanced search capabilities.\n */\nexport type BatchOperationTypeFilterProperty = BatchOperationTypeEnum | AdvancedBatchOperationTypeFilter;\n\n/**\n * Advanced filter\n * Advanced BatchOperationTypeEnum filter.\n */\nexport type AdvancedBatchOperationTypeFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: BatchOperationTypeEnum;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: BatchOperationTypeEnum;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<BatchOperationTypeEnum>;\n    $like?: LikeFilter;\n};\n\n/**\n * BatchOperationStateEnum property with full advanced search capabilities.\n */\nexport type BatchOperationStateFilterProperty = BatchOperationStateEnum | AdvancedBatchOperationStateFilter;\n\n/**\n * Advanced filter\n * Advanced BatchOperationStateEnum filter.\n */\nexport type AdvancedBatchOperationStateFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: BatchOperationStateEnum;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: BatchOperationStateEnum;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<BatchOperationStateEnum>;\n    $like?: LikeFilter;\n};\n\n/**\n * The batch operation state.\n */\nexport type BatchOperationStateEnum = 'ACTIVE' | 'CANCELED' | 'COMPLETED' | 'CREATED' | 'FAILED' | 'PARTIALLY_COMPLETED' | 'SUSPENDED';\n\nexport type BatchOperationItemSearchQuerySortRequest = {\n    /**\n     * The field to sort by.\n     */\n    field: 'batchOperationKey' | 'itemKey' | 'processInstanceKey' | 'state';\n    order?: SortOrderEnum;\n};\n\n/**\n * Batch operation item search request.\n */\nexport type BatchOperationItemSearchQuery = SearchQueryRequest & {\n    /**\n     * Sort field criteria.\n     */\n    sort?: Array<BatchOperationItemSearchQuerySortRequest>;\n    /**\n     * The batch operation search filters.\n     */\n    filter?: BatchOperationItemFilter;\n};\n\n/**\n * Batch operation item filter request.\n */\nexport type BatchOperationItemFilter = {\n    /**\n     * The key (or operate legacy ID) of the batch operation.\n     */\n    batchOperationKey?: BasicStringFilterProperty;\n    /**\n     * The key of the item, e.g. a process instance key.\n     */\n    itemKey?: BasicStringFilterProperty;\n    /**\n     * The process instance key of the processed item.\n     */\n    processInstanceKey?: ProcessInstanceKeyFilterProperty;\n    /**\n     * The state of the batch operation.\n     */\n    state?: BatchOperationItemStateFilterProperty;\n};\n\n/**\n * BatchOperationItemStateEnum property with full advanced search capabilities.\n */\nexport type BatchOperationItemStateFilterProperty = BatchOperationItemStateEnum | AdvancedBatchOperationItemStateFilter;\n\n/**\n * Advanced filter\n * Advanced BatchOperationItemStateEnum filter.\n */\nexport type AdvancedBatchOperationItemStateFilter = {\n    /**\n     * Checks for equality with the provided value.\n     */\n    $eq?: BatchOperationItemStateEnum;\n    /**\n     * Checks for inequality with the provided value.\n     */\n    $neq?: BatchOperationItemStateEnum;\n    /**\n     * Checks if the current property exists.\n     */\n    $exists?: boolean;\n    /**\n     * Checks if the property matches any of the provided values.\n     */\n    $in?: Array<BatchOperationItemStateEnum>;\n    $like?: LikeFilter;\n};\n\n/**\n * The state, one of ACTIVE, COMPLETED, TERMINATED.\n */\nexport type BatchOperationItemStateEnum = 'ACTIVE' | 'COMPLETED' | 'CANCELED' | 'FAILED';\n\n/**\n * The batch operation search query result.\n */\nexport type BatchOperationSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching batch operations.\n     */\n    items?: Array<BatchOperationResponse>;\n};\n\nexport type BatchOperationResponse = {\n    /**\n     * Key or (Operate Legacy ID = UUID) of the batch operation.\n     */\n    batchOperationKey?: BatchOperationKey;\n    /**\n     * The state of the batch operation.\n     */\n    state?: 'ACTIVE' | 'CANCELED' | 'COMPLETED' | 'CREATED' | 'FAILED' | 'PARTIALLY_COMPLETED' | 'SUSPENDED';\n    batchOperationType?: BatchOperationTypeEnum;\n    /**\n     * The start date of the batch operation.\n     */\n    startDate?: string;\n    /**\n     * The end date of the batch operation.\n     */\n    endDate?: string;\n    /**\n     * The total number of items contained in this batch operation.\n     */\n    operationsTotalCount?: number;\n    /**\n     * The number of items which failed during execution of the batch operation. (e.g. because they are rejected by the Zeebe engine).\n     */\n    operationsFailedCount?: number;\n    /**\n     * The number of successfully completed tasks.\n     */\n    operationsCompletedCount?: number;\n    /**\n     * The errors that occurred per partition during the batch operation.\n     */\n    errors?: Array<BatchOperationError>;\n};\n\nexport type BatchOperationError = {\n    /**\n     * The partition ID where the error occurred.\n     */\n    partitionId?: number;\n    /**\n     * The type of the error that occurred during the batch operation.\n     */\n    type?: 'QUERY_FAILED' | 'RESULT_BUFFER_SIZE_EXCEEDED';\n    /**\n     * The error message that occurred during the batch operation.\n     */\n    message?: string;\n};\n\nexport type BatchOperationItemSearchQueryResult = SearchQueryResponse & {\n    /**\n     * The matching batch operations.\n     */\n    items?: Array<BatchOperationItemResponse>;\n};\n\nexport type BatchOperationItemResponse = {\n    operationType?: BatchOperationTypeEnum;\n    /**\n     * The key (or operate legacy ID) of the batch operation.\n     */\n    batchOperationKey?: BatchOperationKey;\n    /**\n     * Key of the item, e.g. a process instance key.\n     */\n    itemKey?: string;\n    /**\n     * the process instance key of the processed item.\n     */\n    processInstanceKey?: ProcessInstanceKey;\n    /**\n     * State of the item.\n     */\n    state?: 'ACTIVE' | 'COMPLETED' | 'SKIPPED' | 'CANCELED' | 'FAILED';\n    /**\n     * the date this item was processed.\n     */\n    processedDate?: string;\n    /**\n     * the error message from the engine in case of a failed operation.\n     */\n    errorMessage?: string;\n};\n\n/**\n * The process instance filter that defines which process instances should be canceled.\n */\nexport type ProcessInstanceCancellationBatchOperationRequest = {\n    filter: ProcessInstanceFilter;\n};\n\n/**\n * The process instance filter that defines which process instances should have their incidents resolved.\n */\nexport type ProcessInstanceIncidentResolutionBatchOperationRequest = {\n    filter: ProcessInstanceFilter;\n};\n\n/**\n * The process instance filter to define on which process instances tokens should be moved,\n * as well as mapping instructions which active element instances should be terminated and which\n * new element instances should be activated\n *\n */\nexport type ProcessInstanceModificationBatchOperationRequest = {\n    filter: ProcessInstanceFilter;\n    /**\n     * Instructions describing which elements should be activated in which scopes and which variables should be created.\n     */\n    moveInstructions: Array<ProcessInstanceModificationMoveBatchOperationInstruction>;\n};\n\n/**\n * Instructions describing a move operation. This instruction will terminate all active elementInstance\n * at sourceElementId and activate a new element instance for each terminated one at targetElementId.\n */\nexport type ProcessInstanceModificationMoveBatchOperationInstruction = {\n    /**\n     * The ID of the element that should be terminated.\n     */\n    sourceElementId: ElementId;\n    /**\n     * The ID of the element that should be activated.\n     */\n    targetElementId: ElementId;\n};\n\n/**\n * A tag. Needs to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length ≤ 100.\n */\nexport type Tag = CamundaKey<'Tag'>;\n\n/**\n * List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length ≤ 100.\n */\nexport type TagSet = Array<Tag> & { readonly length: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 }; // minItems=0 maxItems=10; uniqueItems=true;\n\n/**\n * The unique identifier of the tenant.\n */\nexport type TenantId = CamundaKey<'TenantId'>;\n\n/**\n * The unique name of a user.\n */\nexport type Username = CamundaKey<'Username'>;\n\nexport type GetTopologyData = {\n    body?: never;\n    path?: never;\n    query?: never;\n    url: '/topology';\n};\n\nexport type GetTopologyErrors = {\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetTopologyError = GetTopologyErrors[keyof GetTopologyErrors];\n\nexport type GetTopologyResponses = {\n    /**\n     * Obtains the current topology of the cluster the gateway is part of.\n     */\n    200: TopologyResponse;\n};\n\nexport type GetTopologyResponse = GetTopologyResponses[keyof GetTopologyResponses];\n\nexport type GetStatusData = {\n    body?: never;\n    path?: never;\n    query?: never;\n    url: '/status';\n};\n\nexport type GetStatusErrors = {\n    /**\n     * The cluster is DOWN and does not have any partition with a healthy leader.\n     */\n    503: unknown;\n};\n\nexport type GetStatusResponses = {\n    /**\n     * The cluster is UP and has at least one partition with a healthy leader.\n     */\n    204: void;\n};\n\nexport type GetStatusResponse = GetStatusResponses[keyof GetStatusResponses];\n\nexport type GetLicenseData = {\n    body?: never;\n    path?: never;\n    query?: never;\n    url: '/license';\n};\n\nexport type GetLicenseErrors = {\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetLicenseError = GetLicenseErrors[keyof GetLicenseErrors];\n\nexport type GetLicenseResponses = {\n    /**\n     * Obtains the current status of the Camunda license.\n     */\n    200: LicenseResponse;\n};\n\nexport type GetLicenseResponse = GetLicenseResponses[keyof GetLicenseResponses];\n\nexport type GetAuthenticationData = {\n    body?: never;\n    path?: never;\n    query?: never;\n    url: '/authentication/me';\n};\n\nexport type GetAuthenticationErrors = {\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetAuthenticationError = GetAuthenticationErrors[keyof GetAuthenticationErrors];\n\nexport type GetAuthenticationResponses = {\n    /**\n     * The current user is successfully returned.\n     */\n    200: CamundaUserResult;\n};\n\nexport type GetAuthenticationResponse = GetAuthenticationResponses[keyof GetAuthenticationResponses];\n\nexport type ActivateJobsData = {\n    body: JobActivationRequest;\n    path?: never;\n    query?: never;\n    url: '/jobs/activation';\n};\n\nexport type ActivateJobsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * An Internal Error occurred. More details are provided in the response body. If the response body contains RESOURCE_EXHAUSTED, this signals back pressure.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type ActivateJobsError = ActivateJobsErrors[keyof ActivateJobsErrors];\n\nexport type ActivateJobsResponses = {\n    /**\n     * The list of activated jobs.\n     */\n    200: JobActivationResult;\n};\n\nexport type ActivateJobsResponse = ActivateJobsResponses[keyof ActivateJobsResponses];\n\nexport type SearchJobsData = {\n    body?: JobSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/jobs/search';\n};\n\nexport type SearchJobsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchJobsError = SearchJobsErrors[keyof SearchJobsErrors];\n\nexport type SearchJobsResponses = {\n    /**\n     * The job search result.\n     */\n    200: JobSearchQueryResult;\n};\n\nexport type SearchJobsResponse = SearchJobsResponses[keyof SearchJobsResponses];\n\nexport type FailJobData = {\n    body?: JobFailRequest;\n    path: {\n        /**\n         * The key of the job to fail.\n         */\n        jobKey: JobKey;\n    };\n    query?: never;\n    url: '/jobs/{jobKey}/failure';\n};\n\nexport type FailJobErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The job with the given jobKey is not found. It was completed by another worker, or the process instance itself was canceled.\n     *\n     */\n    404: ProblemDetail;\n    /**\n     * The job with the given key is in the wrong state (i.e: not ACTIVATED or ACTIVATABLE). The job was failed by another worker with retries = 0, and the process is now in an incident state.\n     *\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type FailJobError = FailJobErrors[keyof FailJobErrors];\n\nexport type FailJobResponses = {\n    /**\n     * The job is failed.\n     */\n    204: void;\n};\n\nexport type FailJobResponse = FailJobResponses[keyof FailJobResponses];\n\nexport type ThrowJobErrorData = {\n    body: JobErrorRequest;\n    path: {\n        /**\n         * The key of the job.\n         */\n        jobKey: JobKey;\n    };\n    query?: never;\n    url: '/jobs/{jobKey}/error';\n};\n\nexport type ThrowJobErrorErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The job with the given jobKey is not found.\n     *\n     */\n    404: ProblemDetail;\n    /**\n     * The job with the given key is in the wrong state currently. More details are provided in the response body.\n     *\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type ThrowJobErrorError = ThrowJobErrorErrors[keyof ThrowJobErrorErrors];\n\nexport type ThrowJobErrorResponses = {\n    /**\n     * An error is thrown for the job.\n     */\n    204: void;\n};\n\nexport type ThrowJobErrorResponse = ThrowJobErrorResponses[keyof ThrowJobErrorResponses];\n\nexport type CompleteJobData = {\n    body?: JobCompletionRequest;\n    path: {\n        /**\n         * The key of the job to complete.\n         */\n        jobKey: JobKey;\n    };\n    query?: never;\n    url: '/jobs/{jobKey}/completion';\n};\n\nexport type CompleteJobErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The job with the given key was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The job with the given key is in the wrong state currently. More details are provided in the response body.\n     *\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type CompleteJobError = CompleteJobErrors[keyof CompleteJobErrors];\n\nexport type CompleteJobResponses = {\n    /**\n     * The job was completed successfully.\n     */\n    204: void;\n};\n\nexport type CompleteJobResponse = CompleteJobResponses[keyof CompleteJobResponses];\n\nexport type UpdateJobData = {\n    body: JobUpdateRequest;\n    path: {\n        /**\n         * The key of the job to update.\n         */\n        jobKey: JobKey;\n    };\n    query?: never;\n    url: '/jobs/{jobKey}';\n};\n\nexport type UpdateJobErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The job with the jobKey is not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The job with the given key is in the wrong state currently. More details are provided in the response body.\n     *\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UpdateJobError = UpdateJobErrors[keyof UpdateJobErrors];\n\nexport type UpdateJobResponses = {\n    /**\n     * The job was updated successfully.\n     */\n    204: void;\n};\n\nexport type UpdateJobResponse = UpdateJobResponses[keyof UpdateJobResponses];\n\nexport type ResolveIncidentData = {\n    body?: IncidentResolutionRequest;\n    path: {\n        /**\n         * Key of the incident to resolve.\n         */\n        incidentKey: IncidentKey;\n    };\n    query?: never;\n    url: '/incidents/{incidentKey}/resolution';\n};\n\nexport type ResolveIncidentErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The incident with the incidentKey is not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type ResolveIncidentError = ResolveIncidentErrors[keyof ResolveIncidentErrors];\n\nexport type ResolveIncidentResponses = {\n    /**\n     * The incident is marked as resolved.\n     */\n    204: void;\n};\n\nexport type ResolveIncidentResponse = ResolveIncidentResponses[keyof ResolveIncidentResponses];\n\nexport type CreateTenantData = {\n    body: TenantCreateRequest;\n    path?: never;\n    query?: never;\n    url: '/tenants';\n};\n\nexport type CreateTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The resource was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * Tenant with this id already exists.\n     */\n    409: unknown;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type CreateTenantError = CreateTenantErrors[keyof CreateTenantErrors];\n\nexport type CreateTenantResponses = {\n    /**\n     * The tenant was created successfully.\n     */\n    201: TenantCreateResult;\n};\n\nexport type CreateTenantResponse = CreateTenantResponses[keyof CreateTenantResponses];\n\nexport type DeleteTenantData = {\n    body?: never;\n    path: {\n        tenantId: TenantId;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}';\n};\n\nexport type DeleteTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The tenant was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type DeleteTenantError = DeleteTenantErrors[keyof DeleteTenantErrors];\n\nexport type DeleteTenantResponses = {\n    /**\n     * The tenant was deleted successfully.\n     */\n    204: void;\n};\n\nexport type DeleteTenantResponse = DeleteTenantResponses[keyof DeleteTenantResponses];\n\nexport type GetTenantData = {\n    body?: never;\n    path: {\n        tenantId: TenantId;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}';\n};\n\nexport type GetTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Tenant not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetTenantError = GetTenantErrors[keyof GetTenantErrors];\n\nexport type GetTenantResponses = {\n    /**\n     * The tenant was retrieved successfully.\n     */\n    200: TenantResult;\n};\n\nexport type GetTenantResponse = GetTenantResponses[keyof GetTenantResponses];\n\nexport type UpdateTenantData = {\n    body: TenantUpdateRequest;\n    path: {\n        tenantId: TenantId;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}';\n};\n\nexport type UpdateTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The tenant was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UpdateTenantError = UpdateTenantErrors[keyof UpdateTenantErrors];\n\nexport type UpdateTenantResponses = {\n    /**\n     * The tenant was updated successfully.\n     */\n    200: TenantUpdateResult;\n};\n\nexport type UpdateTenantResponse = UpdateTenantResponses[keyof UpdateTenantResponses];\n\nexport type UnassignUserFromTenantData = {\n    body?: never;\n    path: {\n        /**\n         * The unique identifier of the tenant.\n         */\n        tenantId: TenantId;\n        /**\n         * The unique identifier of the user.\n         */\n        username: Username;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/users/{username}';\n};\n\nexport type UnassignUserFromTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The tenant or user was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UnassignUserFromTenantError = UnassignUserFromTenantErrors[keyof UnassignUserFromTenantErrors];\n\nexport type UnassignUserFromTenantResponses = {\n    /**\n     * The user was successfully unassigned from the tenant.\n     */\n    204: void;\n};\n\nexport type UnassignUserFromTenantResponse = UnassignUserFromTenantResponses[keyof UnassignUserFromTenantResponses];\n\nexport type AssignUserToTenantData = {\n    body?: never;\n    path: {\n        /**\n         * The unique identifier of the tenant.\n         */\n        tenantId: TenantId;\n        /**\n         * The username of the user to assign.\n         */\n        username: Username;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/users/{username}';\n};\n\nexport type AssignUserToTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The tenant or user was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type AssignUserToTenantError = AssignUserToTenantErrors[keyof AssignUserToTenantErrors];\n\nexport type AssignUserToTenantResponses = {\n    /**\n     * The user was successfully assigned to the tenant.\n     */\n    204: void;\n};\n\nexport type AssignUserToTenantResponse = AssignUserToTenantResponses[keyof AssignUserToTenantResponses];\n\nexport type SearchUsersForTenantData = {\n    body?: TenantUserSearchQueryRequest;\n    path: {\n        tenantId: TenantId;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/users/search';\n};\n\nexport type SearchUsersForTenantResponses = {\n    /**\n     * The search result of users for the tenant.\n     */\n    200: TenantUserSearchResult;\n};\n\nexport type SearchUsersForTenantResponse = SearchUsersForTenantResponses[keyof SearchUsersForTenantResponses];\n\nexport type SearchClientsForTenantData = {\n    body?: TenantClientSearchQueryRequest;\n    path: {\n        tenantId: TenantId;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/clients/search';\n};\n\nexport type SearchClientsForTenantResponses = {\n    /**\n     * The search result of users for the tenant.\n     */\n    200: TenantClientSearchResult;\n};\n\nexport type SearchClientsForTenantResponse = SearchClientsForTenantResponses[keyof SearchClientsForTenantResponses];\n\nexport type SearchGroupIdsForTenantData = {\n    body?: TenantGroupSearchQueryRequest;\n    path: {\n        tenantId: TenantId;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/groups/search';\n};\n\nexport type SearchGroupIdsForTenantResponses = {\n    /**\n     * The search result of groups for the tenant.\n     */\n    200: TenantGroupSearchResult;\n};\n\nexport type SearchGroupIdsForTenantResponse = SearchGroupIdsForTenantResponses[keyof SearchGroupIdsForTenantResponses];\n\nexport type SearchRolesForTenantData = {\n    body?: RoleSearchQueryRequest;\n    path: {\n        tenantId: TenantId;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/roles/search';\n};\n\nexport type SearchRolesForTenantResponses = {\n    /**\n     * The search result of roles for the tenant.\n     */\n    200: RoleSearchQueryResult;\n};\n\nexport type SearchRolesForTenantResponse = SearchRolesForTenantResponses[keyof SearchRolesForTenantResponses];\n\nexport type UnassignClientFromTenantData = {\n    body?: never;\n    path: {\n        tenantId: TenantId;\n        /**\n         * The unique identifier of the application.\n         */\n        clientId: string;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/clients/{clientId}';\n};\n\nexport type UnassignClientFromTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The tenant does not exist or the client was not assigned to it.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UnassignClientFromTenantError = UnassignClientFromTenantErrors[keyof UnassignClientFromTenantErrors];\n\nexport type UnassignClientFromTenantResponses = {\n    /**\n     * The client was successfully unassigned from the tenant.\n     */\n    204: void;\n};\n\nexport type UnassignClientFromTenantResponse = UnassignClientFromTenantResponses[keyof UnassignClientFromTenantResponses];\n\nexport type AssignClientToTenantData = {\n    body?: never;\n    path: {\n        tenantId: TenantId;\n        /**\n         * The ID of the client to assign.\n         */\n        clientId: string;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/clients/{clientId}';\n};\n\nexport type AssignClientToTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The tenant was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type AssignClientToTenantError = AssignClientToTenantErrors[keyof AssignClientToTenantErrors];\n\nexport type AssignClientToTenantResponses = {\n    /**\n     * The client was successfully assigned to the tenant.\n     */\n    204: void;\n};\n\nexport type AssignClientToTenantResponse = AssignClientToTenantResponses[keyof AssignClientToTenantResponses];\n\nexport type UnassignMappingRuleFromTenantData = {\n    body?: never;\n    path: {\n        tenantId: TenantId;\n        /**\n         * The unique identifier of the mapping rule.\n         */\n        mappingRuleId: string;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/mapping-rules/{mappingRuleId}';\n};\n\nexport type UnassignMappingRuleFromTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The tenant or mapping rule was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UnassignMappingRuleFromTenantError = UnassignMappingRuleFromTenantErrors[keyof UnassignMappingRuleFromTenantErrors];\n\nexport type UnassignMappingRuleFromTenantResponses = {\n    /**\n     * The mapping rule was successfully unassigned from the tenant.\n     */\n    204: void;\n};\n\nexport type UnassignMappingRuleFromTenantResponse = UnassignMappingRuleFromTenantResponses[keyof UnassignMappingRuleFromTenantResponses];\n\nexport type AssignMappingRuleToTenantData = {\n    body?: never;\n    path: {\n        tenantId: TenantId;\n        /**\n         * The unique identifier of the mapping rule.\n         */\n        mappingRuleId: string;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/mapping-rules/{mappingRuleId}';\n};\n\nexport type AssignMappingRuleToTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The tenant or mapping rule was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type AssignMappingRuleToTenantError = AssignMappingRuleToTenantErrors[keyof AssignMappingRuleToTenantErrors];\n\nexport type AssignMappingRuleToTenantResponses = {\n    /**\n     * The mapping rule was successfully assigned to the tenant.\n     */\n    204: void;\n};\n\nexport type AssignMappingRuleToTenantResponse = AssignMappingRuleToTenantResponses[keyof AssignMappingRuleToTenantResponses];\n\nexport type SearchMappingRulesForTenantData = {\n    body?: MappingRuleSearchQueryRequest;\n    path: {\n        tenantId: TenantId;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/mapping-rules/search';\n};\n\nexport type SearchMappingRulesForTenantResponses = {\n    /**\n     * The search result of MappingRules for the tenant.\n     */\n    200: MappingRuleSearchQueryResult;\n};\n\nexport type SearchMappingRulesForTenantResponse = SearchMappingRulesForTenantResponses[keyof SearchMappingRulesForTenantResponses];\n\nexport type UnassignGroupFromTenantData = {\n    body?: never;\n    path: {\n        tenantId: TenantId;\n        /**\n         * The unique identifier of the group.\n         */\n        groupId: string;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/groups/{groupId}';\n};\n\nexport type UnassignGroupFromTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The tenant or group was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UnassignGroupFromTenantError = UnassignGroupFromTenantErrors[keyof UnassignGroupFromTenantErrors];\n\nexport type UnassignGroupFromTenantResponses = {\n    /**\n     * The group was successfully unassigned from the tenant.\n     */\n    204: void;\n};\n\nexport type UnassignGroupFromTenantResponse = UnassignGroupFromTenantResponses[keyof UnassignGroupFromTenantResponses];\n\nexport type AssignGroupToTenantData = {\n    body?: never;\n    path: {\n        tenantId: TenantId;\n        /**\n         * The unique identifier of the group.\n         */\n        groupId: string;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/groups/{groupId}';\n};\n\nexport type AssignGroupToTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The tenant or group was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type AssignGroupToTenantError = AssignGroupToTenantErrors[keyof AssignGroupToTenantErrors];\n\nexport type AssignGroupToTenantResponses = {\n    /**\n     * The group was successfully assigned to the tenant.\n     */\n    204: void;\n};\n\nexport type AssignGroupToTenantResponse = AssignGroupToTenantResponses[keyof AssignGroupToTenantResponses];\n\nexport type UnassignRoleFromTenantData = {\n    body?: never;\n    path: {\n        tenantId: TenantId;\n        /**\n         * The unique identifier of the role.\n         */\n        roleId: string;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/roles/{roleId}';\n};\n\nexport type UnassignRoleFromTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The tenant or role was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UnassignRoleFromTenantError = UnassignRoleFromTenantErrors[keyof UnassignRoleFromTenantErrors];\n\nexport type UnassignRoleFromTenantResponses = {\n    /**\n     * The role was successfully unassigned from the tenant.\n     */\n    204: void;\n};\n\nexport type UnassignRoleFromTenantResponse = UnassignRoleFromTenantResponses[keyof UnassignRoleFromTenantResponses];\n\nexport type AssignRoleToTenantData = {\n    body?: never;\n    path: {\n        tenantId: TenantId;\n        /**\n         * The unique identifier of the role.\n         */\n        roleId: string;\n    };\n    query?: never;\n    url: '/tenants/{tenantId}/roles/{roleId}';\n};\n\nexport type AssignRoleToTenantErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The tenant or role was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type AssignRoleToTenantError = AssignRoleToTenantErrors[keyof AssignRoleToTenantErrors];\n\nexport type AssignRoleToTenantResponses = {\n    /**\n     * The role was successfully assigned to the tenant.\n     */\n    204: void;\n};\n\nexport type AssignRoleToTenantResponse = AssignRoleToTenantResponses[keyof AssignRoleToTenantResponses];\n\nexport type SearchTenantsData = {\n    body?: TenantSearchQueryRequest;\n    path?: never;\n    query?: never;\n    url: '/tenants/search';\n};\n\nexport type SearchTenantsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchTenantsError = SearchTenantsErrors[keyof SearchTenantsErrors];\n\nexport type SearchTenantsResponses = {\n    /**\n     * The tenants search result\n     */\n    200: TenantSearchQueryResult;\n};\n\nexport type SearchTenantsResponse = SearchTenantsResponses[keyof SearchTenantsResponses];\n\nexport type CompleteUserTaskData = {\n    body?: UserTaskCompletionRequest;\n    path: {\n        /**\n         * The key of the user task to complete.\n         */\n        userTaskKey: UserTaskKey;\n    };\n    query?: never;\n    url: '/user-tasks/{userTaskKey}/completion';\n};\n\nexport type CompleteUserTaskErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The user task with the given key was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The user task with the given key is in the wrong state currently. More details are provided in the response body.\n     *\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type CompleteUserTaskError = CompleteUserTaskErrors[keyof CompleteUserTaskErrors];\n\nexport type CompleteUserTaskResponses = {\n    /**\n     * The user task was completed successfully.\n     */\n    204: void;\n};\n\nexport type CompleteUserTaskResponse = CompleteUserTaskResponses[keyof CompleteUserTaskResponses];\n\nexport type AssignUserTaskData = {\n    body: UserTaskAssignmentRequest;\n    path: {\n        /**\n         * The key of the user task to assign.\n         */\n        userTaskKey: UserTaskKey;\n    };\n    query?: never;\n    url: '/user-tasks/{userTaskKey}/assignment';\n};\n\nexport type AssignUserTaskErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The user task with the given key was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The user task with the given key is in the wrong state currently. More details are provided in the response body.\n     *\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type AssignUserTaskError = AssignUserTaskErrors[keyof AssignUserTaskErrors];\n\nexport type AssignUserTaskResponses = {\n    /**\n     * The user task's assignment was adjusted.\n     */\n    204: void;\n};\n\nexport type AssignUserTaskResponse = AssignUserTaskResponses[keyof AssignUserTaskResponses];\n\nexport type GetUserTaskData = {\n    body?: never;\n    path: {\n        /**\n         * The user task key.\n         */\n        userTaskKey: UserTaskKey;\n    };\n    query?: never;\n    url: '/user-tasks/{userTaskKey}';\n};\n\nexport type GetUserTaskErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The user task with the given key was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetUserTaskError = GetUserTaskErrors[keyof GetUserTaskErrors];\n\nexport type GetUserTaskResponses = {\n    /**\n     * The user task is successfully returned.\n     *\n     */\n    200: UserTaskResult;\n};\n\nexport type GetUserTaskResponse = GetUserTaskResponses[keyof GetUserTaskResponses];\n\nexport type UpdateUserTaskData = {\n    body?: UserTaskUpdateRequest;\n    path: {\n        /**\n         * The key of the user task to update.\n         */\n        userTaskKey: UserTaskKey;\n    };\n    query?: never;\n    url: '/user-tasks/{userTaskKey}';\n};\n\nexport type UpdateUserTaskErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The user task with the given key was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The user task with the given key is in the wrong state currently. More details are provided in the response body.\n     *\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UpdateUserTaskError = UpdateUserTaskErrors[keyof UpdateUserTaskErrors];\n\nexport type UpdateUserTaskResponses = {\n    /**\n     * The user task was updated successfully.\n     */\n    204: void;\n};\n\nexport type UpdateUserTaskResponse = UpdateUserTaskResponses[keyof UpdateUserTaskResponses];\n\nexport type GetUserTaskFormData = {\n    body?: never;\n    path: {\n        /**\n         * The user task key.\n         */\n        userTaskKey: UserTaskKey;\n    };\n    query?: never;\n    url: '/user-tasks/{userTaskKey}/form';\n};\n\nexport type GetUserTaskFormErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetUserTaskFormError = GetUserTaskFormErrors[keyof GetUserTaskFormErrors];\n\nexport type GetUserTaskFormResponses = {\n    /**\n     * The form is successfully returned.\n     */\n    200: FormResult;\n    /**\n     * The user task was found, but no form is associated with it.\n     */\n    204: void;\n};\n\nexport type GetUserTaskFormResponse = GetUserTaskFormResponses[keyof GetUserTaskFormResponses];\n\nexport type UnassignUserTaskData = {\n    body?: never;\n    path: {\n        /**\n         * The key of the user task.\n         */\n        userTaskKey: UserTaskKey;\n    };\n    query?: never;\n    url: '/user-tasks/{userTaskKey}/assignee';\n};\n\nexport type UnassignUserTaskErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The user task with the given key was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The user task with the given key is in the wrong state currently. More details are provided in the response body.\n     *\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UnassignUserTaskError = UnassignUserTaskErrors[keyof UnassignUserTaskErrors];\n\nexport type UnassignUserTaskResponses = {\n    /**\n     * The user task was unassigned successfully.\n     */\n    204: void;\n};\n\nexport type UnassignUserTaskResponse = UnassignUserTaskResponses[keyof UnassignUserTaskResponses];\n\nexport type SearchUserTasksData = {\n    body?: UserTaskSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/user-tasks/search';\n};\n\nexport type SearchUserTasksErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchUserTasksError = SearchUserTasksErrors[keyof SearchUserTasksErrors];\n\nexport type SearchUserTasksResponses = {\n    /**\n     * The user task search result.\n     */\n    200: UserTaskSearchQueryResult;\n};\n\nexport type SearchUserTasksResponse = SearchUserTasksResponses[keyof SearchUserTasksResponses];\n\nexport type SearchUserTaskVariablesData = {\n    body?: UserTaskVariableSearchQueryRequest;\n    path: {\n        /**\n         * The key of the user task.\n         */\n        userTaskKey: UserTaskKey;\n    };\n    query?: never;\n    url: '/user-tasks/{userTaskKey}/variables/search';\n};\n\nexport type SearchUserTaskVariablesErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchUserTaskVariablesError = SearchUserTaskVariablesErrors[keyof SearchUserTaskVariablesErrors];\n\nexport type SearchUserTaskVariablesResponses = {\n    /**\n     * The user task variables search response.\n     *\n     */\n    200: VariableSearchQueryResult;\n};\n\nexport type SearchUserTaskVariablesResponse = SearchUserTaskVariablesResponses[keyof SearchUserTaskVariablesResponses];\n\nexport type SearchVariablesData = {\n    body?: VariableSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/variables/search';\n};\n\nexport type SearchVariablesErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchVariablesError = SearchVariablesErrors[keyof SearchVariablesErrors];\n\nexport type SearchVariablesResponses = {\n    /**\n     * The variable search result.\n     */\n    200: VariableSearchQueryResult;\n};\n\nexport type SearchVariablesResponse = SearchVariablesResponses[keyof SearchVariablesResponses];\n\nexport type GetVariableData = {\n    body?: never;\n    path: {\n        /**\n         * The variable key.\n         */\n        variableKey: VariableKey;\n    };\n    query?: never;\n    url: '/variables/{variableKey}';\n};\n\nexport type GetVariableErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetVariableError = GetVariableErrors[keyof GetVariableErrors];\n\nexport type GetVariableResponses = {\n    /**\n     * The variable is successfully returned.\n     */\n    200: VariableResult;\n};\n\nexport type GetVariableResponse = GetVariableResponses[keyof GetVariableResponses];\n\nexport type PinClockData = {\n    body: ClockPinRequest;\n    path?: never;\n    query?: never;\n    url: '/clock';\n};\n\nexport type PinClockErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type PinClockError = PinClockErrors[keyof PinClockErrors];\n\nexport type PinClockResponses = {\n    /**\n     * The clock was successfully pinned to the specified time in epoch milliseconds.\n     *\n     */\n    204: void;\n};\n\nexport type PinClockResponse = PinClockResponses[keyof PinClockResponses];\n\nexport type ResetClockData = {\n    body?: never;\n    path?: never;\n    query?: never;\n    url: '/clock/reset';\n};\n\nexport type ResetClockErrors = {\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type ResetClockError = ResetClockErrors[keyof ResetClockErrors];\n\nexport type ResetClockResponses = {\n    /**\n     * The clock was successfully reset to the system time.\n     */\n    204: void;\n};\n\nexport type ResetClockResponse = ResetClockResponses[keyof ResetClockResponses];\n\nexport type SearchProcessDefinitionsData = {\n    body?: ProcessDefinitionSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/process-definitions/search';\n};\n\nexport type SearchProcessDefinitionsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchProcessDefinitionsError = SearchProcessDefinitionsErrors[keyof SearchProcessDefinitionsErrors];\n\nexport type SearchProcessDefinitionsResponses = {\n    /**\n     * The process definition search result.\n     */\n    200: ProcessDefinitionSearchQueryResult;\n};\n\nexport type SearchProcessDefinitionsResponse = SearchProcessDefinitionsResponses[keyof SearchProcessDefinitionsResponses];\n\nexport type GetProcessDefinitionData = {\n    body?: never;\n    path: {\n        /**\n         * The assigned key of the process definition, which acts as a unique identifier for this process definition.\n         *\n         */\n        processDefinitionKey: ProcessDefinitionKey;\n    };\n    query?: never;\n    url: '/process-definitions/{processDefinitionKey}';\n};\n\nexport type GetProcessDefinitionErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The process definition with the given key was not found. More details are provided in the response body.\n     *\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetProcessDefinitionError = GetProcessDefinitionErrors[keyof GetProcessDefinitionErrors];\n\nexport type GetProcessDefinitionResponses = {\n    /**\n     * The process definition is successfully returned.\n     */\n    200: ProcessDefinitionResult;\n};\n\nexport type GetProcessDefinitionResponse = GetProcessDefinitionResponses[keyof GetProcessDefinitionResponses];\n\nexport type GetProcessDefinitionXmlData = {\n    body?: never;\n    path: {\n        /**\n         * The assigned key of the process definition, which acts as a unique identifier for this process definition.\n         */\n        processDefinitionKey: ProcessDefinitionKey;\n    };\n    query?: never;\n    url: '/process-definitions/{processDefinitionKey}/xml';\n};\n\nexport type GetProcessDefinitionXmlErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The decision with the given key was not found. More details are provided in the response body.\n     *\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetProcessDefinitionXmlError = GetProcessDefinitionXmlErrors[keyof GetProcessDefinitionXmlErrors];\n\nexport type GetProcessDefinitionXmlResponses = {\n    /**\n     * The XML of the process definition is successfully returned.\n     */\n    200: string;\n    /**\n     * The process definition was found but does not have XML.\n     */\n    204: string;\n};\n\nexport type GetProcessDefinitionXmlResponse = GetProcessDefinitionXmlResponses[keyof GetProcessDefinitionXmlResponses];\n\nexport type GetStartProcessFormData = {\n    body?: never;\n    path: {\n        /**\n         * The process key.\n         */\n        processDefinitionKey: ProcessDefinitionKey;\n    };\n    query?: never;\n    url: '/process-definitions/{processDefinitionKey}/form';\n};\n\nexport type GetStartProcessFormErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetStartProcessFormError = GetStartProcessFormErrors[keyof GetStartProcessFormErrors];\n\nexport type GetStartProcessFormResponses = {\n    /**\n     * The form is successfully returned.\n     */\n    200: FormResult;\n    /**\n     * The process was found, but no form is associated with it.\n     */\n    204: void;\n};\n\nexport type GetStartProcessFormResponse = GetStartProcessFormResponses[keyof GetStartProcessFormResponses];\n\nexport type GetProcessDefinitionStatisticsData = {\n    body?: ProcessDefinitionElementStatisticsQuery;\n    path: {\n        /**\n         * The assigned key of the process definition, which acts as a unique identifier for this process definition.\n         */\n        processDefinitionKey: ProcessDefinitionKey;\n    };\n    query?: never;\n    url: '/process-definitions/{processDefinitionKey}/statistics/element-instances';\n};\n\nexport type GetProcessDefinitionStatisticsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetProcessDefinitionStatisticsError = GetProcessDefinitionStatisticsErrors[keyof GetProcessDefinitionStatisticsErrors];\n\nexport type GetProcessDefinitionStatisticsResponses = {\n    /**\n     * The process definition statistics result.\n     */\n    200: ProcessDefinitionElementStatisticsQueryResult;\n};\n\nexport type GetProcessDefinitionStatisticsResponse = GetProcessDefinitionStatisticsResponses[keyof GetProcessDefinitionStatisticsResponses];\n\nexport type CreateProcessInstanceData = {\n    body: ProcessInstanceCreationInstruction;\n    path?: never;\n    query?: never;\n    url: '/process-instances';\n};\n\nexport type CreateProcessInstanceErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n    /**\n     * The process instance creation request timed out in the gateway.\n     *\n     * This can happen if the `awaitCompletion` request parameter is set to `true`\n     * and the created process instance did not complete within the defined request timeout.\n     * This often happens when the created instance is not fully automated or contains wait states.\n     *\n     */\n    504: ProblemDetail;\n};\n\nexport type CreateProcessInstanceError = CreateProcessInstanceErrors[keyof CreateProcessInstanceErrors];\n\nexport type CreateProcessInstanceResponses = {\n    /**\n     * The process instance was created.\n     */\n    200: CreateProcessInstanceResult;\n};\n\nexport type CreateProcessInstanceResponse = CreateProcessInstanceResponses[keyof CreateProcessInstanceResponses];\n\nexport type GetProcessInstanceData = {\n    body?: never;\n    path: {\n        /**\n         * The process instance key.\n         */\n        processInstanceKey: ProcessInstanceKey;\n    };\n    query?: never;\n    url: '/process-instances/{processInstanceKey}';\n};\n\nexport type GetProcessInstanceErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The process instance with the given key was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetProcessInstanceError = GetProcessInstanceErrors[keyof GetProcessInstanceErrors];\n\nexport type GetProcessInstanceResponses = {\n    /**\n     * The process instance is successfully returned.\n     */\n    200: ProcessInstanceResult;\n};\n\nexport type GetProcessInstanceResponse = GetProcessInstanceResponses[keyof GetProcessInstanceResponses];\n\nexport type GetProcessInstanceSequenceFlowsData = {\n    body?: never;\n    path: {\n        /**\n         * The assigned key of the process instance, which acts as a unique identifier for this process instance.\n         */\n        processInstanceKey: ProcessInstanceKey;\n    };\n    query?: never;\n    url: '/process-instances/{processInstanceKey}/sequence-flows';\n};\n\nexport type GetProcessInstanceSequenceFlowsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetProcessInstanceSequenceFlowsError = GetProcessInstanceSequenceFlowsErrors[keyof GetProcessInstanceSequenceFlowsErrors];\n\nexport type GetProcessInstanceSequenceFlowsResponses = {\n    /**\n     * The process instance sequence flows result.\n     */\n    200: ProcessInstanceSequenceFlowsQueryResult;\n};\n\nexport type GetProcessInstanceSequenceFlowsResponse = GetProcessInstanceSequenceFlowsResponses[keyof GetProcessInstanceSequenceFlowsResponses];\n\nexport type GetProcessInstanceStatisticsData = {\n    body?: never;\n    path: {\n        /**\n         * The assigned key of the process instance, which acts as a unique identifier for this process instance.\n         */\n        processInstanceKey: ProcessInstanceKey;\n    };\n    query?: never;\n    url: '/process-instances/{processInstanceKey}/statistics/element-instances';\n};\n\nexport type GetProcessInstanceStatisticsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetProcessInstanceStatisticsError = GetProcessInstanceStatisticsErrors[keyof GetProcessInstanceStatisticsErrors];\n\nexport type GetProcessInstanceStatisticsResponses = {\n    /**\n     * The process instance statistics result.\n     */\n    200: ProcessInstanceElementStatisticsQueryResult;\n};\n\nexport type GetProcessInstanceStatisticsResponse = GetProcessInstanceStatisticsResponses[keyof GetProcessInstanceStatisticsResponses];\n\nexport type SearchProcessInstancesData = {\n    body?: ProcessInstanceSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/process-instances/search';\n};\n\nexport type SearchProcessInstancesErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchProcessInstancesError = SearchProcessInstancesErrors[keyof SearchProcessInstancesErrors];\n\nexport type SearchProcessInstancesResponses = {\n    /**\n     * The process instance search result.\n     */\n    200: ProcessInstanceSearchQueryResult;\n};\n\nexport type SearchProcessInstancesResponse = SearchProcessInstancesResponses[keyof SearchProcessInstancesResponses];\n\nexport type SearchProcessInstanceIncidentsData = {\n    body?: ProcessInstanceIncidentSearchQuery;\n    path: {\n        /**\n         * The assigned key of the process instance, which acts as a unique identifier for this process instance.\n         */\n        processInstanceKey: ProcessInstanceKey;\n    };\n    query?: never;\n    url: '/process-instances/{processInstanceKey}/incidents/search';\n};\n\nexport type SearchProcessInstanceIncidentsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The process instance with the given key was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchProcessInstanceIncidentsError = SearchProcessInstanceIncidentsErrors[keyof SearchProcessInstanceIncidentsErrors];\n\nexport type SearchProcessInstanceIncidentsResponses = {\n    /**\n     * The process instance search result.\n     */\n    200: IncidentSearchQueryResult;\n};\n\nexport type SearchProcessInstanceIncidentsResponse = SearchProcessInstanceIncidentsResponses[keyof SearchProcessInstanceIncidentsResponses];\n\nexport type CancelProcessInstanceData = {\n    body?: CancelProcessInstanceRequest;\n    path: {\n        /**\n         * The key of the process instance to cancel.\n         */\n        processInstanceKey: ProcessInstanceKey;\n    };\n    query?: never;\n    url: '/process-instances/{processInstanceKey}/cancellation';\n};\n\nexport type CancelProcessInstanceErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The process instance is not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type CancelProcessInstanceError = CancelProcessInstanceErrors[keyof CancelProcessInstanceErrors];\n\nexport type CancelProcessInstanceResponses = {\n    /**\n     * The process instance is canceled.\n     */\n    204: void;\n};\n\nexport type CancelProcessInstanceResponse = CancelProcessInstanceResponses[keyof CancelProcessInstanceResponses];\n\nexport type CancelProcessInstancesBatchOperationData = {\n    body: ProcessInstanceCancellationBatchOperationRequest;\n    path?: never;\n    query?: never;\n    url: '/process-instances/cancellation';\n};\n\nexport type CancelProcessInstancesBatchOperationErrors = {\n    /**\n     * The process instance batch operation failed. More details are provided in the response body.\n     *\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type CancelProcessInstancesBatchOperationError = CancelProcessInstancesBatchOperationErrors[keyof CancelProcessInstancesBatchOperationErrors];\n\nexport type CancelProcessInstancesBatchOperationResponses = {\n    /**\n     * The batch operation request was created.\n     */\n    200: BatchOperationCreatedResult;\n};\n\nexport type CancelProcessInstancesBatchOperationResponse = CancelProcessInstancesBatchOperationResponses[keyof CancelProcessInstancesBatchOperationResponses];\n\nexport type ResolveIncidentsBatchOperationData = {\n    body?: ProcessInstanceIncidentResolutionBatchOperationRequest;\n    path?: never;\n    query?: never;\n    url: '/process-instances/incident-resolution';\n};\n\nexport type ResolveIncidentsBatchOperationErrors = {\n    /**\n     * The process instance batch operation failed. More details are provided in the response body.\n     *\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type ResolveIncidentsBatchOperationError = ResolveIncidentsBatchOperationErrors[keyof ResolveIncidentsBatchOperationErrors];\n\nexport type ResolveIncidentsBatchOperationResponses = {\n    /**\n     * The batch operation request was created.\n     */\n    200: BatchOperationCreatedResult;\n};\n\nexport type ResolveIncidentsBatchOperationResponse = ResolveIncidentsBatchOperationResponses[keyof ResolveIncidentsBatchOperationResponses];\n\nexport type MigrateProcessInstancesBatchOperationData = {\n    body: ProcessInstanceMigrationBatchOperationRequest;\n    path?: never;\n    query?: never;\n    url: '/process-instances/migration';\n};\n\nexport type MigrateProcessInstancesBatchOperationErrors = {\n    /**\n     * The process instance batch operation failed. More details are provided in the response body.\n     *\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type MigrateProcessInstancesBatchOperationError = MigrateProcessInstancesBatchOperationErrors[keyof MigrateProcessInstancesBatchOperationErrors];\n\nexport type MigrateProcessInstancesBatchOperationResponses = {\n    /**\n     * The batch operation request was created.\n     */\n    200: BatchOperationCreatedResult;\n};\n\nexport type MigrateProcessInstancesBatchOperationResponse = MigrateProcessInstancesBatchOperationResponses[keyof MigrateProcessInstancesBatchOperationResponses];\n\nexport type ModifyProcessInstancesBatchOperationData = {\n    body: ProcessInstanceModificationBatchOperationRequest;\n    path?: never;\n    query?: never;\n    url: '/process-instances/modification';\n};\n\nexport type ModifyProcessInstancesBatchOperationErrors = {\n    /**\n     * The process instance batch operation failed. More details are provided in the response body.\n     *\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type ModifyProcessInstancesBatchOperationError = ModifyProcessInstancesBatchOperationErrors[keyof ModifyProcessInstancesBatchOperationErrors];\n\nexport type ModifyProcessInstancesBatchOperationResponses = {\n    /**\n     * The batch operation request was created.\n     */\n    200: BatchOperationCreatedResult;\n};\n\nexport type ModifyProcessInstancesBatchOperationResponse = ModifyProcessInstancesBatchOperationResponses[keyof ModifyProcessInstancesBatchOperationResponses];\n\nexport type MigrateProcessInstanceData = {\n    body: ProcessInstanceMigrationInstruction;\n    path: {\n        /**\n         * The key of the process instance that should be migrated.\n         */\n        processInstanceKey: ProcessInstanceKey;\n    };\n    query?: never;\n    url: '/process-instances/{processInstanceKey}/migration';\n};\n\nexport type MigrateProcessInstanceErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The process instance is not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The process instance migration failed. More details are provided in the response body.\n     *\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type MigrateProcessInstanceError = MigrateProcessInstanceErrors[keyof MigrateProcessInstanceErrors];\n\nexport type MigrateProcessInstanceResponses = {\n    /**\n     * The process instance is migrated.\n     */\n    204: void;\n};\n\nexport type MigrateProcessInstanceResponse = MigrateProcessInstanceResponses[keyof MigrateProcessInstanceResponses];\n\nexport type ModifyProcessInstanceData = {\n    body: ProcessInstanceModificationInstruction;\n    path: {\n        /**\n         * The key of the process instance that should be modified.\n         */\n        processInstanceKey: ProcessInstanceKey;\n    };\n    query?: never;\n    url: '/process-instances/{processInstanceKey}/modification';\n};\n\nexport type ModifyProcessInstanceErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The process instance is not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type ModifyProcessInstanceError = ModifyProcessInstanceErrors[keyof ModifyProcessInstanceErrors];\n\nexport type ModifyProcessInstanceResponses = {\n    /**\n     * The process instance is modified.\n     */\n    204: void;\n};\n\nexport type ModifyProcessInstanceResponse = ModifyProcessInstanceResponses[keyof ModifyProcessInstanceResponses];\n\nexport type GetProcessInstanceCallHierarchyData = {\n    body?: never;\n    path: {\n        /**\n         * The key of the process instance to fetch the hierarchy for.\n         */\n        processInstanceKey: ProcessInstanceKey;\n    };\n    query?: never;\n    url: '/process-instances/{processInstanceKey}/call-hierarchy';\n};\n\nexport type GetProcessInstanceCallHierarchyErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The process instance is not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetProcessInstanceCallHierarchyError = GetProcessInstanceCallHierarchyErrors[keyof GetProcessInstanceCallHierarchyErrors];\n\nexport type GetProcessInstanceCallHierarchyResponses = {\n    /**\n     * The call hierarchy is successfully returned.\n     */\n    200: Array<ProcessInstanceCallHierarchyEntry>;\n};\n\nexport type GetProcessInstanceCallHierarchyResponse = GetProcessInstanceCallHierarchyResponses[keyof GetProcessInstanceCallHierarchyResponses];\n\nexport type SearchElementInstancesData = {\n    body?: ElementInstanceSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/element-instances/search';\n};\n\nexport type SearchElementInstancesErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchElementInstancesError = SearchElementInstancesErrors[keyof SearchElementInstancesErrors];\n\nexport type SearchElementInstancesResponses = {\n    /**\n     * The element instance search result.\n     */\n    200: ElementInstanceSearchQueryResult;\n};\n\nexport type SearchElementInstancesResponse = SearchElementInstancesResponses[keyof SearchElementInstancesResponses];\n\nexport type GetElementInstanceData = {\n    body?: never;\n    path: {\n        /**\n         * The assigned key of the element instance, which acts as a unique identifier for this element instance.\n         */\n        elementInstanceKey: ElementInstanceKey;\n    };\n    query?: never;\n    url: '/element-instances/{elementInstanceKey}';\n};\n\nexport type GetElementInstanceErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The element instance with the given key was not found. More details are provided in the response body.\n     *\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetElementInstanceError = GetElementInstanceErrors[keyof GetElementInstanceErrors];\n\nexport type GetElementInstanceResponses = {\n    /**\n     * The element instance is successfully returned.\n     */\n    200: ElementInstanceResult;\n};\n\nexport type GetElementInstanceResponse = GetElementInstanceResponses[keyof GetElementInstanceResponses];\n\nexport type SearchDecisionDefinitionsData = {\n    body?: DecisionDefinitionSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/decision-definitions/search';\n};\n\nexport type SearchDecisionDefinitionsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchDecisionDefinitionsError = SearchDecisionDefinitionsErrors[keyof SearchDecisionDefinitionsErrors];\n\nexport type SearchDecisionDefinitionsResponses = {\n    /**\n     * The decision definition search result.\n     */\n    200: DecisionDefinitionSearchQueryResult;\n};\n\nexport type SearchDecisionDefinitionsResponse = SearchDecisionDefinitionsResponses[keyof SearchDecisionDefinitionsResponses];\n\nexport type GetDecisionDefinitionData = {\n    body?: never;\n    path: {\n        /**\n         * The assigned key of the decision definition, which acts as a unique identifier for this decision.\n         */\n        decisionDefinitionKey: DecisionDefinitionKey;\n    };\n    query?: never;\n    url: '/decision-definitions/{decisionDefinitionKey}';\n};\n\nexport type GetDecisionDefinitionErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The decision with the given key was not found. More details are provided in the response body.\n     *\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetDecisionDefinitionError = GetDecisionDefinitionErrors[keyof GetDecisionDefinitionErrors];\n\nexport type GetDecisionDefinitionResponses = {\n    /**\n     * The decision definition is successfully returned.\n     *\n     */\n    200: DecisionDefinitionResult;\n};\n\nexport type GetDecisionDefinitionResponse = GetDecisionDefinitionResponses[keyof GetDecisionDefinitionResponses];\n\nexport type GetDecisionDefinitionXmlData = {\n    body?: never;\n    path: {\n        /**\n         * The assigned key of the decision definition, which acts as a unique identifier for this decision.\n         */\n        decisionDefinitionKey: DecisionDefinitionKey;\n    };\n    query?: never;\n    url: '/decision-definitions/{decisionDefinitionKey}/xml';\n};\n\nexport type GetDecisionDefinitionXmlErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The decision with the given key was not found. More details are provided in the response body.\n     *\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetDecisionDefinitionXmlError = GetDecisionDefinitionXmlErrors[keyof GetDecisionDefinitionXmlErrors];\n\nexport type GetDecisionDefinitionXmlResponses = {\n    /**\n     * The XML of the decision definition is successfully returned.\n     */\n    200: string;\n};\n\nexport type GetDecisionDefinitionXmlResponse = GetDecisionDefinitionXmlResponses[keyof GetDecisionDefinitionXmlResponses];\n\nexport type SearchDecisionRequirementsData = {\n    body?: DecisionRequirementsSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/decision-requirements/search';\n};\n\nexport type SearchDecisionRequirementsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchDecisionRequirementsError = SearchDecisionRequirementsErrors[keyof SearchDecisionRequirementsErrors];\n\nexport type SearchDecisionRequirementsResponses = {\n    /**\n     * The decision requirements search result.\n     */\n    200: DecisionRequirementsSearchQueryResult;\n};\n\nexport type SearchDecisionRequirementsResponse = SearchDecisionRequirementsResponses[keyof SearchDecisionRequirementsResponses];\n\nexport type GetDecisionRequirementsData = {\n    body?: never;\n    path: {\n        /**\n         * The assigned key of the decision requirements, which acts as a unique identifier for this decision requirements.\n         */\n        decisionRequirementsKey: DecisionRequirementsKey;\n    };\n    query?: never;\n    url: '/decision-requirements/{decisionRequirementsKey}';\n};\n\nexport type GetDecisionRequirementsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The decision requirements with the given key was not found. More details are provided in the response body.\n     *\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetDecisionRequirementsError = GetDecisionRequirementsErrors[keyof GetDecisionRequirementsErrors];\n\nexport type GetDecisionRequirementsResponses = {\n    /**\n     * The decision requirements is successfully returned.\n     */\n    200: DecisionRequirementsResult;\n};\n\nexport type GetDecisionRequirementsResponse = GetDecisionRequirementsResponses[keyof GetDecisionRequirementsResponses];\n\nexport type GetDecisionRequirementsXmlData = {\n    body?: never;\n    path: {\n        /**\n         * The assigned key of the decision requirements, which acts as a unique identifier for this decision.\n         */\n        decisionRequirementsKey: DecisionRequirementsKey;\n    };\n    query?: never;\n    url: '/decision-requirements/{decisionRequirementsKey}/xml';\n};\n\nexport type GetDecisionRequirementsXmlErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The decision requirements with the given key was not found. More details are provided in the response body.\n     *\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetDecisionRequirementsXmlError = GetDecisionRequirementsXmlErrors[keyof GetDecisionRequirementsXmlErrors];\n\nexport type GetDecisionRequirementsXmlResponses = {\n    /**\n     * The XML of the decision requirements is successfully returned.\n     */\n    200: string;\n};\n\nexport type GetDecisionRequirementsXmlResponse = GetDecisionRequirementsXmlResponses[keyof GetDecisionRequirementsXmlResponses];\n\nexport type SearchDecisionInstancesData = {\n    body?: DecisionInstanceSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/decision-instances/search';\n};\n\nexport type SearchDecisionInstancesErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchDecisionInstancesError = SearchDecisionInstancesErrors[keyof SearchDecisionInstancesErrors];\n\nexport type SearchDecisionInstancesResponses = {\n    /**\n     * The decision instance search result.\n     */\n    200: DecisionInstanceSearchQueryResult;\n};\n\nexport type SearchDecisionInstancesResponse = SearchDecisionInstancesResponses[keyof SearchDecisionInstancesResponses];\n\nexport type GetDecisionInstanceData = {\n    body?: never;\n    path: {\n        decisionEvaluationInstanceKey: DecisionEvaluationInstanceKey;\n    };\n    query?: never;\n    url: '/decision-instances/{decisionEvaluationInstanceKey}';\n};\n\nexport type GetDecisionInstanceErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The decision instance with the given ID was not found. More details are provided in the response body.\n     *\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetDecisionInstanceError = GetDecisionInstanceErrors[keyof GetDecisionInstanceErrors];\n\nexport type GetDecisionInstanceResponses = {\n    /**\n     * The decision instance is successfully returned.\n     */\n    200: DecisionInstanceGetQueryResult;\n};\n\nexport type GetDecisionInstanceResponse = GetDecisionInstanceResponses[keyof GetDecisionInstanceResponses];\n\nexport type EvaluateDecisionData = {\n    body: DecisionEvaluationInstruction;\n    path?: never;\n    query?: never;\n    url: '/decision-definitions/evaluation';\n};\n\nexport type EvaluateDecisionErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The decision is not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type EvaluateDecisionError = EvaluateDecisionErrors[keyof EvaluateDecisionErrors];\n\nexport type EvaluateDecisionResponses = {\n    /**\n     * The decision was evaluated.\n     */\n    200: EvaluateDecisionResult;\n};\n\nexport type EvaluateDecisionResponse = EvaluateDecisionResponses[keyof EvaluateDecisionResponses];\n\nexport type CreateAuthorizationData = {\n    body: AuthorizationRequest;\n    path?: never;\n    query?: never;\n    url: '/authorizations';\n};\n\nexport type CreateAuthorizationErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The owner was not found.\n     *\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type CreateAuthorizationError = CreateAuthorizationErrors[keyof CreateAuthorizationErrors];\n\nexport type CreateAuthorizationResponses = {\n    /**\n     * The authorization was created successfully.\n     *\n     */\n    201: AuthorizationCreateResult;\n};\n\nexport type CreateAuthorizationResponse = CreateAuthorizationResponses[keyof CreateAuthorizationResponses];\n\nexport type DeleteAuthorizationData = {\n    body?: never;\n    path: {\n        /**\n         * The key of the authorization to delete.\n         */\n        authorizationKey: AuthorizationKey;\n    };\n    query?: never;\n    url: '/authorizations/{authorizationKey}';\n};\n\nexport type DeleteAuthorizationErrors = {\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * The authorization with the authorizationKey was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type DeleteAuthorizationError = DeleteAuthorizationErrors[keyof DeleteAuthorizationErrors];\n\nexport type DeleteAuthorizationResponses = {\n    /**\n     * The authorization was deleted successfully.\n     */\n    204: void;\n};\n\nexport type DeleteAuthorizationResponse = DeleteAuthorizationResponses[keyof DeleteAuthorizationResponses];\n\nexport type GetAuthorizationData = {\n    body?: never;\n    path: {\n        /**\n         * The key of the authorization to get.\n         */\n        authorizationKey: AuthorizationKey;\n    };\n    query?: never;\n    url: '/authorizations/{authorizationKey}';\n};\n\nexport type GetAuthorizationErrors = {\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The authorization with the given key was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetAuthorizationError = GetAuthorizationErrors[keyof GetAuthorizationErrors];\n\nexport type GetAuthorizationResponses = {\n    /**\n     * The authorization was successfully returned.\n     */\n    200: AuthorizationResult;\n};\n\nexport type GetAuthorizationResponse = GetAuthorizationResponses[keyof GetAuthorizationResponses];\n\nexport type UpdateAuthorizationData = {\n    body: AuthorizationRequest;\n    path: {\n        /**\n         * The key of the authorization to delete.\n         */\n        authorizationKey: AuthorizationKey;\n    };\n    query?: never;\n    url: '/authorizations/{authorizationKey}';\n};\n\nexport type UpdateAuthorizationErrors = {\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * The authorization with the authorizationKey was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UpdateAuthorizationError = UpdateAuthorizationErrors[keyof UpdateAuthorizationErrors];\n\nexport type UpdateAuthorizationResponses = {\n    /**\n     * The authorization was updated successfully.\n     */\n    204: void;\n};\n\nexport type UpdateAuthorizationResponse = UpdateAuthorizationResponses[keyof UpdateAuthorizationResponses];\n\nexport type SearchAuthorizationsData = {\n    body?: AuthorizationSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/authorizations/search';\n};\n\nexport type SearchAuthorizationsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchAuthorizationsError = SearchAuthorizationsErrors[keyof SearchAuthorizationsErrors];\n\nexport type SearchAuthorizationsResponses = {\n    /**\n     * The authorization search result.\n     */\n    200: AuthorizationSearchResult;\n};\n\nexport type SearchAuthorizationsResponse = SearchAuthorizationsResponses[keyof SearchAuthorizationsResponses];\n\nexport type CreateRoleData = {\n    body?: RoleCreateRequest;\n    path?: never;\n    query?: never;\n    url: '/roles';\n};\n\nexport type CreateRoleErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type CreateRoleError = CreateRoleErrors[keyof CreateRoleErrors];\n\nexport type CreateRoleResponses = {\n    /**\n     * The role was created successfully.\n     *\n     */\n    201: RoleCreateResult;\n};\n\nexport type CreateRoleResponse = CreateRoleResponses[keyof CreateRoleResponses];\n\nexport type DeleteRoleData = {\n    body?: never;\n    path: {\n        /**\n         * The ID of the role to delete.\n         */\n        roleId: string;\n    };\n    query?: never;\n    url: '/roles/{roleId}';\n};\n\nexport type DeleteRoleErrors = {\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * The role with the ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type DeleteRoleError = DeleteRoleErrors[keyof DeleteRoleErrors];\n\nexport type DeleteRoleResponses = {\n    /**\n     * The role was deleted successfully.\n     */\n    204: void;\n};\n\nexport type DeleteRoleResponse = DeleteRoleResponses[keyof DeleteRoleResponses];\n\nexport type GetRoleData = {\n    body?: never;\n    path: {\n        /**\n         * The role ID.\n         */\n        roleId: string;\n    };\n    query?: never;\n    url: '/roles/{roleId}';\n};\n\nexport type GetRoleErrors = {\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The role with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetRoleError = GetRoleErrors[keyof GetRoleErrors];\n\nexport type GetRoleResponses = {\n    /**\n     * The role is successfully returned.\n     */\n    200: RoleResult;\n};\n\nexport type GetRoleResponse = GetRoleResponses[keyof GetRoleResponses];\n\nexport type UpdateRoleData = {\n    body: RoleUpdateRequest;\n    path: {\n        /**\n         * The ID of the role to update.\n         */\n        roleId: string;\n    };\n    query?: never;\n    url: '/roles/{roleId}';\n};\n\nexport type UpdateRoleErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * The role with the ID is not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UpdateRoleError = UpdateRoleErrors[keyof UpdateRoleErrors];\n\nexport type UpdateRoleResponses = {\n    /**\n     * The role was updated successfully.\n     */\n    200: RoleUpdateResult;\n};\n\nexport type UpdateRoleResponse = UpdateRoleResponses[keyof UpdateRoleResponses];\n\nexport type SearchUsersForRoleData = {\n    body?: RoleUserSearchQueryRequest;\n    path: {\n        /**\n         * The role ID.\n         */\n        roleId: string;\n    };\n    query?: never;\n    url: '/roles/{roleId}/users/search';\n};\n\nexport type SearchUsersForRoleErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The role with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchUsersForRoleError = SearchUsersForRoleErrors[keyof SearchUsersForRoleErrors];\n\nexport type SearchUsersForRoleResponses = {\n    /**\n     * The users with the assigned role.\n     */\n    200: RoleUserSearchResult;\n};\n\nexport type SearchUsersForRoleResponse = SearchUsersForRoleResponses[keyof SearchUsersForRoleResponses];\n\nexport type SearchClientsForRoleData = {\n    body?: RoleClientSearchQueryRequest;\n    path: {\n        /**\n         * The role ID.\n         */\n        roleId: string;\n    };\n    query?: never;\n    url: '/roles/{roleId}/clients/search';\n};\n\nexport type SearchClientsForRoleErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The role with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchClientsForRoleError = SearchClientsForRoleErrors[keyof SearchClientsForRoleErrors];\n\nexport type SearchClientsForRoleResponses = {\n    /**\n     * The clients with the assigned role.\n     */\n    200: RoleClientSearchResult;\n};\n\nexport type SearchClientsForRoleResponse = SearchClientsForRoleResponses[keyof SearchClientsForRoleResponses];\n\nexport type UnassignRoleFromUserData = {\n    body?: never;\n    path: {\n        /**\n         * The role ID.\n         */\n        roleId: string;\n        /**\n         * The user username.\n         */\n        username: Username;\n    };\n    query?: never;\n    url: '/roles/{roleId}/users/{username}';\n};\n\nexport type UnassignRoleFromUserErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The role or user with the given ID or username was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UnassignRoleFromUserError = UnassignRoleFromUserErrors[keyof UnassignRoleFromUserErrors];\n\nexport type UnassignRoleFromUserResponses = {\n    /**\n     * The role was unassigned successfully from the user.\n     */\n    204: void;\n};\n\nexport type UnassignRoleFromUserResponse = UnassignRoleFromUserResponses[keyof UnassignRoleFromUserResponses];\n\nexport type AssignRoleToUserData = {\n    body?: never;\n    path: {\n        /**\n         * The role ID.\n         */\n        roleId: string;\n        /**\n         * The user username.\n         */\n        username: Username;\n    };\n    query?: never;\n    url: '/roles/{roleId}/users/{username}';\n};\n\nexport type AssignRoleToUserErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The role or user with the given ID or username was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The role is already assigned to the user with the given ID.\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type AssignRoleToUserError = AssignRoleToUserErrors[keyof AssignRoleToUserErrors];\n\nexport type AssignRoleToUserResponses = {\n    /**\n     * The role was assigned successfully to the user.\n     */\n    204: void;\n};\n\nexport type AssignRoleToUserResponse = AssignRoleToUserResponses[keyof AssignRoleToUserResponses];\n\nexport type UnassignRoleFromClientData = {\n    body?: never;\n    path: {\n        /**\n         * The role ID.\n         */\n        roleId: string;\n        /**\n         * The client ID.\n         */\n        clientId: string;\n    };\n    query?: never;\n    url: '/roles/{roleId}/clients/{clientId}';\n};\n\nexport type UnassignRoleFromClientErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The role or client with the given ID or username was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UnassignRoleFromClientError = UnassignRoleFromClientErrors[keyof UnassignRoleFromClientErrors];\n\nexport type UnassignRoleFromClientResponses = {\n    /**\n     * The role was unassigned successfully from the client.\n     */\n    204: void;\n};\n\nexport type UnassignRoleFromClientResponse = UnassignRoleFromClientResponses[keyof UnassignRoleFromClientResponses];\n\nexport type AssignRoleToClientData = {\n    body?: never;\n    path: {\n        /**\n         * The role ID.\n         */\n        roleId: string;\n        /**\n         * The client ID.\n         */\n        clientId: string;\n    };\n    query?: never;\n    url: '/roles/{roleId}/clients/{clientId}';\n};\n\nexport type AssignRoleToClientErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The role with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The role was already assigned to the client with the given ID.\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type AssignRoleToClientError = AssignRoleToClientErrors[keyof AssignRoleToClientErrors];\n\nexport type AssignRoleToClientResponses = {\n    /**\n     * The role was assigned successfully to the client.\n     */\n    204: void;\n};\n\nexport type AssignRoleToClientResponse = AssignRoleToClientResponses[keyof AssignRoleToClientResponses];\n\nexport type SearchRolesData = {\n    body?: RoleSearchQueryRequest;\n    path?: never;\n    query?: never;\n    url: '/roles/search';\n};\n\nexport type SearchRolesErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchRolesError = SearchRolesErrors[keyof SearchRolesErrors];\n\nexport type SearchRolesResponses = {\n    /**\n     * The roles search result.\n     */\n    200: RoleSearchQueryResult;\n};\n\nexport type SearchRolesResponse = SearchRolesResponses[keyof SearchRolesResponses];\n\nexport type UnassignRoleFromGroupData = {\n    body?: never;\n    path: {\n        /**\n         * The role ID.\n         */\n        roleId: string;\n        /**\n         * The group ID.\n         */\n        groupId: string;\n    };\n    query?: never;\n    url: '/roles/{roleId}/groups/{groupId}';\n};\n\nexport type UnassignRoleFromGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The role or group with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UnassignRoleFromGroupError = UnassignRoleFromGroupErrors[keyof UnassignRoleFromGroupErrors];\n\nexport type UnassignRoleFromGroupResponses = {\n    /**\n     * The role was unassigned successfully from the group.\n     */\n    204: void;\n};\n\nexport type UnassignRoleFromGroupResponse = UnassignRoleFromGroupResponses[keyof UnassignRoleFromGroupResponses];\n\nexport type AssignRoleToGroupData = {\n    body?: never;\n    path: {\n        /**\n         * The role ID.\n         */\n        roleId: string;\n        /**\n         * The group ID.\n         */\n        groupId: string;\n    };\n    query?: never;\n    url: '/roles/{roleId}/groups/{groupId}';\n};\n\nexport type AssignRoleToGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The role or group with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The role is already assigned to the group with the given ID.\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type AssignRoleToGroupError = AssignRoleToGroupErrors[keyof AssignRoleToGroupErrors];\n\nexport type AssignRoleToGroupResponses = {\n    /**\n     * The role was assigned successfully to the group.\n     */\n    204: void;\n};\n\nexport type AssignRoleToGroupResponse = AssignRoleToGroupResponses[keyof AssignRoleToGroupResponses];\n\nexport type SearchGroupsForRoleData = {\n    body?: RoleGroupSearchQueryRequest;\n    path: {\n        /**\n         * The role ID.\n         */\n        roleId: string;\n    };\n    query?: never;\n    url: '/roles/{roleId}/groups/search';\n};\n\nexport type SearchGroupsForRoleErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The role with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchGroupsForRoleError = SearchGroupsForRoleErrors[keyof SearchGroupsForRoleErrors];\n\nexport type SearchGroupsForRoleResponses = {\n    /**\n     * The groups with assigned role.\n     */\n    200: RoleGroupSearchResult;\n};\n\nexport type SearchGroupsForRoleResponse = SearchGroupsForRoleResponses[keyof SearchGroupsForRoleResponses];\n\nexport type UnassignRoleFromMappingRuleData = {\n    body?: never;\n    path: {\n        /**\n         * The role ID.\n         */\n        roleId: string;\n        /**\n         * The mapping rule ID.\n         */\n        mappingRuleId: string;\n    };\n    query?: never;\n    url: '/roles/{roleId}/mapping-rules/{mappingRuleId}';\n};\n\nexport type UnassignRoleFromMappingRuleErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The role or mapping rule with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UnassignRoleFromMappingRuleError = UnassignRoleFromMappingRuleErrors[keyof UnassignRoleFromMappingRuleErrors];\n\nexport type UnassignRoleFromMappingRuleResponses = {\n    /**\n     * The role was unassigned successfully from the mapping rule.\n     */\n    204: void;\n};\n\nexport type UnassignRoleFromMappingRuleResponse = UnassignRoleFromMappingRuleResponses[keyof UnassignRoleFromMappingRuleResponses];\n\nexport type AssignRoleToMappingRuleData = {\n    body?: never;\n    path: {\n        /**\n         * The role ID.\n         */\n        roleId: string;\n        /**\n         * The mapping rule ID.\n         */\n        mappingRuleId: string;\n    };\n    query?: never;\n    url: '/roles/{roleId}/mapping-rules/{mappingRuleId}';\n};\n\nexport type AssignRoleToMappingRuleErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The role or mapping rule with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The role is already assigned to the mapping rule with the given ID.\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type AssignRoleToMappingRuleError = AssignRoleToMappingRuleErrors[keyof AssignRoleToMappingRuleErrors];\n\nexport type AssignRoleToMappingRuleResponses = {\n    /**\n     * The role was assigned successfully to the mapping rule.\n     */\n    204: void;\n};\n\nexport type AssignRoleToMappingRuleResponse = AssignRoleToMappingRuleResponses[keyof AssignRoleToMappingRuleResponses];\n\nexport type SearchMappingRulesForRoleData = {\n    body?: MappingRuleSearchQueryRequest;\n    path: {\n        /**\n         * The role ID.\n         */\n        roleId: string;\n    };\n    query?: never;\n    url: '/roles/{roleId}/mapping-rules/search';\n};\n\nexport type SearchMappingRulesForRoleErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The role with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchMappingRulesForRoleError = SearchMappingRulesForRoleErrors[keyof SearchMappingRulesForRoleErrors];\n\nexport type SearchMappingRulesForRoleResponses = {\n    /**\n     * The mapping rules with assigned role.\n     */\n    200: MappingRuleSearchQueryResult;\n};\n\nexport type SearchMappingRulesForRoleResponse = SearchMappingRulesForRoleResponses[keyof SearchMappingRulesForRoleResponses];\n\nexport type CreateGroupData = {\n    body?: GroupCreateRequest;\n    path?: never;\n    query?: never;\n    url: '/groups';\n};\n\nexport type CreateGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type CreateGroupError = CreateGroupErrors[keyof CreateGroupErrors];\n\nexport type CreateGroupResponses = {\n    /**\n     * The group was created successfully.\n     */\n    201: GroupCreateResult;\n};\n\nexport type CreateGroupResponse = CreateGroupResponses[keyof CreateGroupResponses];\n\nexport type DeleteGroupData = {\n    body?: never;\n    path: {\n        /**\n         * The ID of the group to delete.\n         */\n        groupId: string;\n    };\n    query?: never;\n    url: '/groups/{groupId}';\n};\n\nexport type DeleteGroupErrors = {\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * The group with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type DeleteGroupError = DeleteGroupErrors[keyof DeleteGroupErrors];\n\nexport type DeleteGroupResponses = {\n    /**\n     * The group was deleted successfully.\n     */\n    204: void;\n};\n\nexport type DeleteGroupResponse = DeleteGroupResponses[keyof DeleteGroupResponses];\n\nexport type GetGroupData = {\n    body?: never;\n    path: {\n        /**\n         * The group ID.\n         */\n        groupId: string;\n    };\n    query?: never;\n    url: '/groups/{groupId}';\n};\n\nexport type GetGroupErrors = {\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The group with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetGroupError = GetGroupErrors[keyof GetGroupErrors];\n\nexport type GetGroupResponses = {\n    /**\n     * The group is successfully returned.\n     */\n    200: GroupResult;\n};\n\nexport type GetGroupResponse = GetGroupResponses[keyof GetGroupResponses];\n\nexport type UpdateGroupData = {\n    body: GroupUpdateRequest;\n    path: {\n        /**\n         * The ID of the group to update.\n         */\n        groupId: string;\n    };\n    query?: never;\n    url: '/groups/{groupId}';\n};\n\nexport type UpdateGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * The group with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UpdateGroupError = UpdateGroupErrors[keyof UpdateGroupErrors];\n\nexport type UpdateGroupResponses = {\n    /**\n     * The group was updated successfully.\n     */\n    200: GroupUpdateResult;\n};\n\nexport type UpdateGroupResponse = UpdateGroupResponses[keyof UpdateGroupResponses];\n\nexport type SearchUsersForGroupData = {\n    body?: GroupUserSearchQueryRequest;\n    path: {\n        /**\n         * The group ID.\n         */\n        groupId: string;\n    };\n    query?: never;\n    url: '/groups/{groupId}/users/search';\n};\n\nexport type SearchUsersForGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The group with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchUsersForGroupError = SearchUsersForGroupErrors[keyof SearchUsersForGroupErrors];\n\nexport type SearchUsersForGroupResponses = {\n    /**\n     * The users assigned to the group.\n     */\n    200: GroupUserSearchResult;\n};\n\nexport type SearchUsersForGroupResponse = SearchUsersForGroupResponses[keyof SearchUsersForGroupResponses];\n\nexport type SearchMappingRulesForGroupData = {\n    body?: MappingRuleSearchQueryRequest;\n    path: {\n        /**\n         * The group ID.\n         */\n        groupId: string;\n    };\n    query?: never;\n    url: '/groups/{groupId}/mapping-rules/search';\n};\n\nexport type SearchMappingRulesForGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The group with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchMappingRulesForGroupError = SearchMappingRulesForGroupErrors[keyof SearchMappingRulesForGroupErrors];\n\nexport type SearchMappingRulesForGroupResponses = {\n    /**\n     * The mapping rules assigned to the group.\n     */\n    200: MappingRuleSearchQueryResult;\n};\n\nexport type SearchMappingRulesForGroupResponse = SearchMappingRulesForGroupResponses[keyof SearchMappingRulesForGroupResponses];\n\nexport type SearchRolesForGroupData = {\n    body?: RoleSearchQueryRequest;\n    path: {\n        /**\n         * The group ID.\n         */\n        groupId: string;\n    };\n    query?: never;\n    url: '/groups/{groupId}/roles/search';\n};\n\nexport type SearchRolesForGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The group with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchRolesForGroupError = SearchRolesForGroupErrors[keyof SearchRolesForGroupErrors];\n\nexport type SearchRolesForGroupResponses = {\n    /**\n     * The roles assigned to the group.\n     */\n    200: RoleSearchQueryResult;\n};\n\nexport type SearchRolesForGroupResponse = SearchRolesForGroupResponses[keyof SearchRolesForGroupResponses];\n\nexport type SearchClientsForGroupData = {\n    body?: GroupClientSearchQueryRequest;\n    path: {\n        /**\n         * The group ID.\n         */\n        groupId: string;\n    };\n    query?: never;\n    url: '/groups/{groupId}/clients/search';\n};\n\nexport type SearchClientsForGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The group with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchClientsForGroupError = SearchClientsForGroupErrors[keyof SearchClientsForGroupErrors];\n\nexport type SearchClientsForGroupResponses = {\n    /**\n     * The clients assigned to the group.\n     */\n    200: GroupClientSearchResult;\n};\n\nexport type SearchClientsForGroupResponse = SearchClientsForGroupResponses[keyof SearchClientsForGroupResponses];\n\nexport type UnassignUserFromGroupData = {\n    body?: never;\n    path: {\n        /**\n         * The group ID.\n         */\n        groupId: string;\n        /**\n         * The user username.\n         */\n        username: Username;\n    };\n    query?: never;\n    url: '/groups/{groupId}/users/{username}';\n};\n\nexport type UnassignUserFromGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The group or user with the given ID was not found, or the user is not assigned to this group.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UnassignUserFromGroupError = UnassignUserFromGroupErrors[keyof UnassignUserFromGroupErrors];\n\nexport type UnassignUserFromGroupResponses = {\n    /**\n     * The user was unassigned successfully from the group.\n     */\n    204: void;\n};\n\nexport type UnassignUserFromGroupResponse = UnassignUserFromGroupResponses[keyof UnassignUserFromGroupResponses];\n\nexport type AssignUserToGroupData = {\n    body?: never;\n    path: {\n        /**\n         * The group ID.\n         */\n        groupId: string;\n        /**\n         * The user username.\n         */\n        username: Username;\n    };\n    query?: never;\n    url: '/groups/{groupId}/users/{username}';\n};\n\nexport type AssignUserToGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The group or user with the given ID or username was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The user with the given ID is already assigned to the group.\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type AssignUserToGroupError = AssignUserToGroupErrors[keyof AssignUserToGroupErrors];\n\nexport type AssignUserToGroupResponses = {\n    /**\n     * The user was assigned successfully to the group.\n     */\n    204: void;\n};\n\nexport type AssignUserToGroupResponse = AssignUserToGroupResponses[keyof AssignUserToGroupResponses];\n\nexport type UnassignClientFromGroupData = {\n    body?: never;\n    path: {\n        /**\n         * The group ID.\n         */\n        groupId: string;\n        /**\n         * The client ID.\n         */\n        clientId: string;\n    };\n    query?: never;\n    url: '/groups/{groupId}/clients/{clientId}';\n};\n\nexport type UnassignClientFromGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The group with the given ID was not found, or the client is not assigned to this group.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UnassignClientFromGroupError = UnassignClientFromGroupErrors[keyof UnassignClientFromGroupErrors];\n\nexport type UnassignClientFromGroupResponses = {\n    /**\n     * The client was unassigned successfully from the group.\n     */\n    204: void;\n};\n\nexport type UnassignClientFromGroupResponse = UnassignClientFromGroupResponses[keyof UnassignClientFromGroupResponses];\n\nexport type AssignClientToGroupData = {\n    body?: never;\n    path: {\n        /**\n         * The group ID.\n         */\n        groupId: string;\n        /**\n         * The client ID.\n         */\n        clientId: string;\n    };\n    query?: never;\n    url: '/groups/{groupId}/clients/{clientId}';\n};\n\nexport type AssignClientToGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The group with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The client with the given ID is already assigned to the group.\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type AssignClientToGroupError = AssignClientToGroupErrors[keyof AssignClientToGroupErrors];\n\nexport type AssignClientToGroupResponses = {\n    /**\n     * The client was assigned successfully to the group.\n     */\n    204: void;\n};\n\nexport type AssignClientToGroupResponse = AssignClientToGroupResponses[keyof AssignClientToGroupResponses];\n\nexport type UnassignMappingRuleFromGroupData = {\n    body?: never;\n    path: {\n        /**\n         * The group ID.\n         */\n        groupId: string;\n        /**\n         * The mapping rule ID.\n         */\n        mappingRuleId: string;\n    };\n    query?: never;\n    url: '/groups/{groupId}/mapping-rules/{mappingRuleId}';\n};\n\nexport type UnassignMappingRuleFromGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The group or mapping rule with the given ID was not found, or the mapping rule is not assigned to this group.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UnassignMappingRuleFromGroupError = UnassignMappingRuleFromGroupErrors[keyof UnassignMappingRuleFromGroupErrors];\n\nexport type UnassignMappingRuleFromGroupResponses = {\n    /**\n     * The mapping rule was unassigned successfully from the group.\n     */\n    204: void;\n};\n\nexport type UnassignMappingRuleFromGroupResponse = UnassignMappingRuleFromGroupResponses[keyof UnassignMappingRuleFromGroupResponses];\n\nexport type AssignMappingRuleToGroupData = {\n    body?: never;\n    path: {\n        /**\n         * The group ID.\n         */\n        groupId: string;\n        /**\n         * The mapping rule ID.\n         */\n        mappingRuleId: string;\n    };\n    query?: never;\n    url: '/groups/{groupId}/mapping-rules/{mappingRuleId}';\n};\n\nexport type AssignMappingRuleToGroupErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The group or mapping rule with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * The mapping rule with the given ID is already assigned to the group.\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type AssignMappingRuleToGroupError = AssignMappingRuleToGroupErrors[keyof AssignMappingRuleToGroupErrors];\n\nexport type AssignMappingRuleToGroupResponses = {\n    /**\n     * The mapping rule was assigned successfully to the group.\n     */\n    204: void;\n};\n\nexport type AssignMappingRuleToGroupResponse = AssignMappingRuleToGroupResponses[keyof AssignMappingRuleToGroupResponses];\n\nexport type SearchGroupsData = {\n    body?: GroupSearchQueryRequest;\n    path?: never;\n    query?: never;\n    url: '/groups/search';\n};\n\nexport type SearchGroupsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchGroupsError = SearchGroupsErrors[keyof SearchGroupsErrors];\n\nexport type SearchGroupsResponses = {\n    /**\n     * The groups search result.\n     */\n    200: GroupSearchQueryResult;\n};\n\nexport type SearchGroupsResponse = SearchGroupsResponses[keyof SearchGroupsResponses];\n\nexport type CreateMappingRuleData = {\n    body?: MappingRuleCreateRequest;\n    path?: never;\n    query?: never;\n    url: '/mapping-rules';\n};\n\nexport type CreateMappingRuleErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request to create a mapping rule was denied.\n     * More details are provided in the response body.\n     *\n     */\n    403: ProblemDetail;\n    /**\n     * The request to create a mapping rule was denied.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type CreateMappingRuleError = CreateMappingRuleErrors[keyof CreateMappingRuleErrors];\n\nexport type CreateMappingRuleResponses = {\n    /**\n     * The mapping rule was created successfully.\n     */\n    201: MappingRuleCreateResult;\n};\n\nexport type CreateMappingRuleResponse = CreateMappingRuleResponses[keyof CreateMappingRuleResponses];\n\nexport type DeleteMappingRuleData = {\n    body?: never;\n    path: {\n        /**\n         * The ID of the mapping rule to delete.\n         */\n        mappingRuleId: string;\n    };\n    query?: never;\n    url: '/mapping-rules/{mappingRuleId}';\n};\n\nexport type DeleteMappingRuleErrors = {\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * The mapping rule with the mappingRuleId was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type DeleteMappingRuleError = DeleteMappingRuleErrors[keyof DeleteMappingRuleErrors];\n\nexport type DeleteMappingRuleResponses = {\n    /**\n     * The mapping rule was deleted successfully.\n     */\n    204: void;\n};\n\nexport type DeleteMappingRuleResponse = DeleteMappingRuleResponses[keyof DeleteMappingRuleResponses];\n\nexport type GetMappingRuleData = {\n    body?: never;\n    path: {\n        /**\n         * The ID of the mapping rule to get.\n         */\n        mappingRuleId: string;\n    };\n    query?: never;\n    url: '/mapping-rules/{mappingRuleId}';\n};\n\nexport type GetMappingRuleErrors = {\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * The mapping rule with the mappingRuleId was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetMappingRuleError = GetMappingRuleErrors[keyof GetMappingRuleErrors];\n\nexport type GetMappingRuleResponses = {\n    /**\n     * The mapping rule was returned successfully.\n     */\n    200: MappingRuleResult;\n};\n\nexport type GetMappingRuleResponse = GetMappingRuleResponses[keyof GetMappingRuleResponses];\n\nexport type UpdateMappingRuleData = {\n    body?: MappingRuleUpdateRequest;\n    path: {\n        /**\n         * The ID of the mapping rule to update.\n         */\n        mappingRuleId: string;\n    };\n    query?: never;\n    url: '/mapping-rules/{mappingRuleId}';\n};\n\nexport type UpdateMappingRuleErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request to update a mapping rule was denied.\n     * More details are provided in the response body.\n     *\n     */\n    403: ProblemDetail;\n    /**\n     * The request to update a mapping rule was denied.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UpdateMappingRuleError = UpdateMappingRuleErrors[keyof UpdateMappingRuleErrors];\n\nexport type UpdateMappingRuleResponses = {\n    /**\n     * The mapping rule was updated successfully.\n     */\n    200: MappingRuleUpdateResult;\n};\n\nexport type UpdateMappingRuleResponse = UpdateMappingRuleResponses[keyof UpdateMappingRuleResponses];\n\nexport type SearchMappingRuleData = {\n    body?: MappingRuleSearchQueryRequest;\n    path?: never;\n    query?: never;\n    url: '/mapping-rules/search';\n};\n\nexport type SearchMappingRuleErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchMappingRuleError = SearchMappingRuleErrors[keyof SearchMappingRuleErrors];\n\nexport type SearchMappingRuleResponses = {\n    /**\n     * The mapping rule search result.\n     */\n    200: MappingRuleSearchQueryResult;\n};\n\nexport type SearchMappingRuleResponse = SearchMappingRuleResponses[keyof SearchMappingRuleResponses];\n\nexport type PublishMessageData = {\n    body: MessagePublicationRequest;\n    path?: never;\n    query?: never;\n    url: '/messages/publication';\n};\n\nexport type PublishMessageErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type PublishMessageError = PublishMessageErrors[keyof PublishMessageErrors];\n\nexport type PublishMessageResponses = {\n    /**\n     * The message was published.\n     */\n    200: MessagePublicationResult;\n};\n\nexport type PublishMessageResponse = PublishMessageResponses[keyof PublishMessageResponses];\n\nexport type CorrelateMessageData = {\n    body: MessageCorrelationRequest;\n    path?: never;\n    query?: never;\n    url: '/messages/correlation';\n};\n\nexport type CorrelateMessageErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type CorrelateMessageError = CorrelateMessageErrors[keyof CorrelateMessageErrors];\n\nexport type CorrelateMessageResponses = {\n    /**\n     * The message is correlated to one or more process instances\n     */\n    200: MessageCorrelationResult;\n};\n\nexport type CorrelateMessageResponse = CorrelateMessageResponses[keyof CorrelateMessageResponses];\n\nexport type SearchCorrelatedMessageSubscriptionsData = {\n    body?: CorrelatedMessageSubscriptionSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/correlated-message-subscriptions/search';\n};\n\nexport type SearchCorrelatedMessageSubscriptionsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchCorrelatedMessageSubscriptionsError = SearchCorrelatedMessageSubscriptionsErrors[keyof SearchCorrelatedMessageSubscriptionsErrors];\n\nexport type SearchCorrelatedMessageSubscriptionsResponses = {\n    /**\n     * The correlated message subscriptions search result.\n     */\n    200: CorrelatedMessageSubscriptionSearchQueryResult;\n};\n\nexport type SearchCorrelatedMessageSubscriptionsResponse = SearchCorrelatedMessageSubscriptionsResponses[keyof SearchCorrelatedMessageSubscriptionsResponses];\n\nexport type SearchMessageSubscriptionsData = {\n    body?: MessageSubscriptionSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/message-subscriptions/search';\n};\n\nexport type SearchMessageSubscriptionsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchMessageSubscriptionsError = SearchMessageSubscriptionsErrors[keyof SearchMessageSubscriptionsErrors];\n\nexport type SearchMessageSubscriptionsResponses = {\n    /**\n     * The message subscription search result.\n     */\n    200: MessageSubscriptionSearchQueryResult;\n};\n\nexport type SearchMessageSubscriptionsResponse = SearchMessageSubscriptionsResponses[keyof SearchMessageSubscriptionsResponses];\n\nexport type CreateDocumentData = {\n    body: {\n        file: Blob | File;\n        metadata?: DocumentMetadata;\n    };\n    path?: never;\n    query?: {\n        /**\n         * The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.\n         */\n        storeId?: string;\n        /**\n         * The ID of the document to upload. If not provided, a new ID will be generated. Specifying an existing ID will result in an error if the document already exists.\n         *\n         */\n        documentId?: string;\n    };\n    url: '/documents';\n};\n\nexport type CreateDocumentErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The server cannot process the request because the media type (Content-Type) of the request payload is not supported  by the server for the requested resource and method.\n     *\n     */\n    415: ProblemDetail;\n};\n\nexport type CreateDocumentError = CreateDocumentErrors[keyof CreateDocumentErrors];\n\nexport type CreateDocumentResponses = {\n    /**\n     * The document was uploaded successfully.\n     */\n    201: DocumentReference;\n};\n\nexport type CreateDocumentResponse = CreateDocumentResponses[keyof CreateDocumentResponses];\n\nexport type CreateDocumentsData = {\n    body: {\n        /**\n         * The documents to upload.\n         */\n        files: Array<Blob | File>;\n        /**\n         * Optional JSON array of metadata object whose index aligns with each file entry. The metadata array must have the same length as the files array.\n         *\n         */\n        metadataList?: Array<DocumentMetadata>;\n    };\n    path?: never;\n    query?: {\n        /**\n         * The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.\n         */\n        storeId?: string;\n    };\n    url: '/documents/batch';\n};\n\nexport type CreateDocumentsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The server cannot process the request because the media type (Content-Type) of the request payload is not supported  by the server for the requested resource and method.\n     *\n     */\n    415: ProblemDetail;\n};\n\nexport type CreateDocumentsError = CreateDocumentsErrors[keyof CreateDocumentsErrors];\n\nexport type CreateDocumentsResponses = {\n    /**\n     * All documents were uploaded successfully.\n     */\n    201: DocumentCreationBatchResponse;\n    /**\n     * Not all documents were uploaded successfully. More details are provided in the response body.\n     *\n     */\n    207: DocumentCreationBatchResponse;\n};\n\nexport type CreateDocumentsResponse = CreateDocumentsResponses[keyof CreateDocumentsResponses];\n\nexport type DeleteDocumentData = {\n    body?: never;\n    path: {\n        /**\n         * The ID of the document to delete.\n         */\n        documentId: DocumentId;\n    };\n    query?: {\n        /**\n         * The ID of the document store to delete the document from.\n         */\n        storeId?: string;\n    };\n    url: '/documents/{documentId}';\n};\n\nexport type DeleteDocumentErrors = {\n    /**\n     * The document with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type DeleteDocumentError = DeleteDocumentErrors[keyof DeleteDocumentErrors];\n\nexport type DeleteDocumentResponses = {\n    /**\n     * The document was deleted successfully.\n     */\n    204: void;\n};\n\nexport type DeleteDocumentResponse = DeleteDocumentResponses[keyof DeleteDocumentResponses];\n\nexport type GetDocumentData = {\n    body?: never;\n    path: {\n        /**\n         * The ID of the document to download.\n         */\n        documentId: DocumentId;\n    };\n    query: {\n        /**\n         * The ID of the document store to download the document from.\n         */\n        storeId?: string;\n        /**\n         * The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.\n         *\n         */\n        contentHash: string;\n    };\n    url: '/documents/{documentId}';\n};\n\nexport type GetDocumentErrors = {\n    /**\n     * The document with the given ID was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetDocumentError = GetDocumentErrors[keyof GetDocumentErrors];\n\nexport type GetDocumentResponses = {\n    /**\n     * The document was downloaded successfully.\n     */\n    200: Blob | File;\n};\n\nexport type GetDocumentResponse = GetDocumentResponses[keyof GetDocumentResponses];\n\nexport type CreateDocumentLinkData = {\n    body?: DocumentLinkRequest;\n    path: {\n        /**\n         * The ID of the document to link.\n         */\n        documentId: DocumentId;\n    };\n    query: {\n        /**\n         * The ID of the document store to link the document from.\n         */\n        storeId?: string;\n        /**\n         * The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.\n         *\n         */\n        contentHash: string;\n    };\n    url: '/documents/{documentId}/links';\n};\n\nexport type CreateDocumentLinkErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n};\n\nexport type CreateDocumentLinkError = CreateDocumentLinkErrors[keyof CreateDocumentLinkErrors];\n\nexport type CreateDocumentLinkResponses = {\n    /**\n     * The document link was created successfully.\n     */\n    201: DocumentLink;\n};\n\nexport type CreateDocumentLinkResponse = CreateDocumentLinkResponses[keyof CreateDocumentLinkResponses];\n\nexport type CreateUserData = {\n    body: UserRequest;\n    path?: never;\n    query?: never;\n    url: '/users';\n};\n\nexport type CreateUserErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * A user with the given username already exists.\n     *\n     */\n    409: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type CreateUserError = CreateUserErrors[keyof CreateUserErrors];\n\nexport type CreateUserResponses = {\n    /**\n     * The user was created successfully.\n     *\n     */\n    201: UserCreateResult;\n};\n\nexport type CreateUserResponse = CreateUserResponses[keyof CreateUserResponses];\n\nexport type SearchUsersData = {\n    body?: UserSearchQueryRequest;\n    path?: never;\n    query?: never;\n    url: '/users/search';\n};\n\nexport type SearchUsersErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchUsersError = SearchUsersErrors[keyof SearchUsersErrors];\n\nexport type SearchUsersResponses = {\n    /**\n     * The user search result.\n     */\n    200: UserSearchResult;\n};\n\nexport type SearchUsersResponse = SearchUsersResponses[keyof SearchUsersResponses];\n\nexport type DeleteUserData = {\n    body?: never;\n    path: {\n        /**\n         * The username of the user to delete.\n         */\n        username: Username;\n    };\n    query?: never;\n    url: '/users/{username}';\n};\n\nexport type DeleteUserErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The user is not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type DeleteUserError = DeleteUserErrors[keyof DeleteUserErrors];\n\nexport type DeleteUserResponses = {\n    /**\n     * The user was deleted successfully.\n     */\n    204: void;\n};\n\nexport type DeleteUserResponse = DeleteUserResponses[keyof DeleteUserResponses];\n\nexport type GetUserData = {\n    body?: never;\n    path: {\n        /**\n         * The username of the user.\n         */\n        username: Username;\n    };\n    query?: never;\n    url: '/users/{username}';\n};\n\nexport type GetUserErrors = {\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The user with the given username was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetUserError = GetUserErrors[keyof GetUserErrors];\n\nexport type GetUserResponses = {\n    /**\n     * The user is successfully returned.\n     */\n    200: UserResult;\n};\n\nexport type GetUserResponse = GetUserResponses[keyof GetUserResponses];\n\nexport type UpdateUserData = {\n    body: UserUpdateRequest;\n    path: {\n        /**\n         * The username of the user to update.\n         */\n        username: Username;\n    };\n    query?: never;\n    url: '/users/{username}';\n};\n\nexport type UpdateUserErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The user was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type UpdateUserError = UpdateUserErrors[keyof UpdateUserErrors];\n\nexport type UpdateUserResponses = {\n    /**\n     * The user was updated successfully.\n     */\n    200: UserUpdateResult;\n};\n\nexport type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses];\n\nexport type CreateAdminUserData = {\n    body: UserRequest;\n    path?: never;\n    query?: never;\n    url: '/setup/user';\n};\n\nexport type CreateAdminUserErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type CreateAdminUserError = CreateAdminUserErrors[keyof CreateAdminUserErrors];\n\nexport type CreateAdminUserResponses = {\n    /**\n     * The user was created and got assigned the admin role successfully.\n     *\n     */\n    201: UserCreateResult;\n};\n\nexport type CreateAdminUserResponse = CreateAdminUserResponses[keyof CreateAdminUserResponses];\n\nexport type SearchIncidentsData = {\n    body?: IncidentSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/incidents/search';\n};\n\nexport type SearchIncidentsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchIncidentsError = SearchIncidentsErrors[keyof SearchIncidentsErrors];\n\nexport type SearchIncidentsResponses = {\n    /**\n     * The incident search result.\n     *\n     */\n    200: IncidentSearchQueryResult;\n};\n\nexport type SearchIncidentsResponse = SearchIncidentsResponses[keyof SearchIncidentsResponses];\n\nexport type GetIncidentData = {\n    body?: never;\n    path: {\n        /**\n         * The assigned key of the incident, which acts as a unique identifier for this incident.\n         */\n        incidentKey: IncidentKey;\n    };\n    query?: never;\n    url: '/incidents/{incidentKey}';\n};\n\nexport type GetIncidentErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The incident with the given key was not found. More details are provided in the response body.\n     *\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetIncidentError = GetIncidentErrors[keyof GetIncidentErrors];\n\nexport type GetIncidentResponses = {\n    /**\n     * The incident is successfully returned.\n     */\n    200: IncidentResult;\n};\n\nexport type GetIncidentResponse = GetIncidentResponses[keyof GetIncidentResponses];\n\nexport type GetUsageMetricsData = {\n    body?: never;\n    path?: never;\n    query: {\n        /**\n         * The start date for usage metrics, including this date. Value in ISO 8601 format.\n         */\n        startTime: string;\n        /**\n         * The end date for usage metrics, including this date. Value in ISO 8601 format.\n         */\n        endTime: string;\n        /**\n         * Restrict results to a specific tenant ID. If not provided, results for all tenants are returned.\n         */\n        tenantId?: TenantId;\n        /**\n         * Whether to return tenant metrics in addition to the total metrics or not. Default false.\n         */\n        withTenants?: boolean;\n    };\n    url: '/system/usage-metrics';\n};\n\nexport type GetUsageMetricsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetUsageMetricsError = GetUsageMetricsErrors[keyof GetUsageMetricsErrors];\n\nexport type GetUsageMetricsResponses = {\n    /**\n     * The usage metrics search result.\n     */\n    200: UsageMetricsResponse;\n};\n\nexport type GetUsageMetricsResponse = GetUsageMetricsResponses[keyof GetUsageMetricsResponses];\n\nexport type CreateDeploymentData = {\n    body: {\n        /**\n         * The binary data to create the deployment resources. It is possible to have more than one form part with different form part names for the binary data to create a deployment.\n         *\n         */\n        resources: Array<Blob | File>;\n        /**\n         * The tenant to deploy the resources to.\n         */\n        tenantId?: string;\n    };\n    path?: never;\n    query?: never;\n    url: '/deployments';\n};\n\nexport type CreateDeploymentErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type CreateDeploymentError = CreateDeploymentErrors[keyof CreateDeploymentErrors];\n\nexport type CreateDeploymentResponses = {\n    /**\n     * The resources are deployed.\n     */\n    200: DeploymentResult;\n};\n\nexport type CreateDeploymentResponse = CreateDeploymentResponses[keyof CreateDeploymentResponses];\n\nexport type DeleteResourceData = {\n    body?: DeleteResourceRequest;\n    path: {\n        /**\n         * The key of the resource to delete.\n         * This can be the key of a process definition, the key of a decision requirements\n         * definition or the key of a form definition\n         *\n         */\n        resourceKey: ResourceKey;\n    };\n    query?: never;\n    url: '/resources/{resourceKey}/deletion';\n};\n\nexport type DeleteResourceErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The resource is not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type DeleteResourceError = DeleteResourceErrors[keyof DeleteResourceErrors];\n\nexport type DeleteResourceResponses = {\n    /**\n     * The resource is deleted.\n     */\n    200: unknown;\n};\n\nexport type GetResourceData = {\n    body?: never;\n    path: {\n        /**\n         * The unique key identifying the resource.\n         */\n        resourceKey: ResourceKey;\n    };\n    query?: never;\n    url: '/resources/{resourceKey}';\n};\n\nexport type GetResourceErrors = {\n    /**\n     * A resource with the given key was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetResourceError = GetResourceErrors[keyof GetResourceErrors];\n\nexport type GetResourceResponses = {\n    /**\n     * The resource is successfully returned.\n     */\n    200: ResourceResult;\n};\n\nexport type GetResourceResponse = GetResourceResponses[keyof GetResourceResponses];\n\nexport type GetResourceContentData = {\n    body?: never;\n    path: {\n        /**\n         * The unique key identifying the resource.\n         */\n        resourceKey: ResourceKey;\n    };\n    query?: never;\n    url: '/resources/{resourceKey}/content';\n};\n\nexport type GetResourceContentErrors = {\n    /**\n     * A resource with the given key was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetResourceContentError = GetResourceContentErrors[keyof GetResourceContentErrors];\n\nexport type GetResourceContentResponses = {\n    /**\n     * The resource content is successfully returned.\n     */\n    200: string;\n};\n\nexport type GetResourceContentResponse = GetResourceContentResponses[keyof GetResourceContentResponses];\n\nexport type CreateElementInstanceVariablesData = {\n    body: SetVariableRequest;\n    path: {\n        /**\n         * The key of the element instance to update the variables for.\n         * This can be the process instance key (as obtained during instance creation), or a given\n         * element, such as a service task (see the `elementInstanceKey` on the job message).\n         *\n         */\n        elementInstanceKey: ElementInstanceKey;\n    };\n    query?: never;\n    url: '/element-instances/{elementInstanceKey}/variables';\n};\n\nexport type CreateElementInstanceVariablesErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type CreateElementInstanceVariablesError = CreateElementInstanceVariablesErrors[keyof CreateElementInstanceVariablesErrors];\n\nexport type CreateElementInstanceVariablesResponses = {\n    /**\n     * The variables were updated.\n     */\n    204: void;\n};\n\nexport type CreateElementInstanceVariablesResponse = CreateElementInstanceVariablesResponses[keyof CreateElementInstanceVariablesResponses];\n\nexport type ActivateAdHocSubProcessActivitiesData = {\n    body: AdHocSubProcessActivateActivitiesInstruction;\n    path: {\n        /**\n         * The key of the ad-hoc sub-process instance that contains the activities.\n         */\n        adHocSubProcessInstanceKey: ElementInstanceKey;\n    };\n    query?: never;\n    url: '/element-instances/ad-hoc-activities/{adHocSubProcessInstanceKey}/activation';\n};\n\nexport type ActivateAdHocSubProcessActivitiesErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The request lacks valid authentication credentials.\n     */\n    401: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * The ad-hoc sub-process instance is not found or the provided key does not identify an\n     * ad-hoc sub-process.\n     *\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type ActivateAdHocSubProcessActivitiesError = ActivateAdHocSubProcessActivitiesErrors[keyof ActivateAdHocSubProcessActivitiesErrors];\n\nexport type ActivateAdHocSubProcessActivitiesResponses = {\n    /**\n     * The ad-hoc sub-process instance is modified.\n     */\n    204: void;\n};\n\nexport type ActivateAdHocSubProcessActivitiesResponse = ActivateAdHocSubProcessActivitiesResponses[keyof ActivateAdHocSubProcessActivitiesResponses];\n\nexport type BroadcastSignalData = {\n    body: SignalBroadcastRequest;\n    path?: never;\n    query?: never;\n    url: '/signals/broadcast';\n};\n\nexport type BroadcastSignalErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The signal is not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type BroadcastSignalError = BroadcastSignalErrors[keyof BroadcastSignalErrors];\n\nexport type BroadcastSignalResponses = {\n    /**\n     * The signal was broadcast.\n     */\n    200: SignalBroadcastResult;\n};\n\nexport type BroadcastSignalResponse = BroadcastSignalResponses[keyof BroadcastSignalResponses];\n\nexport type GetBatchOperationData = {\n    body?: never;\n    path: {\n        /**\n         * The key (or operate legacy ID) of the batch operation.\n         *\n         */\n        batchOperationKey: BatchOperationKey;\n    };\n    query?: never;\n    url: '/batch-operations/{batchOperationKey}';\n};\n\nexport type GetBatchOperationErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * The batch operation is not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type GetBatchOperationError = GetBatchOperationErrors[keyof GetBatchOperationErrors];\n\nexport type GetBatchOperationResponses = {\n    /**\n     * The batch operation was found.\n     */\n    200: BatchOperationResponse;\n};\n\nexport type GetBatchOperationResponse = GetBatchOperationResponses[keyof GetBatchOperationResponses];\n\nexport type SearchBatchOperationsData = {\n    body?: BatchOperationSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/batch-operations/search';\n};\n\nexport type SearchBatchOperationsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchBatchOperationsError = SearchBatchOperationsErrors[keyof SearchBatchOperationsErrors];\n\nexport type SearchBatchOperationsResponses = {\n    /**\n     * The batch operation search result.\n     */\n    200: BatchOperationSearchQueryResult;\n};\n\nexport type SearchBatchOperationsResponse = SearchBatchOperationsResponses[keyof SearchBatchOperationsResponses];\n\nexport type CancelBatchOperationData = {\n    body?: unknown;\n    path: {\n        /**\n         * The key (or operate legacy ID) of the batch operation.\n         *\n         */\n        batchOperationKey: BatchOperationKey;\n    };\n    query?: never;\n    url: '/batch-operations/{batchOperationKey}/cancellation';\n};\n\nexport type CancelBatchOperationErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The batch operation was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type CancelBatchOperationError = CancelBatchOperationErrors[keyof CancelBatchOperationErrors];\n\nexport type CancelBatchOperationResponses = {\n    /**\n     * The batch operation cancel request was created.\n     */\n    204: void;\n};\n\nexport type CancelBatchOperationResponse = CancelBatchOperationResponses[keyof CancelBatchOperationResponses];\n\nexport type SuspendBatchOperationData = {\n    body?: unknown;\n    path: {\n        /**\n         * The key (or operate legacy ID) of the batch operation.\n         *\n         */\n        batchOperationKey: BatchOperationKey;\n    };\n    query?: never;\n    url: '/batch-operations/{batchOperationKey}/suspension';\n};\n\nexport type SuspendBatchOperationErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The batch operation was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type SuspendBatchOperationError = SuspendBatchOperationErrors[keyof SuspendBatchOperationErrors];\n\nexport type SuspendBatchOperationResponses = {\n    /**\n     * The batch operation pause request was created.\n     */\n    204: void;\n};\n\nexport type SuspendBatchOperationResponse = SuspendBatchOperationResponses[keyof SuspendBatchOperationResponses];\n\nexport type ResumeBatchOperationData = {\n    body?: unknown;\n    path: {\n        /**\n         * The key (or operate legacy ID) of the batch operation.\n         *\n         */\n        batchOperationKey: BatchOperationKey;\n    };\n    query?: never;\n    url: '/batch-operations/{batchOperationKey}/resumption';\n};\n\nexport type ResumeBatchOperationErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * Forbidden. The request is not allowed.\n     */\n    403: ProblemDetail;\n    /**\n     * Not found. The batch operation was not found.\n     */\n    404: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n    /**\n     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .\n     *\n     */\n    503: ProblemDetail;\n};\n\nexport type ResumeBatchOperationError = ResumeBatchOperationErrors[keyof ResumeBatchOperationErrors];\n\nexport type ResumeBatchOperationResponses = {\n    /**\n     * The batch operation resume request was created.\n     */\n    204: void;\n};\n\nexport type ResumeBatchOperationResponse = ResumeBatchOperationResponses[keyof ResumeBatchOperationResponses];\n\nexport type SearchBatchOperationItemsData = {\n    body?: BatchOperationItemSearchQuery;\n    path?: never;\n    query?: never;\n    url: '/batch-operation-items/search';\n};\n\nexport type SearchBatchOperationItemsErrors = {\n    /**\n     * The provided data is not valid.\n     */\n    400: ProblemDetail;\n    /**\n     * An internal error occurred while processing the request.\n     *\n     */\n    500: ProblemDetail;\n};\n\nexport type SearchBatchOperationItemsError = SearchBatchOperationItemsErrors[keyof SearchBatchOperationItemsErrors];\n\nexport type SearchBatchOperationItemsResponses = {\n    /**\n     * The batch operation search result.\n     */\n    200: BatchOperationItemSearchQueryResult;\n};\n\nexport type SearchBatchOperationItemsResponse = SearchBatchOperationItemsResponses[keyof SearchBatchOperationItemsResponses];\n\nexport type ClientOptions = {\n    baseUrl: '{schema}://{host}:{port}/v2' | (string & {});\n};\n\n// branding-plugin generated\n// schemaVersion=1.0.0\n// specHash=sha256:c6c3f5f4c9c24b7b7d6873e31f72d83db79418de81dc00f09a21843b4ce0d507\n\nexport function assertConstraint(value: string, label: string, c: { pattern?: string; minLength?: number; maxLength?: number }) {\n  if (c.pattern && !(new RegExp(c.pattern).test(value))) throw new Error(`\u001b[31mInvalid pattern for ${label}: '${value}'.\u001b[0m Needs to match: ${JSON.stringify(c)}\n`);\n  if (typeof c.minLength === \"number\" && value.length < c.minLength) throw new Error(`Value too short for ${label}`);\n  if (typeof c.maxLength === \"number\" && value.length > c.maxLength) throw new Error(`Value too long for ${label}`);\n}\n// System-generated key for an authorization.\nexport namespace AuthorizationKey {\n  export function assumeExists(value: string): AuthorizationKey {\n    assertConstraint(value, 'AuthorizationKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: AuthorizationKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'AuthorizationKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for an batch operation.\nexport namespace BatchOperationKey {\n  export function assumeExists(value: string): BatchOperationKey {\n    return value as any;\n  }\n  export function getValue(key: BatchOperationKey): string { return key; }\n  export function isValid(value: string): boolean {\n    return true;\n  }\n}\n// Id of a decision definition, from the model. Only ids of decision definitions that are deployed are useful.\nexport namespace DecisionDefinitionId {\n  export function assumeExists(value: string): DecisionDefinitionId {\n    assertConstraint(value, 'DecisionDefinitionId', { pattern: \"^[A-Za-z0-9_@.+-]+$\", minLength: 1, maxLength: 256 });\n    return value as any;\n  }\n  export function getValue(key: DecisionDefinitionId): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'DecisionDefinitionId', { pattern: \"^[A-Za-z0-9_@.+-]+$\", minLength: 1, maxLength: 256 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a decision definition.\nexport namespace DecisionDefinitionKey {\n  export function assumeExists(value: string): DecisionDefinitionKey {\n    assertConstraint(value, 'DecisionDefinitionKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: DecisionDefinitionKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'DecisionDefinitionKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a decision evaluation instance.\nexport namespace DecisionEvaluationInstanceKey {\n  export function assumeExists(value: string): DecisionEvaluationInstanceKey {\n    assertConstraint(value, 'DecisionEvaluationInstanceKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: DecisionEvaluationInstanceKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'DecisionEvaluationInstanceKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a decision evaluation.\nexport namespace DecisionEvaluationKey {\n  export function assumeExists(value: string): DecisionEvaluationKey {\n    assertConstraint(value, 'DecisionEvaluationKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: DecisionEvaluationKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'DecisionEvaluationKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a deployed decision instance.\nexport namespace DecisionInstanceKey {\n  export function assumeExists(value: string): DecisionInstanceKey {\n    assertConstraint(value, 'DecisionInstanceKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: DecisionInstanceKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'DecisionInstanceKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a deployed decision requirements definition.\nexport namespace DecisionRequirementsKey {\n  export function assumeExists(value: string): DecisionRequirementsKey {\n    assertConstraint(value, 'DecisionRequirementsKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: DecisionRequirementsKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'DecisionRequirementsKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// Key for a deployment.\nexport namespace DeploymentKey {\n  export function assumeExists(value: string): DeploymentKey {\n    assertConstraint(value, 'DeploymentKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: DeploymentKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'DeploymentKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// Document Id that uniquely identifies a document.\nexport namespace DocumentId {\n  export function assumeExists(value: string): DocumentId {\n    return value as any;\n  }\n  export function getValue(key: DocumentId): string { return key; }\n  export function isValid(value: string): boolean {\n    return true;\n  }\n}\n// The model-defined id of an element.\nexport namespace ElementId {\n  export function assumeExists(value: string): ElementId {\n    return value as any;\n  }\n  export function getValue(key: ElementId): string { return key; }\n  export function isValid(value: string): boolean {\n    return true;\n  }\n}\n// System-generated key for a element instance.\nexport namespace ElementInstanceKey {\n  export function assumeExists(value: string): ElementInstanceKey {\n    assertConstraint(value, 'ElementInstanceKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: ElementInstanceKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'ElementInstanceKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// The end cursor in a search query result set.\nexport namespace EndCursor {\n  export function assumeExists(value: string): EndCursor {\n    assertConstraint(value, 'EndCursor', { pattern: \"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$\", minLength: 2, maxLength: 300 });\n    return value as any;\n  }\n  export function getValue(key: EndCursor): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'EndCursor', { pattern: \"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$\", minLength: 2, maxLength: 300 });\n      return true;\n    } catch { return false; }\n  }\n}\n// The user-defined id for the form\nexport namespace FormId {\n  export function assumeExists(value: string): FormId {\n    return value as any;\n  }\n  export function getValue(key: FormId): string { return key; }\n  export function isValid(value: string): boolean {\n    return true;\n  }\n}\n// System-generated key for a deployed form.\nexport namespace FormKey {\n  export function assumeExists(value: string): FormKey {\n    assertConstraint(value, 'FormKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: FormKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'FormKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a incident.\nexport namespace IncidentKey {\n  export function assumeExists(value: string): IncidentKey {\n    assertConstraint(value, 'IncidentKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: IncidentKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'IncidentKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a job.\nexport namespace JobKey {\n  export function assumeExists(value: string): JobKey {\n    assertConstraint(value, 'JobKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: JobKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'JobKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a message correlation.\nexport namespace MessageCorrelationKey {\n  export function assumeExists(value: string): MessageCorrelationKey {\n    assertConstraint(value, 'MessageCorrelationKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: MessageCorrelationKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'MessageCorrelationKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for an message.\nexport namespace MessageKey {\n  export function assumeExists(value: string): MessageKey {\n    assertConstraint(value, 'MessageKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: MessageKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'MessageKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a message subscription.\nexport namespace MessageSubscriptionKey {\n  export function assumeExists(value: string): MessageSubscriptionKey {\n    assertConstraint(value, 'MessageSubscriptionKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: MessageSubscriptionKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'MessageSubscriptionKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.\nexport namespace ProcessDefinitionId {\n  export function assumeExists(value: string): ProcessDefinitionId {\n    assertConstraint(value, 'ProcessDefinitionId', { pattern: \"^[a-zA-Z_][a-zA-Z0-9_\\\\-\\\\.]*$\", minLength: 1 });\n    return value as any;\n  }\n  export function getValue(key: ProcessDefinitionId): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'ProcessDefinitionId', { pattern: \"^[a-zA-Z_][a-zA-Z0-9_\\\\-\\\\.]*$\", minLength: 1 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a deployed process definition.\nexport namespace ProcessDefinitionKey {\n  export function assumeExists(value: string): ProcessDefinitionKey {\n    assertConstraint(value, 'ProcessDefinitionKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: ProcessDefinitionKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'ProcessDefinitionKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a process instance.\nexport namespace ProcessInstanceKey {\n  export function assumeExists(value: string): ProcessInstanceKey {\n    assertConstraint(value, 'ProcessInstanceKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: ProcessInstanceKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'ProcessInstanceKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a scope.\nexport namespace ScopeKey {\n  export function assumeExists(value: string): ScopeKey {\n    assertConstraint(value, 'ScopeKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: ScopeKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'ScopeKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for an signal.\nexport namespace SignalKey {\n  export function assumeExists(value: string): SignalKey {\n    assertConstraint(value, 'SignalKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: SignalKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'SignalKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// The start cursor in a search query result set.\nexport namespace StartCursor {\n  export function assumeExists(value: string): StartCursor {\n    assertConstraint(value, 'StartCursor', { pattern: \"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$\", minLength: 2, maxLength: 300 });\n    return value as any;\n  }\n  export function getValue(key: StartCursor): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'StartCursor', { pattern: \"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$\", minLength: 2, maxLength: 300 });\n      return true;\n    } catch { return false; }\n  }\n}\n// A tag. Needs to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length ≤ 100.\nexport namespace Tag {\n  export function fromString(value: string): Tag {\n    assertConstraint(value, 'Tag', { pattern: \"^[A-Za-z][A-Za-z0-9_\\\\-:.]{0,99}$\", minLength: 1, maxLength: 100 });\n    return value as any;\n  }\n  export function getValue(key: Tag): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'Tag', { pattern: \"^[A-Za-z][A-Za-z0-9_\\\\-:.]{0,99}$\", minLength: 1, maxLength: 100 });\n      return true;\n    } catch { return false; }\n  }\n}\n// The unique identifier of the tenant.\nexport namespace TenantId {\n  export function assumeExists(value: string): TenantId {\n    assertConstraint(value, 'TenantId', { pattern: \"^(<default>|[A-Za-z0-9_@.+-]+)$\", minLength: 1, maxLength: 256 });\n    return value as any;\n  }\n  export function getValue(key: TenantId): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'TenantId', { pattern: \"^(<default>|[A-Za-z0-9_@.+-]+)$\", minLength: 1, maxLength: 256 });\n      return true;\n    } catch { return false; }\n  }\n}\n// The unique name of a user.\nexport namespace Username {\n  export function assumeExists(value: string): Username {\n    assertConstraint(value, 'Username', { pattern: \"^(<default>|[A-Za-z0-9_@.+-]+)$\", minLength: 1, maxLength: 256 });\n    return value as any;\n  }\n  export function getValue(key: Username): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'Username', { pattern: \"^(<default>|[A-Za-z0-9_@.+-]+)$\", minLength: 1, maxLength: 256 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a user task.\nexport namespace UserTaskKey {\n  export function assumeExists(value: string): UserTaskKey {\n    assertConstraint(value, 'UserTaskKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: UserTaskKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'UserTaskKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}\n// System-generated key for a variable.\nexport namespace VariableKey {\n  export function assumeExists(value: string): VariableKey {\n    assertConstraint(value, 'VariableKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n    return value as any;\n  }\n  export function getValue(key: VariableKey): string { return key; }\n  export function isValid(value: string): boolean {\n    try {\n      assertConstraint(value, 'VariableKey', { pattern: \"^-?[0-9]+$\", minLength: 1, maxLength: 25 });\n      return true;\n    } catch { return false; }\n  }\n}","// Entry point: export Camunda class, key types, and errors.\nimport { createCamundaClient, CamundaClient } from './gen/CamundaClient';\nimport { createCamundaClientLoose, type CamundaClientLoose, type Loose } from './loose';\n// Public re-exports for worker API\nexport type { JobWorkerConfig, JobWorker, Job, JobActionReceipt } from './runtime/jobWorker';\nexport { JobActionReceipt as JobActionReceiptSymbol } from './runtime/jobWorker';\n\nexport {\n  createCamundaResultClient,\n  type CamundaResultClient,\n  type Result,\n  isOk,\n  isErr,\n} from './resultClient';\nexport { createCamundaFpClient, type CamundaFpClient, type Either, isLeft, isRight } from './fp-ts';\nexport * from './gen/types.gen';\nexport { CamundaValidationError, EventualConsistencyTimeoutError } from './runtime/errors';\n// eventualPoll unified with result mode; no separate export\nexport {\n  createCamundaClient,\n  createCamundaClientLoose,\n  type CamundaClientLoose,\n  type Loose,\n  CamundaClient,\n};\n// Public type for client construction options\nexport type { CamundaOptions } from './gen/CamundaClient';\nexport type { EnrichedActivatedJob } from './runtime/jobActions';\nexport default createCamundaClient;\n"],"mappings":";;;;;;;;;;;;;AA0CO,SAAS,4BACX,MAC4C;AAC/C,QAAM,SAAS,oBAAoB,GAAG,IAAI;AAC1C,SAAO;AACT;;;AC3CO,IAAM,OAAO,CAAO,MAAiD,EAAE;AACvE,IAAM,QAAQ,CAAO,MAAkD,CAAC,EAAE;AAGjF,SAAS,UAAU,GAA+B;AAChD,SAAO,KAAK,OAAO,EAAE,SAAS;AAChC;AAQO,SAAS,0BAA0B,SAA0B;AAClE,QAAM,OAAO,oBAAoB,OAAO;AAExC,QAAM,UAA6B;AAAA,IACjC,IAAI,SAAS,MAAM,OAAO;AACxB,UAAI,SAAS,QAAS,QAAO;AAC7B,YAAM,QAAS,KAAa,IAAI;AAChC,UAAI,OAAO,UAAU,WAAY,QAAO;AACxC,aAAO,IAAI,SAAgB;AACzB,YAAI;AACF,gBAAM,MAAM,MAAM,MAAM,MAAM,IAAI;AAClC,cAAI,UAAU,GAAG,GAAG;AAClB,mBAAO,IACJ,KAAK,CAAC,OAAY,EAAE,IAAI,MAAM,OAAO,EAAE,EAAW,EAClD,MAAM,CAAC,OAAgB,EAAE,IAAI,OAAO,OAAO,EAAE,EAAW;AAAA,UAC7D;AACA,iBAAO,QAAQ,QAAQ,EAAE,IAAI,MAAM,OAAO,IAAI,CAAU;AAAA,QAC1D,SAAS,GAAG;AACV,iBAAO,QAAQ,QAAQ,EAAE,IAAI,OAAO,OAAO,EAAE,CAAU;AAAA,QACzD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO,IAAI,MAAM,CAAC,GAAG,OAAO;AAC9B;;;AC2vXO,SAAS,iBAAiB,OAAe,OAAe,GAAiE;AAC9H,MAAI,EAAE,WAAW,CAAE,IAAI,OAAO,EAAE,OAAO,EAAE,KAAK,KAAK,EAAI,OAAM,IAAI,MAAM,+BAA4B,KAAK,MAAM,KAAK,6BAA0B,KAAK,UAAU,CAAC,CAAC;AAAA,CAC/J;AACC,MAAI,OAAO,EAAE,cAAc,YAAY,MAAM,SAAS,EAAE,UAAW,OAAM,IAAI,MAAM,uBAAuB,KAAK,EAAE;AACjH,MAAI,OAAO,EAAE,cAAc,YAAY,MAAM,SAAS,EAAE,UAAW,OAAM,IAAI,MAAM,sBAAsB,KAAK,EAAE;AAClH;AAEO,IAAU;AAAA,CAAV,CAAUA,sBAAV;AACE,WAAS,aAAa,OAAiC;AAC5D,qBAAiB,OAAO,oBAAoB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAClG,WAAO;AAAA,EACT;AAHO,EAAAA,kBAAS;AAIT,WAAS,SAAS,KAA+B;AAAE,WAAO;AAAA,EAAK;AAA/D,EAAAA,kBAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,oBAAoB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAClG,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,kBAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,uBAAV;AACE,WAAS,aAAa,OAAkC;AAC7D,WAAO;AAAA,EACT;AAFO,EAAAA,mBAAS;AAGT,WAAS,SAAS,KAAgC;AAAE,WAAO;AAAA,EAAK;AAAhE,EAAAA,mBAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,WAAO;AAAA,EACT;AAFO,EAAAA,mBAAS;AAAA,GALD;AAUV,IAAU;AAAA,CAAV,CAAUC,0BAAV;AACE,WAAS,aAAa,OAAqC;AAChE,qBAAiB,OAAO,wBAAwB,EAAE,SAAS,uBAAuB,WAAW,GAAG,WAAW,IAAI,CAAC;AAChH,WAAO;AAAA,EACT;AAHO,EAAAA,sBAAS;AAIT,WAAS,SAAS,KAAmC;AAAE,WAAO;AAAA,EAAK;AAAnE,EAAAA,sBAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,wBAAwB,EAAE,SAAS,uBAAuB,WAAW,GAAG,WAAW,IAAI,CAAC;AAChH,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,sBAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,2BAAV;AACE,WAAS,aAAa,OAAsC;AACjE,qBAAiB,OAAO,yBAAyB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACvG,WAAO;AAAA,EACT;AAHO,EAAAA,uBAAS;AAIT,WAAS,SAAS,KAAoC;AAAE,WAAO;AAAA,EAAK;AAApE,EAAAA,uBAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,yBAAyB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACvG,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,uBAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,mCAAV;AACE,WAAS,aAAa,OAA8C;AACzE,qBAAiB,OAAO,iCAAiC,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC/G,WAAO;AAAA,EACT;AAHO,EAAAA,+BAAS;AAIT,WAAS,SAAS,KAA4C;AAAE,WAAO;AAAA,EAAK;AAA5E,EAAAA,+BAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,iCAAiC,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC/G,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,+BAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,2BAAV;AACE,WAAS,aAAa,OAAsC;AACjE,qBAAiB,OAAO,yBAAyB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACvG,WAAO;AAAA,EACT;AAHO,EAAAA,uBAAS;AAIT,WAAS,SAAS,KAAoC;AAAE,WAAO;AAAA,EAAK;AAApE,EAAAA,uBAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,yBAAyB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACvG,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,uBAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,yBAAV;AACE,WAAS,aAAa,OAAoC;AAC/D,qBAAiB,OAAO,uBAAuB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACrG,WAAO;AAAA,EACT;AAHO,EAAAA,qBAAS;AAIT,WAAS,SAAS,KAAkC;AAAE,WAAO;AAAA,EAAK;AAAlE,EAAAA,qBAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,uBAAuB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACrG,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,qBAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,6BAAV;AACE,WAAS,aAAa,OAAwC;AACnE,qBAAiB,OAAO,2BAA2B,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACzG,WAAO;AAAA,EACT;AAHO,EAAAA,yBAAS;AAIT,WAAS,SAAS,KAAsC;AAAE,WAAO;AAAA,EAAK;AAAtE,EAAAA,yBAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,2BAA2B,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACzG,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,yBAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,mBAAV;AACE,WAAS,aAAa,OAA8B;AACzD,qBAAiB,OAAO,iBAAiB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC/F,WAAO;AAAA,EACT;AAHO,EAAAA,eAAS;AAIT,WAAS,SAAS,KAA4B;AAAE,WAAO;AAAA,EAAK;AAA5D,EAAAA,eAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,iBAAiB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC/F,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,eAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,gBAAV;AACE,WAAS,aAAa,OAA2B;AACtD,WAAO;AAAA,EACT;AAFO,EAAAA,YAAS;AAGT,WAAS,SAAS,KAAyB;AAAE,WAAO;AAAA,EAAK;AAAzD,EAAAA,YAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,WAAO;AAAA,EACT;AAFO,EAAAA,YAAS;AAAA,GALD;AAUV,IAAU;AAAA,CAAV,CAAUC,eAAV;AACE,WAAS,aAAa,OAA0B;AACrD,WAAO;AAAA,EACT;AAFO,EAAAA,WAAS;AAGT,WAAS,SAAS,KAAwB;AAAE,WAAO;AAAA,EAAK;AAAxD,EAAAA,WAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,WAAO;AAAA,EACT;AAFO,EAAAA,WAAS;AAAA,GALD;AAUV,IAAU;AAAA,CAAV,CAAUC,wBAAV;AACE,WAAS,aAAa,OAAmC;AAC9D,qBAAiB,OAAO,sBAAsB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACpG,WAAO;AAAA,EACT;AAHO,EAAAA,oBAAS;AAIT,WAAS,SAAS,KAAiC;AAAE,WAAO;AAAA,EAAK;AAAjE,EAAAA,oBAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,sBAAsB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACpG,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,oBAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,eAAV;AACE,WAAS,aAAa,OAA0B;AACrD,qBAAiB,OAAO,aAAa,EAAE,SAAS,yEAAyE,WAAW,GAAG,WAAW,IAAI,CAAC;AACvJ,WAAO;AAAA,EACT;AAHO,EAAAA,WAAS;AAIT,WAAS,SAAS,KAAwB;AAAE,WAAO;AAAA,EAAK;AAAxD,EAAAA,WAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,aAAa,EAAE,SAAS,yEAAyE,WAAW,GAAG,WAAW,IAAI,CAAC;AACvJ,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,WAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,YAAV;AACE,WAAS,aAAa,OAAuB;AAClD,WAAO;AAAA,EACT;AAFO,EAAAA,QAAS;AAGT,WAAS,SAAS,KAAqB;AAAE,WAAO;AAAA,EAAK;AAArD,EAAAA,QAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,WAAO;AAAA,EACT;AAFO,EAAAA,QAAS;AAAA,GALD;AAUV,IAAU;AAAA,CAAV,CAAUC,aAAV;AACE,WAAS,aAAa,OAAwB;AACnD,qBAAiB,OAAO,WAAW,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACzF,WAAO;AAAA,EACT;AAHO,EAAAA,SAAS;AAIT,WAAS,SAAS,KAAsB;AAAE,WAAO;AAAA,EAAK;AAAtD,EAAAA,SAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,WAAW,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACzF,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,SAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,iBAAV;AACE,WAAS,aAAa,OAA4B;AACvD,qBAAiB,OAAO,eAAe,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC7F,WAAO;AAAA,EACT;AAHO,EAAAA,aAAS;AAIT,WAAS,SAAS,KAA0B;AAAE,WAAO;AAAA,EAAK;AAA1D,EAAAA,aAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,eAAe,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC7F,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,aAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,YAAV;AACE,WAAS,aAAa,OAAuB;AAClD,qBAAiB,OAAO,UAAU,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACxF,WAAO;AAAA,EACT;AAHO,EAAAA,QAAS;AAIT,WAAS,SAAS,KAAqB;AAAE,WAAO;AAAA,EAAK;AAArD,EAAAA,QAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,UAAU,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACxF,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,QAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,2BAAV;AACE,WAAS,aAAa,OAAsC;AACjE,qBAAiB,OAAO,yBAAyB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACvG,WAAO;AAAA,EACT;AAHO,EAAAA,uBAAS;AAIT,WAAS,SAAS,KAAoC;AAAE,WAAO;AAAA,EAAK;AAApE,EAAAA,uBAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,yBAAyB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACvG,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,uBAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,gBAAV;AACE,WAAS,aAAa,OAA2B;AACtD,qBAAiB,OAAO,cAAc,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC5F,WAAO;AAAA,EACT;AAHO,EAAAA,YAAS;AAIT,WAAS,SAAS,KAAyB;AAAE,WAAO;AAAA,EAAK;AAAzD,EAAAA,YAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,cAAc,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC5F,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,YAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,4BAAV;AACE,WAAS,aAAa,OAAuC;AAClE,qBAAiB,OAAO,0BAA0B,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACxG,WAAO;AAAA,EACT;AAHO,EAAAA,wBAAS;AAIT,WAAS,SAAS,KAAqC;AAAE,WAAO;AAAA,EAAK;AAArE,EAAAA,wBAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,0BAA0B,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACxG,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,wBAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,yBAAV;AACE,WAAS,aAAa,OAAoC;AAC/D,qBAAiB,OAAO,uBAAuB,EAAE,SAAS,kCAAkC,WAAW,EAAE,CAAC;AAC1G,WAAO;AAAA,EACT;AAHO,EAAAA,qBAAS;AAIT,WAAS,SAAS,KAAkC;AAAE,WAAO;AAAA,EAAK;AAAlE,EAAAA,qBAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,uBAAuB,EAAE,SAAS,kCAAkC,WAAW,EAAE,CAAC;AAC1G,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,qBAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,0BAAV;AACE,WAAS,aAAa,OAAqC;AAChE,qBAAiB,OAAO,wBAAwB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACtG,WAAO;AAAA,EACT;AAHO,EAAAA,sBAAS;AAIT,WAAS,SAAS,KAAmC;AAAE,WAAO;AAAA,EAAK;AAAnE,EAAAA,sBAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,wBAAwB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACtG,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,sBAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,wBAAV;AACE,WAAS,aAAa,OAAmC;AAC9D,qBAAiB,OAAO,sBAAsB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACpG,WAAO;AAAA,EACT;AAHO,EAAAA,oBAAS;AAIT,WAAS,SAAS,KAAiC;AAAE,WAAO;AAAA,EAAK;AAAjE,EAAAA,oBAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,sBAAsB,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AACpG,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,oBAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,cAAV;AACE,WAAS,aAAa,OAAyB;AACpD,qBAAiB,OAAO,YAAY,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC1F,WAAO;AAAA,EACT;AAHO,EAAAA,UAAS;AAIT,WAAS,SAAS,KAAuB;AAAE,WAAO;AAAA,EAAK;AAAvD,EAAAA,UAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,YAAY,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC1F,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,UAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,eAAV;AACE,WAAS,aAAa,OAA0B;AACrD,qBAAiB,OAAO,aAAa,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC3F,WAAO;AAAA,EACT;AAHO,EAAAA,WAAS;AAIT,WAAS,SAAS,KAAwB;AAAE,WAAO;AAAA,EAAK;AAAxD,EAAAA,WAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,aAAa,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC3F,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,WAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,iBAAV;AACE,WAAS,aAAa,OAA4B;AACvD,qBAAiB,OAAO,eAAe,EAAE,SAAS,yEAAyE,WAAW,GAAG,WAAW,IAAI,CAAC;AACzJ,WAAO;AAAA,EACT;AAHO,EAAAA,aAAS;AAIT,WAAS,SAAS,KAA0B;AAAE,WAAO;AAAA,EAAK;AAA1D,EAAAA,aAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,eAAe,EAAE,SAAS,yEAAyE,WAAW,GAAG,WAAW,IAAI,CAAC;AACzJ,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,aAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,SAAV;AACE,WAAS,WAAW,OAAoB;AAC7C,qBAAiB,OAAO,OAAO,EAAE,SAAS,qCAAqC,WAAW,GAAG,WAAW,IAAI,CAAC;AAC7G,WAAO;AAAA,EACT;AAHO,EAAAA,KAAS;AAIT,WAAS,SAAS,KAAkB;AAAE,WAAO;AAAA,EAAK;AAAlD,EAAAA,KAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,OAAO,EAAE,SAAS,qCAAqC,WAAW,GAAG,WAAW,IAAI,CAAC;AAC7G,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,KAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,cAAV;AACE,WAAS,aAAa,OAAyB;AACpD,qBAAiB,OAAO,YAAY,EAAE,SAAS,mCAAmC,WAAW,GAAG,WAAW,IAAI,CAAC;AAChH,WAAO;AAAA,EACT;AAHO,EAAAA,UAAS;AAIT,WAAS,SAAS,KAAuB;AAAE,WAAO;AAAA,EAAK;AAAvD,EAAAA,UAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,YAAY,EAAE,SAAS,mCAAmC,WAAW,GAAG,WAAW,IAAI,CAAC;AAChH,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,UAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,cAAV;AACE,WAAS,aAAa,OAAyB;AACpD,qBAAiB,OAAO,YAAY,EAAE,SAAS,mCAAmC,WAAW,GAAG,WAAW,IAAI,CAAC;AAChH,WAAO;AAAA,EACT;AAHO,EAAAA,UAAS;AAIT,WAAS,SAAS,KAAuB;AAAE,WAAO;AAAA,EAAK;AAAvD,EAAAA,UAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,YAAY,EAAE,SAAS,mCAAmC,WAAW,GAAG,WAAW,IAAI,CAAC;AAChH,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,UAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,iBAAV;AACE,WAAS,aAAa,OAA4B;AACvD,qBAAiB,OAAO,eAAe,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC7F,WAAO;AAAA,EACT;AAHO,EAAAA,aAAS;AAIT,WAAS,SAAS,KAA0B;AAAE,WAAO;AAAA,EAAK;AAA1D,EAAAA,aAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,eAAe,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC7F,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,aAAS;AAAA,GAND;AAcV,IAAU;AAAA,CAAV,CAAUC,iBAAV;AACE,WAAS,aAAa,OAA4B;AACvD,qBAAiB,OAAO,eAAe,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC7F,WAAO;AAAA,EACT;AAHO,EAAAA,aAAS;AAIT,WAAS,SAAS,KAA0B;AAAE,WAAO;AAAA,EAAK;AAA1D,EAAAA,aAAS;AACT,WAAS,QAAQ,OAAwB;AAC9C,QAAI;AACF,uBAAiB,OAAO,eAAe,EAAE,SAAS,cAAc,WAAW,GAAG,WAAW,GAAG,CAAC;AAC7F,aAAO;AAAA,IACT,QAAQ;AAAE,aAAO;AAAA,IAAO;AAAA,EAC1B;AALO,EAAAA,aAAS;AAAA,GAND;;;ACrqYjB,IAAO,gBAAQ;","names":["AuthorizationKey","BatchOperationKey","DecisionDefinitionId","DecisionDefinitionKey","DecisionEvaluationInstanceKey","DecisionEvaluationKey","DecisionInstanceKey","DecisionRequirementsKey","DeploymentKey","DocumentId","ElementId","ElementInstanceKey","EndCursor","FormId","FormKey","IncidentKey","JobKey","MessageCorrelationKey","MessageKey","MessageSubscriptionKey","ProcessDefinitionId","ProcessDefinitionKey","ProcessInstanceKey","ScopeKey","SignalKey","StartCursor","Tag","TenantId","Username","UserTaskKey","VariableKey"]}