import * as zod from 'zod';
import { z } from 'zod';
import { LogLevel, LogTransport, Logger } from '@camunda8/orchestration-cluster-api/logger';

type BackpressureSeverity = 'healthy' | 'soft' | 'severe';

declare const SCHEMA: {
    readonly CAMUNDA_REST_ADDRESS: {
        readonly type: "string";
        readonly default: "http://localhost:8080/v2";
        readonly doc: "Base REST endpoint address.";
    };
    readonly CAMUNDA_SDK_HTTP_RETRY_MAX_ATTEMPTS: {
        readonly desc: "Maximum total HTTP attempts (including the initial attempt) for transient failures (429,503, network).";
        readonly type: "int";
        readonly default: 3;
    };
    readonly CAMUNDA_SDK_HTTP_RETRY_BASE_DELAY_MS: {
        readonly desc: "Base delay in milliseconds for exponential backoff (full jitter) for HTTP retries.";
        readonly type: "int";
        readonly default: 100;
    };
    readonly CAMUNDA_SDK_HTTP_RETRY_MAX_DELAY_MS: {
        readonly desc: "Maximum delay cap in milliseconds for HTTP retry backoff.";
        readonly type: "int";
        readonly default: 2000;
    };
    readonly CAMUNDA_TOKEN_AUDIENCE: {
        readonly type: "string";
        readonly default: "zeebe.camunda.io";
        readonly doc: "Token audience for OAuth flows.";
    };
    readonly CAMUNDA_CLIENT_ID: {
        readonly type: "string";
        readonly doc: "OAuth client id (required when CAMUNDA_AUTH_STRATEGY=OAUTH).";
        readonly requiredWhen: {
            readonly key: "CAMUNDA_AUTH_STRATEGY";
            readonly equals: "OAUTH";
        };
    };
    readonly CAMUNDA_CLIENT_SECRET: {
        readonly type: "string";
        readonly secret: true;
        readonly doc: "OAuth client secret (required when CAMUNDA_AUTH_STRATEGY=OAUTH).";
        readonly requiredWhen: {
            readonly key: "CAMUNDA_AUTH_STRATEGY";
            readonly equals: "OAUTH";
        };
    };
    readonly CAMUNDA_OAUTH_URL: {
        readonly type: "string";
        readonly default: "https://login.cloud.camunda.io/oauth/token";
        readonly doc: "OAuth token URL.";
    };
    readonly CAMUNDA_OAUTH_GRANT_TYPE: {
        readonly type: "string";
        readonly default: "client_credentials";
        readonly doc: "OAuth grant type.";
    };
    readonly CAMUNDA_OAUTH_SCOPE: {
        readonly type: "string";
        readonly doc: "Optional OAuth scope (space-separated).";
    };
    readonly CAMUNDA_OAUTH_TIMEOUT_MS: {
        readonly type: "int";
        readonly default: 5000;
        readonly doc: "Timeout in ms for OAuth token fetch.";
    };
    readonly CAMUNDA_OAUTH_RETRY_MAX: {
        readonly type: "int";
        readonly default: 5;
        readonly doc: "Maximum OAuth token fetch attempts (including initial).";
    };
    readonly CAMUNDA_OAUTH_RETRY_BASE_DELAY_MS: {
        readonly type: "int";
        readonly default: 1000;
        readonly doc: "Base delay (ms) for first retry (exponential backoff).";
    };
    readonly CAMUNDA_OAUTH_CACHE_DIR: {
        readonly type: "string";
        readonly doc: "Directory for disk caching OAuth tokens (Node only).";
    };
    readonly CAMUNDA_AUTH_STRATEGY: {
        readonly type: "enum";
        readonly choices: readonly ["NONE", "OAUTH", "BASIC"];
        readonly default: "NONE";
        readonly doc: "Authentication strategy.";
    };
    readonly CAMUNDA_BASIC_AUTH_USERNAME: {
        readonly type: "string";
        readonly doc: "Basic auth username (required when CAMUNDA_AUTH_STRATEGY=BASIC).";
        readonly requiredWhen: {
            readonly key: "CAMUNDA_AUTH_STRATEGY";
            readonly equals: "BASIC";
        };
    };
    readonly CAMUNDA_BASIC_AUTH_PASSWORD: {
        readonly type: "string";
        readonly secret: true;
        readonly doc: "Basic auth password (required when CAMUNDA_AUTH_STRATEGY=BASIC).";
        readonly requiredWhen: {
            readonly key: "CAMUNDA_AUTH_STRATEGY";
            readonly equals: "BASIC";
        };
    };
    readonly CAMUNDA_SDK_VALIDATION: {
        readonly type: "string";
        readonly default: "req:none,res:none";
        readonly doc: "Validation mini-language controlling req/res modes.";
    };
    readonly CAMUNDA_SDK_LOG_LEVEL: {
        readonly type: "enum";
        readonly choices: readonly ["silent", "error", "warn", "info", "debug", "trace", "silly"];
        readonly default: "error";
        readonly doc: "SDK log level. \"silly\" adds unsafe deep diagnostics including HTTP request and response bodies.";
    };
    readonly CAMUNDA_SDK_TELEMETRY_LOG: {
        readonly type: "boolean";
        readonly default: false;
        readonly doc: "Emit telemetry (auth/http/retry) events to the SDK logger automatically (no code).";
    };
    readonly CAMUNDA_SDK_TELEMETRY_CORRELATION: {
        readonly type: "boolean";
        readonly default: false;
        readonly doc: "Enable correlation context (withCorrelation helper) when auto telemetry logging is on.";
    };
    readonly CAMUNDA_MTLS_CERT_PATH: {
        readonly type: "string";
        readonly doc: "Path to client certificate (PEM) for mTLS.";
    };
    readonly CAMUNDA_MTLS_KEY_PATH: {
        readonly type: "string";
        readonly doc: "Path to client private key (PEM) for mTLS.";
    };
    readonly CAMUNDA_MTLS_CA_PATH: {
        readonly type: "string";
        readonly doc: "Path to CA certificate bundle (PEM) for mTLS.";
    };
    readonly CAMUNDA_MTLS_KEY_PASSPHRASE: {
        readonly type: "string";
        readonly secret: true;
        readonly doc: "Optional passphrase for encrypted private key.";
    };
    readonly CAMUNDA_MTLS_CERT: {
        readonly type: "string";
        readonly doc: "Inline PEM client certificate.";
    };
    readonly CAMUNDA_MTLS_KEY: {
        readonly type: "string";
        readonly secret: true;
        readonly doc: "Inline PEM client private key.";
    };
    readonly CAMUNDA_MTLS_CA: {
        readonly type: "string";
        readonly doc: "Inline PEM CA bundle.";
    };
    readonly CAMUNDA_SDK_EVENTUAL_POLL_DEFAULT_MS: {
        readonly type: "int";
        readonly default: 500;
        readonly doc: "Default poll interval (ms) for eventually consistent endpoint polling.";
    };
    readonly CAMUNDA_DEFAULT_TENANT_ID: {
        readonly type: "string";
        readonly default: "<default>";
        readonly doc: "Default tenant id applied to operations when an explicit tenantId is not provided (branded TenantId).";
    };
    readonly CAMUNDA_SDK_BACKPRESSURE_INITIAL_MAX: {
        readonly type: "int";
        readonly default: 16;
        readonly doc: "Initial bootstrap concurrency cap once first backpressure signal occurs.";
    };
    readonly CAMUNDA_SDK_BACKPRESSURE_SOFT_FACTOR: {
        readonly type: "int";
        readonly default: 70;
        readonly doc: "Percentage (integer) multiplier applied to permits on soft backpressure event (e.g. 70 => 0.7x).";
    };
    readonly CAMUNDA_SDK_BACKPRESSURE_SEVERE_FACTOR: {
        readonly type: "int";
        readonly default: 50;
        readonly doc: "Percentage multiplier applied when escalating to severe (e.g. 50 => 0.5x).";
    };
    readonly CAMUNDA_SDK_BACKPRESSURE_RECOVERY_INTERVAL_MS: {
        readonly type: "int";
        readonly default: 1000;
        readonly doc: "Interval in ms between passive recovery checks while healthy hints observed.";
    };
    readonly CAMUNDA_SDK_BACKPRESSURE_RECOVERY_STEP: {
        readonly type: "int";
        readonly default: 1;
        readonly doc: "Permits regained per recovery interval until reaching bootstrap cap.";
    };
    readonly CAMUNDA_SDK_BACKPRESSURE_DECAY_QUIET_MS: {
        readonly type: "int";
        readonly default: 2000;
        readonly doc: "Quiet period (ms) without backpressure signals required to downgrade severity.";
    };
    readonly CAMUNDA_SDK_BACKPRESSURE_FLOOR: {
        readonly type: "int";
        readonly default: 1;
        readonly doc: "Minimum floor concurrency when degraded.";
    };
    readonly CAMUNDA_SDK_BACKPRESSURE_SEVERE_THRESHOLD: {
        readonly type: "int";
        readonly default: 3;
        readonly doc: "Consecutive backpressure events required to enter severe state.";
    };
    readonly CAMUNDA_SDK_BACKPRESSURE_PROFILE: {
        readonly type: "enum";
        readonly choices: readonly ["BALANCED", "CONSERVATIVE", "AGGRESSIVE", "LEGACY"];
        readonly default: "BALANCED";
        readonly doc: "Preset profile for backpressure tuning (LEGACY = observe-only, no gating; other profiles enable adaptive global concurrency control).";
    };
    readonly CAMUNDA_SUPPORT_LOG_ENABLED: {
        readonly type: "boolean";
        readonly default: false;
        readonly doc: "Enable creation of a support log file with environment & configuration diagnostics (Node-only).";
    };
    readonly CAMUNDA_SUPPORT_LOG_FILE_PATH: {
        readonly type: "string";
        readonly doc: "Override support log output file path (default: ./camunda-support.log in current working directory).";
    };
    readonly CAMUNDA_SUPPORT_LOGGER: {
        readonly type: "boolean";
        readonly default: false;
        readonly doc: "Alias for CAMUNDA_SUPPORT_LOG_ENABLED (deprecated).";
    };
};
type EnvVarKey = keyof typeof SCHEMA;
type PrimitiveType<T> = T extends {
    type: 'string';
} ? string : T extends {
    type: 'boolean';
} ? boolean : T extends {
    type: 'int';
} ? number : T extends {
    type: 'enum';
    choices: readonly (infer C)[];
} ? C : never;
type EnvVarValue<K extends EnvVarKey> = PrimitiveType<(typeof SCHEMA)[K]>;
type EnvOverrides = Partial<{
    [K in EnvVarKey]: EnvVarValue<K>;
}>;

type AuthStrategy = 'NONE' | 'OAUTH' | 'BASIC';
type ValidationMode = 'none' | 'warn' | 'strict' | 'fanatical';
interface CamundaConfig {
    restAddress: string;
    tokenAudience: string;
    defaultTenantId: string;
    httpRetry: {
        maxAttempts: number;
        baseDelayMs: number;
        maxDelayMs: number;
    };
    backpressure: {
        enabled: boolean;
        profile: string;
        observeOnly: boolean;
        initialMax: number;
        softFactor: number;
        severeFactor: number;
        recoveryIntervalMs: number;
        recoveryStep: number;
        decayQuietMs: number;
        floor: number;
        severeThreshold: number;
    };
    oauth: {
        clientId?: string;
        clientSecret?: string;
        oauthUrl: string;
        grantType: string;
        scope?: string;
        timeoutMs: number;
        retry: {
            max: number;
            baseDelayMs: number;
        };
        cacheDir?: string;
    };
    auth: {
        strategy: AuthStrategy;
        basic?: {
            username?: string;
            password?: string;
        };
    };
    validation: {
        req: ValidationMode;
        res: ValidationMode;
        raw: string;
    };
    logLevel: 'silent' | 'error' | 'warn' | 'info' | 'debug' | 'trace';
    eventual?: {
        pollDefaultMs: number;
    };
    mtls?: {
        cert?: string;
        key?: string;
        ca?: string;
        keyPassphrase?: string;
        certPath?: string;
        keyPath?: string;
        caPath?: string;
    };
    telemetry?: {
        log: boolean;
        correlation: boolean;
    };
    supportLog?: {
        enabled: boolean;
        filePath: string;
    };
    __raw: Record<string, string | undefined>;
}

interface SupportLogger {
    log(message: string | number | boolean | object, addTimestamp?: boolean): void;
}

interface TelemetryHooks {
    beforeRequest?(e: TelemetryHttpStartEvent): void;
    afterResponse?(e: TelemetryHttpEndEvent): void;
    requestError?(e: TelemetryHttpErrorEvent): void;
    authStart?(e: TelemetryAuthStartEvent): void;
    authSuccess?(e: TelemetryAuthSuccessEvent): void;
    authError?(e: TelemetryAuthErrorEvent): void;
    retry?(e: TelemetryRetryEvent): void;
}
interface BaseEvt {
    ts: number;
    correlationId?: string;
    requestId: string;
}
interface TelemetryHttpStartEvent extends BaseEvt {
    type: 'http.start';
    method: string;
    url: string;
    attempt: number;
}
interface TelemetryHttpEndEvent extends BaseEvt {
    type: 'http.end';
    method: string;
    url: string;
    attempt: number;
    status: number;
    durationMs: number;
}
interface TelemetryHttpErrorEvent extends BaseEvt {
    type: 'http.error';
    method: string;
    url: string;
    attempt: number;
    errorKind: 'network' | 'abort';
    message: string;
    durationMs: number;
}
interface TelemetryAuthStartEvent {
    type: 'auth.start';
    ts: number;
    correlationId?: string;
    audience: string;
    endpoint: string;
    cache: boolean;
}
interface TelemetryAuthSuccessEvent {
    type: 'auth.success';
    ts: number;
    correlationId?: string;
    audience: string;
    endpoint: string;
    cached: boolean;
    durationMs: number;
    expiresInSec: number;
    scopes?: string[];
}
interface TelemetryAuthErrorEvent {
    type: 'auth.error';
    ts: number;
    correlationId?: string;
    audience: string;
    endpoint: string;
    durationMs: number;
    status?: number;
    message: string;
}
interface TelemetryRetryEvent {
    type: 'retry';
    ts: number;
    correlationId?: string;
    attempt: number;
    nextDelayMs: number;
    reason: string;
    domain: 'auth';
}

type AuthToken = string | undefined;
interface Auth {
    /**
     * Which part of the request do we use to send the auth?
     *
     * @default 'header'
     */
    in?: 'header' | 'query' | 'cookie';
    /**
     * Header or query parameter name.
     *
     * @default 'Authorization'
     */
    name?: string;
    scheme?: 'basic' | 'bearer';
    type: 'apiKey' | 'http';
}

interface SerializerOptions<T> {
    /**
     * @default true
     */
    explode: boolean;
    style: T;
}
type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';
type ObjectStyle = 'form' | 'deepObject';

type QuerySerializer = (query: Record<string, unknown>) => string;
type BodySerializer = (body: any) => any;
interface QuerySerializerOptions {
    allowReserved?: boolean;
    array?: SerializerOptions<ArrayStyle>;
    object?: SerializerOptions<ObjectStyle>;
}

type HttpMethod = 'connect' | 'delete' | 'get' | 'head' | 'options' | 'patch' | 'post' | 'put' | 'trace';
type Client$1<RequestFn = never, Config = unknown, MethodFn = never, BuildUrlFn = never, SseFn = never> = {
    /**
     * Returns the final request URL.
     */
    buildUrl: BuildUrlFn;
    getConfig: () => Config;
    request: RequestFn;
    setConfig: (config: Config) => Config;
} & {
    [K in HttpMethod]: MethodFn;
} & ([SseFn] extends [never] ? {
    sse?: never;
} : {
    sse: {
        [K in HttpMethod]: SseFn;
    };
});
interface Config$1 {
    /**
     * Auth token or a function returning auth token. The resolved value will be
     * added to the request payload as defined by its `security` array.
     */
    auth?: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken;
    /**
     * A function for serializing request body parameter. By default,
     * {@link JSON.stringify()} will be used.
     */
    bodySerializer?: BodySerializer | null;
    /**
     * An object containing any HTTP headers that you want to pre-populate your
     * `Headers` object with.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/Headers/Headers#init See more}
     */
    headers?: RequestInit['headers'] | Record<string, string | number | boolean | (string | number | boolean)[] | null | undefined | unknown>;
    /**
     * The request method.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/fetch#method See more}
     */
    method?: Uppercase<HttpMethod>;
    /**
     * A function for serializing request query parameters. By default, arrays
     * will be exploded in form style, objects will be exploded in deepObject
     * style, and reserved characters are percent-encoded.
     *
     * This method will have no effect if the native `paramsSerializer()` Axios
     * API function is used.
     *
     * {@link https://swagger.io/docs/specification/serialization/#query View examples}
     */
    querySerializer?: QuerySerializer | QuerySerializerOptions;
    /**
     * A function validating request data. This is useful if you want to ensure
     * the request conforms to the desired shape, so it can be safely sent to
     * the server.
     */
    requestValidator?: (data: unknown) => Promise<unknown>;
    /**
     * A function transforming response data before it's returned. This is useful
     * for post-processing data, e.g. converting ISO strings into Date objects.
     */
    responseTransformer?: (data: unknown) => Promise<unknown>;
    /**
     * A function validating response data. This is useful if you want to ensure
     * the response conforms to the desired shape, so it can be safely passed to
     * the transformers and returned to the user.
     */
    responseValidator?: (data: unknown) => Promise<unknown>;
}

type ServerSentEventsOptions<TData = unknown> = Omit<RequestInit, 'method'> & Pick<Config$1, 'method' | 'responseTransformer' | 'responseValidator'> & {
    /**
     * Fetch API implementation. You can use this option to provide a custom
     * fetch instance.
     *
     * @default globalThis.fetch
     */
    fetch?: typeof fetch;
    /**
     * Implementing clients can call request interceptors inside this hook.
     */
    onRequest?: (url: string, init: RequestInit) => Promise<Request>;
    /**
     * Callback invoked when a network or parsing error occurs during streaming.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @param error The error that occurred.
     */
    onSseError?: (error: unknown) => void;
    /**
     * Callback invoked when an event is streamed from the server.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @param event Event streamed from the server.
     * @returns Nothing (void).
     */
    onSseEvent?: (event: StreamEvent<TData>) => void;
    serializedBody?: RequestInit['body'];
    /**
     * Default retry delay in milliseconds.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @default 3000
     */
    sseDefaultRetryDelay?: number;
    /**
     * Maximum number of retry attempts before giving up.
     */
    sseMaxRetryAttempts?: number;
    /**
     * Maximum retry delay in milliseconds.
     *
     * Applies only when exponential backoff is used.
     *
     * This option applies only if the endpoint returns a stream of events.
     *
     * @default 30000
     */
    sseMaxRetryDelay?: number;
    /**
     * Optional sleep function for retry backoff.
     *
     * Defaults to using `setTimeout`.
     */
    sseSleepFn?: (ms: number) => Promise<void>;
    url: string;
};
interface StreamEvent<TData = unknown> {
    data: TData;
    event?: string;
    id?: string;
    retry?: number;
}
type ServerSentEventsResult<TData = unknown, TReturn = void, TNext = unknown> = {
    stream: AsyncGenerator<TData extends Record<string, unknown> ? TData[keyof TData] : TData, TReturn, TNext>;
};

type ErrInterceptor<Err, Res, Req, Options> = (error: Err, response: Res, request: Req, options: Options) => Err | Promise<Err>;
type ReqInterceptor<Req, Options> = (request: Req, options: Options) => Req | Promise<Req>;
type ResInterceptor<Res, Req, Options> = (response: Res, request: Req, options: Options) => Res | Promise<Res>;
declare class Interceptors<Interceptor> {
    _fns: (Interceptor | null)[];
    constructor();
    clear(): void;
    getInterceptorIndex(id: number | Interceptor): number;
    exists(id: number | Interceptor): boolean;
    eject(id: number | Interceptor): void;
    update(id: number | Interceptor, fn: Interceptor): number | false | Interceptor;
    use(fn: Interceptor): number;
}
interface Middleware<Req, Res, Err, Options> {
    error: Pick<Interceptors<ErrInterceptor<Err, Res, Req, Options>>, 'eject' | 'use'>;
    request: Pick<Interceptors<ReqInterceptor<Req, Options>>, 'eject' | 'use'>;
    response: Pick<Interceptors<ResInterceptor<Res, Req, Options>>, 'eject' | 'use'>;
}

type ResponseStyle = 'data' | 'fields';
interface Config<T extends ClientOptions$1 = ClientOptions$1> extends Omit<RequestInit, 'body' | 'headers' | 'method'>, Config$1 {
    /**
     * Base URL for all requests made by this client.
     */
    baseUrl?: T['baseUrl'];
    /**
     * Fetch API implementation. You can use this option to provide a custom
     * fetch instance.
     *
     * @default globalThis.fetch
     */
    fetch?: typeof fetch;
    /**
     * Please don't use the Fetch client for Next.js applications. The `next`
     * options won't have any effect.
     *
     * Install {@link https://www.npmjs.com/package/@hey-api/client-next `@hey-api/client-next`} instead.
     */
    next?: never;
    /**
     * Return the response data parsed in a specified format. By default, `auto`
     * will infer the appropriate method from the `Content-Type` response header.
     * You can override this behavior with any of the {@link Body} methods.
     * Select `stream` if you don't want to parse response data at all.
     *
     * @default 'auto'
     */
    parseAs?: 'arrayBuffer' | 'auto' | 'blob' | 'formData' | 'json' | 'stream' | 'text';
    /**
     * Should we return only data or multiple fields (data, error, response, etc.)?
     *
     * @default 'fields'
     */
    responseStyle?: ResponseStyle;
    /**
     * Throw an error instead of returning it in the response?
     *
     * @default false
     */
    throwOnError?: T['throwOnError'];
}
interface RequestOptions<TData = unknown, TResponseStyle extends ResponseStyle = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends Config<{
    responseStyle: TResponseStyle;
    throwOnError: ThrowOnError;
}>, Pick<ServerSentEventsOptions<TData>, 'onSseError' | 'onSseEvent' | 'sseDefaultRetryDelay' | 'sseMaxRetryAttempts' | 'sseMaxRetryDelay'> {
    /**
     * Any body that you want to add to your request.
     *
     * {@link https://developer.mozilla.org/docs/Web/API/fetch#body}
     */
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    /**
     * Security mechanism(s) to use for the request.
     */
    security?: ReadonlyArray<Auth>;
    url: Url;
}
interface ResolvedRequestOptions<TResponseStyle extends ResponseStyle = 'fields', ThrowOnError extends boolean = boolean, Url extends string = string> extends RequestOptions<unknown, TResponseStyle, ThrowOnError, Url> {
    serializedBody?: string;
}
type RequestResult<TData = unknown, TError = unknown, ThrowOnError extends boolean = boolean, TResponseStyle extends ResponseStyle = 'fields'> = ThrowOnError extends true ? Promise<TResponseStyle extends 'data' ? TData extends Record<string, unknown> ? TData[keyof TData] : TData : {
    data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
    request: Request;
    response: Response;
}> : Promise<TResponseStyle extends 'data' ? (TData extends Record<string, unknown> ? TData[keyof TData] : TData) | undefined : ({
    data: TData extends Record<string, unknown> ? TData[keyof TData] : TData;
    error: undefined;
} | {
    data: undefined;
    error: TError extends Record<string, unknown> ? TError[keyof TError] : TError;
}) & {
    request: Request;
    response: Response;
}>;
interface ClientOptions$1 {
    baseUrl?: string;
    responseStyle?: ResponseStyle;
    throwOnError?: boolean;
}
type MethodFn = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle = 'fields'>(options: Omit<RequestOptions<TData, TResponseStyle, ThrowOnError>, 'method'>) => RequestResult<TData, TError, ThrowOnError, TResponseStyle>;
type SseFn = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle = 'fields'>(options: Omit<RequestOptions<TData, TResponseStyle, ThrowOnError>, 'method'>) => Promise<ServerSentEventsResult<TData, TError>>;
type RequestFn = <TData = unknown, TError = unknown, ThrowOnError extends boolean = false, TResponseStyle extends ResponseStyle = 'fields'>(options: Omit<RequestOptions<TData, TResponseStyle, ThrowOnError>, 'method'> & Pick<Required<RequestOptions<TData, TResponseStyle, ThrowOnError>>, 'method'>) => RequestResult<TData, TError, ThrowOnError, TResponseStyle>;
type BuildUrlFn = <TData extends {
    body?: unknown;
    path?: Record<string, unknown>;
    query?: Record<string, unknown>;
    url: string;
}>(options: Pick<TData, 'url'> & Options$1<TData>) => string;
type Client = Client$1<RequestFn, Config, MethodFn, BuildUrlFn, SseFn> & {
    interceptors: Middleware<Request, Response, unknown, ResolvedRequestOptions>;
};
interface TDataShape {
    body?: unknown;
    headers?: unknown;
    path?: unknown;
    query?: unknown;
    url: string;
}
type OmitKeys<T, K> = Pick<T, Exclude<keyof T, K>>;
type Options$1<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean, TResponse = unknown, TResponseStyle extends ResponseStyle = 'fields'> = OmitKeys<RequestOptions<TResponse, TResponseStyle, ThrowOnError>, 'body' | 'path' | 'query' | 'url'> & Omit<TData, 'url'>;

type CamundaKey<T extends string = string> = string & {
    readonly __brand: T;
};
/**
 * Zeebe Engine resource key (Java long serialized as string)
 */
type LongKey = string;
/**
 * The system-assigned key for this resource.
 */
type ResourceKey = ProcessDefinitionKey | DecisionRequirementsKey | FormKey | DecisionDefinitionKey;
type TenantCreateRequest = {
    /**
     * The unique ID for the tenant. Must be 255 characters or less. Can contain letters, numbers, [`_`, `-`, `+`, `.`, `@`].
     */
    tenantId: string;
    /**
     * The name of the tenant.
     */
    name: string;
    /**
     * The description of the tenant.
     */
    description?: string;
};
type TenantCreateResult = {
    tenantId?: TenantId;
    /**
     * The name of the tenant.
     */
    name?: string;
    /**
     * The description of the tenant.
     */
    description?: string;
};
type TenantUpdateRequest = {
    /**
     * The new name of the tenant.
     */
    name: string;
    /**
     * The new description of the tenant.
     */
    description: string;
};
type TenantUpdateResult = {
    tenantId?: TenantId;
    /**
     * The name of the tenant.
     */
    name?: string;
    /**
     * The description of the tenant.
     */
    description?: string;
};
/**
 * Tenant search response item.
 */
type TenantResult = {
    /**
     * The tenant name.
     */
    name?: string;
    tenantId?: TenantId;
    /**
     * The tenant description.
     */
    description?: string;
};
type TenantSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'key' | 'name' | 'tenantId';
    order?: SortOrderEnum;
};
/**
 * Tenant search request
 */
type TenantSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<TenantSearchQuerySortRequest>;
    /**
     * The tenant search filters.
     */
    filter?: TenantFilter;
};
/**
 * Tenant filter request
 */
type TenantFilter = {
    tenantId?: TenantId;
    /**
     * The name of the tenant.
     */
    name?: string;
};
/**
 * Tenant search response.
 */
type TenantSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching tenants.
     */
    items?: Array<TenantResult>;
};
type UserTaskSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'creationDate' | 'completionDate' | 'followUpDate' | 'dueDate' | 'priority' | 'name';
    order?: SortOrderEnum;
};
/**
 * User task search query request.
 */
type UserTaskSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<UserTaskSearchQuerySortRequest>;
    /**
     * The user task search filters.
     */
    filter?: UserTaskFilter;
};
type UserTaskVariableSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'value' | 'name' | 'tenantId' | 'variableKey' | 'scopeKey' | 'processInstanceKey';
    order?: SortOrderEnum;
};
/**
 * User task search query request.
 */
type UserTaskVariableSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<UserTaskVariableSearchQuerySortRequest>;
    /**
     * The user task variable search filters.
     */
    filter?: UserTaskVariableFilter;
};
/**
 * User task search query response.
 */
type UserTaskSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching user tasks.
     */
    items: Array<UserTaskResult>;
};
/**
 * User task filter request.
 */
type UserTaskFilter = {
    /**
     * The user task state.
     */
    state?: UserTaskStateFilterProperty;
    /**
     * The assignee of the user task.
     */
    assignee?: StringFilterProperty;
    /**
     * The priority of the user task.
     */
    priority?: IntegerFilterProperty;
    /**
     * The element ID of the user task.
     */
    elementId?: ElementId;
    /**
     * The task name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.
     *
     */
    name?: string;
    /**
     * The candidate group for this user task.
     */
    candidateGroup?: StringFilterProperty;
    /**
     * The candidate user for this user task.
     */
    candidateUser?: StringFilterProperty;
    /**
     * Tenant ID of this user task.
     */
    tenantId?: StringFilterProperty;
    /**
     * The ID of the process definition.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * The user task creation date.
     */
    creationDate?: DateTimeFilterProperty;
    /**
     * The user task completion date.
     */
    completionDate?: DateTimeFilterProperty;
    /**
     * The user task follow-up date.
     */
    followUpDate?: DateTimeFilterProperty;
    /**
     * The user task due date.
     */
    dueDate?: DateTimeFilterProperty;
    /**
     * Process instance variables associated with the user task.
     */
    processInstanceVariables?: Array<VariableValueFilterProperty>;
    /**
     * Local variables associated with the user task.
     */
    localVariables?: Array<VariableValueFilterProperty>;
    /**
     * The key for this user task.
     */
    userTaskKey?: UserTaskKey;
    /**
     * The key of the process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The key of the process instance.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * The key of the element instance.
     */
    elementInstanceKey?: ElementInstanceKey;
};
/**
 * UserTaskStateEnum property with full advanced search capabilities.
 */
type UserTaskStateFilterProperty = UserTaskStateEnum | AdvancedUserTaskStateFilter;
/**
 * Advanced filter
 * Advanced UserTaskStateEnum filter.
 */
type AdvancedUserTaskStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: UserTaskStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: UserTaskStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<UserTaskStateEnum>;
    $like?: LikeFilter;
};
type VariableValueFilterProperty = {
    /**
     * Name of the variable.
     */
    name: string;
    /**
     * The value of the variable.
     */
    value: StringFilterProperty;
};
/**
 * The user task variable search filters.
 */
type UserTaskVariableFilter = {
    /**
     * Name of the variable.
     */
    name?: StringFilterProperty;
};
type UserTaskResult = {
    /**
     * The name for this user task.
     */
    name?: string;
    state?: UserTaskStateEnum;
    /**
     * The assignee of the user task.
     */
    assignee?: string;
    /**
     * The element ID of the user task.
     */
    elementId?: ElementId;
    /**
     * The candidate groups for this user task.
     */
    candidateGroups?: Array<string>;
    /**
     * The candidate users for this user task.
     */
    candidateUsers?: Array<string>;
    /**
     * The ID of the process definition.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * The creation date of a user task.
     */
    creationDate?: string;
    /**
     * The completion date of a user task.
     */
    completionDate?: string;
    /**
     * The follow date of a user task.
     */
    followUpDate?: string;
    /**
     * The due date of a user task.
     */
    dueDate?: string;
    tenantId?: TenantId;
    /**
     * The external form reference.
     */
    externalFormReference?: string;
    /**
     * The version of the process definition.
     */
    processDefinitionVersion?: number;
    /**
     * Custom headers for the user task.
     */
    customHeaders?: {
        [key: string]: string;
    };
    /**
     * The priority of a user task. The higher the value the higher the priority.
     */
    priority?: number;
    /**
     * The key of the user task.
     */
    userTaskKey: UserTaskKey;
    /**
     * The key of the element instance.
     */
    elementInstanceKey?: ElementInstanceKey;
    /**
     * The name of the process definition.
     */
    processName?: string;
    /**
     * The key of the process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The key of the process instance.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * The key of the form.
     */
    formKey?: FormKey;
};
/**
 * The state of the user task.
 */
type UserTaskStateEnum = 'CREATING' | 'CREATED' | 'ASSIGNING' | 'UPDATING' | 'COMPLETING' | 'COMPLETED' | 'CANCELING' | 'CANCELED' | 'FAILED';
type VariableSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'value' | 'name' | 'tenantId' | 'variableKey' | 'scopeKey' | 'processInstanceKey';
    order?: SortOrderEnum;
};
/**
 * Variable search query request.
 */
type VariableSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<VariableSearchQuerySortRequest>;
    /**
     * The variable search filters.
     */
    filter?: VariableFilter;
};
/**
 * Variable filter request.
 */
type VariableFilter = {
    /**
     * Name of the variable.
     */
    name?: StringFilterProperty;
    /**
     * The value of the variable.
     */
    value?: StringFilterProperty;
    /**
     * Tenant ID of this variable.
     */
    tenantId?: TenantId;
    /**
     * Whether the value is truncated or not.
     */
    isTruncated?: boolean;
    /**
     * The key for this variable.
     */
    variableKey?: VariableKeyFilterProperty;
    /**
     * The key of the scope of this variable.
     */
    scopeKey?: ScopeKeyFilterProperty;
    /**
     * The key of the process instance of this variable.
     */
    processInstanceKey?: ProcessInstanceKeyFilterProperty;
};
/**
 * Variable search query response.
 */
type VariableSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching variables.
     */
    items: Array<VariableSearchResult>;
};
/**
 * Variable search response item.
 */
type VariableSearchResult = VariableResultBase & {
    /**
     * Value of this variable. Can be truncated.
     */
    value: string;
    /**
     * Whether the value is truncated or not.
     */
    isTruncated: boolean;
};
/**
 * Variable search response item.
 */
type VariableResult = VariableResultBase & {
    /**
     * Full value of this variable.
     */
    value: string;
};
/**
 * Variable response item.
 */
type VariableResultBase = {
    /**
     * Name of this variable.
     */
    name: string;
    /**
     * Tenant ID of this variable.
     */
    tenantId: TenantId;
    /**
     * The key for this variable.
     */
    variableKey: VariableKey;
    /**
     * The key of the scope of this variable.
     */
    scopeKey: ScopeKey;
    /**
     * The key of the process instance of this variable.
     */
    processInstanceKey: ProcessInstanceKey;
};
type ProcessDefinitionSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'processDefinitionKey' | 'name' | 'resourceName' | 'version' | 'versionTag' | 'processDefinitionId' | 'tenantId';
    order?: SortOrderEnum;
};
type ProcessDefinitionSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<ProcessDefinitionSearchQuerySortRequest>;
    /**
     * The process definition search filters.
     */
    filter?: ProcessDefinitionFilter;
};
/**
 * Process definition search filter.
 */
type ProcessDefinitionFilter = {
    /**
     * Name of this process definition.
     */
    name?: StringFilterProperty;
    /**
     * Whether to only return the latest version of each process definition.
     * When using this filter, pagination functionality is limited, you can only paginate forward using `after` and `limit`.
     * The response contains no `startCursor` in the `page`, and requests ignore the `from` and `before` in the `page`.
     *
     */
    isLatestVersion?: boolean;
    /**
     * Resource name of this process definition.
     */
    resourceName?: string;
    /**
     * Version of this process definition.
     */
    version?: number;
    /**
     * Version tag of this process definition.
     */
    versionTag?: string;
    /**
     * Process definition ID of this process definition.
     */
    processDefinitionId?: StringFilterProperty;
    /**
     * Tenant ID of this process definition.
     */
    tenantId?: TenantId;
    /**
     * The key for this process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * Indicates whether the start event of the process has an associated Form Key.
     */
    hasStartForm?: boolean;
};
type ProcessDefinitionSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching process definitions.
     */
    items?: Array<ProcessDefinitionResult>;
};
type ProcessDefinitionResult = {
    /**
     * Name of this process definition.
     */
    name?: string;
    /**
     * Resource name for this process definition.
     */
    resourceName?: string;
    /**
     * Version of this process definition.
     */
    version?: number;
    /**
     * Version tag of this process definition.
     */
    versionTag?: string;
    /**
     * Process definition ID of this process definition.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * Tenant ID of this process definition.
     */
    tenantId?: TenantId;
    /**
     * The key for this process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * Indicates whether the start event of the process has an associated Form Key.
     */
    hasStartForm?: boolean;
};
type ProcessInstanceSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'processInstanceKey' | 'processDefinitionId' | 'processDefinitionName' | 'processDefinitionVersion' | 'processDefinitionVersionTag' | 'processDefinitionKey' | 'parentProcessInstanceKey' | 'parentElementInstanceKey' | 'startDate' | 'endDate' | 'state' | 'hasIncident' | 'tenantId';
    order?: SortOrderEnum;
};
/**
 * Process instance search request.
 */
type ProcessInstanceSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<ProcessInstanceSearchQuerySortRequest>;
    /**
     * The process instance search filters.
     */
    filter?: ProcessInstanceFilter;
};
type ProcessInstanceIncidentSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<IncidentSearchQuerySortRequest>;
};
/**
 * Advanced filter
 * Advanced integer (int32) filter.
 */
type AdvancedIntegerFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: number;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: number;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Greater than comparison with the provided value.
     */
    $gt?: number;
    /**
     * Greater than or equal comparison with the provided value.
     */
    $gte?: number;
    /**
     * Lower than comparison with the provided value.
     */
    $lt?: number;
    /**
     * Lower than or equal comparison with the provided value.
     */
    $lte?: number;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<number>;
};
/**
 * Integer property with advanced search capabilities.
 */
type IntegerFilterProperty = number | AdvancedIntegerFilter;
/**
 * Advanced filter
 * Basic advanced string filter.
 */
type BasicStringFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: string;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: string;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<string>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<string>;
};
/**
 * Advanced filter
 * Advanced string filter.
 */
type AdvancedStringFilter = BasicStringFilter & {
    $like?: LikeFilter;
};
/**
 * Advanced filter
 * Advanced ProcessInstanceStateEnum filter.
 */
type AdvancedProcessInstanceStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ProcessInstanceStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: ProcessInstanceStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ProcessInstanceStateEnum>;
    $like?: LikeFilter;
};
/**
 * Advanced filter
 * Advanced ElementInstanceStateEnum filter.
 */
type AdvancedElementInstanceStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ElementInstanceStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: ElementInstanceStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ElementInstanceStateEnum>;
    $like?: LikeFilter;
};
/**
 * Advanced filter
 * Advanced DecisionDefinitionKey filter.
 */
type AdvancedDecisionDefinitionKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: DecisionDefinitionKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: DecisionDefinitionKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<DecisionDefinitionKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<DecisionDefinitionKey>;
};
/**
 * DecisionDefinitionKey property with full advanced search capabilities.
 */
type DecisionDefinitionKeyFilterProperty = DecisionDefinitionKey | AdvancedDecisionDefinitionKeyFilter;
/**
 * Advanced filter
 * Advanced date-time filter.
 */
type AdvancedDateTimeFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: string;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: string;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Greater than comparison with the provided value.
     */
    $gt?: string;
    /**
     * Greater than or equal comparison with the provided value.
     */
    $gte?: string;
    /**
     * Lower than comparison with the provided value.
     */
    $lt?: string;
    /**
     * Lower than or equal comparison with the provided value.
     */
    $lte?: string;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<string>;
};
/**
 * String property with basic advanced search capabilities.
 */
type BasicStringFilterProperty = string | BasicStringFilter;
/**
 * String property with full advanced search capabilities.
 */
type StringFilterProperty = string | AdvancedStringFilter;
/**
 * Checks if the property matches the provided like value.
 *
 * Supported wildcard characters are:
 *
 * * `*`: matches zero, one, or multiple characters.
 * * `?`: matches one, single character.
 *
 * Wildcard characters can be escaped with backslash, for instance: `\*`.
 *
 */
type LikeFilter = string;
/**
 * ProcessInstanceStateEnum property with full advanced search capabilities.
 */
type ProcessInstanceStateFilterProperty = ProcessInstanceStateEnum | AdvancedProcessInstanceStateFilter;
/**
 * ElementInstanceStateEnum property with full advanced search capabilities.
 */
type ElementInstanceStateFilterProperty = ElementInstanceStateEnum | AdvancedElementInstanceStateFilter;
/**
 * Date-time property with full advanced search capabilities.
 */
type DateTimeFilterProperty = string | AdvancedDateTimeFilter;
/**
 * Advanced filter
 * Advanced ProcessDefinitionKey filter.
 */
type AdvancedProcessDefinitionKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ProcessDefinitionKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: ProcessDefinitionKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ProcessDefinitionKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<ProcessDefinitionKey>;
};
/**
 * ProcessDefinitionKey property with full advanced search capabilities.
 */
type ProcessDefinitionKeyFilterProperty = ProcessDefinitionKey | AdvancedProcessDefinitionKeyFilter;
/**
 * Advanced filter
 * Advanced ProcessInstanceKey filter.
 */
type AdvancedProcessInstanceKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ProcessInstanceKey;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: ProcessInstanceKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ProcessInstanceKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<ProcessInstanceKey>;
};
/**
 * ProcessInstanceKey property with full advanced search capabilities.
 */
type ProcessInstanceKeyFilterProperty = ProcessInstanceKey | AdvancedProcessInstanceKeyFilter;
/**
 * Advanced filter
 * Advanced ElementInstanceKey filter.
 */
type AdvancedElementInstanceKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ElementInstanceKey;
    /**
     * Checks for equality with the provided value.
     */
    $neq?: ElementInstanceKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ElementInstanceKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<ElementInstanceKey>;
};
/**
 * ElementInstanceKey property with full advanced search capabilities.
 */
type ElementInstanceKeyFilterProperty = ElementInstanceKey | AdvancedElementInstanceKeyFilter;
/**
 * Advanced filter
 * Advanced VariableKey filter.
 */
type AdvancedVariableKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: VariableKey;
    /**
     * Checks for equality with the provided value.
     */
    $neq?: VariableKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<VariableKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<VariableKey>;
};
/**
 * VariableKey property with full advanced search capabilities.
 */
type VariableKeyFilterProperty = VariableKey | AdvancedVariableKeyFilter;
/**
 * Advanced filter
 * Advanced ScopeKey filter.
 */
type AdvancedScopeKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: ScopeKey;
    /**
     * Checks for equality with the provided value.
     */
    $neq?: ScopeKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<ScopeKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<ScopeKey>;
};
/**
 * ScopeKey property with full advanced search capabilities.
 */
type ScopeKeyFilterProperty = ScopeKey | AdvancedScopeKeyFilter;
/**
 * Advanced filter
 * Advanced MessageSubscriptionKey filter.
 */
type AdvancedMessageSubscriptionKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: MessageSubscriptionKey;
    /**
     * Checks for equality with the provided value.
     */
    $neq?: MessageSubscriptionKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<MessageSubscriptionKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<MessageSubscriptionKey>;
};
/**
 * MessageSubscriptionKey property with full advanced search capabilities.
 */
type MessageSubscriptionKeyFilterProperty = MessageSubscriptionKey | AdvancedMessageSubscriptionKeyFilter;
/**
 * Advanced filter
 * Advanced JobKey filter.
 */
type AdvancedJobKeyFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: JobKey;
    /**
     * Checks for equality with the provided value.
     */
    $neq?: JobKey;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<JobKey>;
    /**
     * Checks if the property matches none of the provided values.
     */
    $notIn?: Array<JobKey>;
};
/**
 * JobKey property with full advanced search capabilities.
 */
type JobKeyFilterProperty = JobKey | AdvancedJobKeyFilter;
/**
 * Base process instance search filter.
 */
type BaseProcessInstanceFilterFields = {
    /**
     * The start date.
     */
    startDate?: DateTimeFilterProperty;
    /**
     * The end date.
     */
    endDate?: DateTimeFilterProperty;
    /**
     * The process instance state.
     */
    state?: ProcessInstanceStateFilterProperty;
    /**
     * Whether this process instance has a related incident or not.
     */
    hasIncident?: boolean;
    /**
     * The tenant ID.
     */
    tenantId?: StringFilterProperty;
    /**
     * The process instance variables.
     */
    variables?: Array<VariableValueFilterProperty>;
    /**
     * The key of this process instance.
     */
    processInstanceKey?: ProcessInstanceKeyFilterProperty;
    /**
     * The parent process instance key.
     */
    parentProcessInstanceKey?: ProcessInstanceKeyFilterProperty;
    /**
     * The parent element instance key.
     */
    parentElementInstanceKey?: ElementInstanceKeyFilterProperty;
    /**
     * The batch operation ID.
     */
    batchOperationId?: StringFilterProperty;
    /**
     * The error message related to the process.
     */
    errorMessage?: StringFilterProperty;
    /**
     * Whether the process has failed jobs with retries left.
     */
    hasRetriesLeft?: boolean;
    /**
     * The state of the element instances associated with the process instance.
     */
    elementInstanceState?: ElementInstanceStateFilterProperty;
    /**
     * The element ID associated with the process instance.
     */
    elementId?: StringFilterProperty;
    /**
     * Whether the element instance has an incident or not.
     */
    hasElementInstanceIncident?: boolean;
    /**
     * The incident error hash code, associated with this process.
     */
    incidentErrorHashCode?: IntegerFilterProperty;
    tags?: TagSet;
};
/**
 * Process definition statistics search filter.
 */
type ProcessDefinitionStatisticsFilter = BaseProcessInstanceFilterFields & {
    /**
     * Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.
     *
     * Top-level fields and the `$or` clause are combined using AND logic  meaning: (top-level filters) AND (any of the `$or` filters) must match.
     * <br>
     * <em>Example:</em>
     *
     * ```json
     * {
     * "state": "ACTIVE",
     * "tenantId": 123,
     * "$or": [
     * { "processDefinitionId": "process_v1" },
     * { "processDefinitionId": "process_v2", "hasIncident": true }
     * ]
     * }
     * ```
     * This matches process instances that:
     *
     * <ul style="padding-left: 20px; margin-left: 20px;">
     * <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>
     * <li style="list-style-type: disc;">have tenant ID equal to <em>123</em></li>
     * <li style="list-style-type: disc;">and match either:
     * <ul style="padding-left: 20px; margin-left: 20px;">
     * <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>
     * <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>
     * </ul>
     * </li>
     * </ul>
     * <br>
     * <p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.
     *
     */
    $or?: Array<BaseProcessInstanceFilterFields>;
};
/**
 * Process instance search filter.
 */
type ProcessInstanceFilterFields = BaseProcessInstanceFilterFields & {
    /**
     * The process definition ID.
     */
    processDefinitionId?: StringFilterProperty;
    /**
     * The process definition name.
     */
    processDefinitionName?: StringFilterProperty;
    /**
     * The process definition version.
     */
    processDefinitionVersion?: IntegerFilterProperty;
    /**
     * The process definition version tag.
     */
    processDefinitionVersionTag?: StringFilterProperty;
    /**
     * The process definition key.
     */
    processDefinitionKey?: ProcessDefinitionKeyFilterProperty;
};
/**
 * Process instance search filter.
 */
type ProcessInstanceFilter = ProcessInstanceFilterFields & {
    /**
     * Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.
     *
     * Top-level fields and the `$or` clause are combined using AND logic  meaning: (top-level filters) AND (any of the `$or` filters) must match.
     * <br>
     * <em>Example:</em>
     *
     * ```json
     * {
     * "state": "ACTIVE",
     * "tenantId": 123,
     * "$or": [
     * { "processDefinitionId": "process_v1" },
     * { "processDefinitionId": "process_v2", "hasIncident": true }
     * ]
     * }
     * ```
     * This matches process instances that:
     *
     * <ul style="padding-left: 20px; margin-left: 20px;">
     * <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>
     * <li style="list-style-type: disc;">have tenant ID equal to <em>123</em></li>
     * <li style="list-style-type: disc;">and match either:
     * <ul style="padding-left: 20px; margin-left: 20px;">
     * <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>
     * <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>
     * </ul>
     * </li>
     * </ul>
     * <br>
     * <p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.
     *
     */
    $or?: Array<ProcessInstanceFilterFields>;
};
/**
 * Process instance search response.
 */
type ProcessInstanceSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching process instances.
     */
    items: Array<ProcessInstanceResult>;
};
/**
 * Process instance search response item.
 */
type ProcessInstanceResult = {
    processDefinitionId: ProcessDefinitionId;
    /**
     * The process definition name.
     */
    processDefinitionName: string;
    /**
     * The process definition version.
     */
    processDefinitionVersion: number;
    /**
     * The process definition version tag.
     */
    processDefinitionVersionTag?: string;
    /**
     * The start date.
     */
    startDate: string;
    /**
     * The end date.
     */
    endDate?: string;
    state: ProcessInstanceStateEnum;
    /**
     * Whether this process instance has a related incident or not.
     */
    hasIncident: boolean;
    tenantId: TenantId;
    /**
     * The key of this process instance.
     */
    processInstanceKey: ProcessInstanceKey;
    /**
     * The process definition key.
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * The parent process instance key.
     */
    parentProcessInstanceKey?: ProcessInstanceKey;
    /**
     * The parent element instance key.
     */
    parentElementInstanceKey?: ElementInstanceKey;
    tags?: TagSet;
};
/**
 * Process instance states
 */
type ProcessInstanceStateEnum = 'ACTIVE' | 'COMPLETED' | 'TERMINATED';
/**
 * Element states
 */
type ElementInstanceStateEnum = 'ACTIVE' | 'COMPLETED' | 'TERMINATED';
type ProcessInstanceCallHierarchyEntry = {
    /**
     * The key of the process instance.
     */
    processInstanceKey: ProcessInstanceKey;
    /**
     * The key of the process definition.
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * The name of the process definition (fall backs to the process definition ID if not available).
     */
    processDefinitionName: string;
};
/**
 * Process instance sequence flows query response.
 */
type ProcessInstanceSequenceFlowsQueryResult = {
    /**
     * The sequence flows.
     */
    items?: Array<ProcessInstanceSequenceFlowResult>;
};
/**
 * Process instance sequence flow result.
 */
type ProcessInstanceSequenceFlowResult = {
    /**
     * The sequence flow ID.
     */
    sequenceFlowId?: string;
    /**
     * The key of this process instance.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * The process definition key.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The process definition ID.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * The element ID for this sequence flow, as provided in the BPMN process.
     */
    elementId?: ElementId;
    tenantId?: TenantId;
};
/**
 * Process definition element statistics request.
 */
type ProcessDefinitionElementStatisticsQuery = {
    /**
     * The process definition statistics search filters.
     */
    filter?: ProcessDefinitionStatisticsFilter;
};
/**
 * Process definition element statistics query response.
 */
type ProcessDefinitionElementStatisticsQueryResult = {
    /**
     * The element statistics.
     */
    items?: Array<ProcessElementStatisticsResult>;
};
/**
 * Process instance element statistics query response.
 */
type ProcessInstanceElementStatisticsQueryResult = {
    /**
     * The element statistics.
     */
    items?: Array<ProcessElementStatisticsResult>;
};
/**
 * Process element statistics response.
 */
type ProcessElementStatisticsResult = {
    /**
     * The element ID for which the results are aggregated.
     */
    elementId?: ElementId;
    /**
     * The total number of active instances of the element.
     */
    active?: number;
    /**
     * The total number of canceled instances of the element.
     */
    canceled?: number;
    /**
     * The total number of incidents for the element.
     */
    incidents?: number;
    /**
     * The total number of completed instances of the element.
     */
    completed?: number;
};
type CancelProcessInstanceRequest = {
    operationReference?: OperationReference;
} | null;
type ElementInstanceSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'elementInstanceKey' | 'processInstanceKey' | 'processDefinitionKey' | 'processDefinitionId' | 'startDate' | 'endDate' | 'elementId' | 'elementName' | 'type' | 'state' | 'incidentKey' | 'tenantId';
    order?: SortOrderEnum;
};
/**
 * Element instance search request.
 */
type ElementInstanceSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<ElementInstanceSearchQuerySortRequest>;
    /**
     * The element instance search filters.
     */
    filter?: ElementInstanceFilter;
};
/**
 * Element instance filter.
 */
type ElementInstanceFilter = {
    /**
     * The process definition ID associated to this element instance.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * State of element instance as defined set of values.
     */
    state?: ElementInstanceStateFilterProperty;
    /**
     * Type of element as defined set of values.
     */
    type?: 'UNSPECIFIED' | 'PROCESS' | 'SUB_PROCESS' | 'EVENT_SUB_PROCESS' | 'AD_HOC_SUB_PROCESS' | 'AD_HOC_SUB_PROCESS_INNER_INSTANCE' | 'START_EVENT' | 'INTERMEDIATE_CATCH_EVENT' | 'INTERMEDIATE_THROW_EVENT' | 'BOUNDARY_EVENT' | 'END_EVENT' | 'SERVICE_TASK' | 'RECEIVE_TASK' | 'USER_TASK' | 'MANUAL_TASK' | 'TASK' | 'EXCLUSIVE_GATEWAY' | 'INCLUSIVE_GATEWAY' | 'PARALLEL_GATEWAY' | 'EVENT_BASED_GATEWAY' | 'SEQUENCE_FLOW' | 'MULTI_INSTANCE_BODY' | 'CALL_ACTIVITY' | 'BUSINESS_RULE_TASK' | 'SCRIPT_TASK' | 'SEND_TASK' | 'UNKNOWN';
    /**
     * The element ID for this element instance.
     */
    elementId?: ElementId;
    /**
     * The element name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.
     *
     */
    elementName?: string;
    /**
     * Shows whether this element instance has an incident related to.
     */
    hasIncident?: boolean;
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this element instance.
     */
    elementInstanceKey?: ElementInstanceKey;
    /**
     * The process instance key associated to this element instance.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * The process definition key associated to this element instance.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The key of incident if field incident is true.
     */
    incidentKey?: IncidentKey;
    /**
     * The start date of this element instance.
     */
    startDate?: DateTimeFilterProperty;
    /**
     * The end date of this element instance.
     */
    endDate?: DateTimeFilterProperty;
    /**
     * The scope key of this element instance. If provided with a process instance key it will return element instances that are immediate children of the process instance. If provided with an element instance key it will return element instances that are immediate children of the element instance.
     *
     */
    elementInstanceScopeKey?: ElementInstanceKey | ProcessInstanceKey;
};
type ElementInstanceSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching element instances.
     */
    items?: Array<ElementInstanceResult>;
};
type ElementInstanceResult = {
    /**
     * The process definition ID associated to this element instance.
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * Date when element instance started.
     */
    startDate: string;
    /**
     * Date when element instance finished.
     */
    endDate?: string;
    /**
     * The element ID for this element instance.
     */
    elementId: ElementId;
    /**
     * The element name for this element instance.
     */
    elementName: string;
    /**
     * Type of element as defined set of values.
     */
    type: 'UNSPECIFIED' | 'PROCESS' | 'SUB_PROCESS' | 'EVENT_SUB_PROCESS' | 'AD_HOC_SUB_PROCESS' | 'AD_HOC_SUB_PROCESS_INNER_INSTANCE' | 'START_EVENT' | 'INTERMEDIATE_CATCH_EVENT' | 'INTERMEDIATE_THROW_EVENT' | 'BOUNDARY_EVENT' | 'END_EVENT' | 'SERVICE_TASK' | 'RECEIVE_TASK' | 'USER_TASK' | 'MANUAL_TASK' | 'TASK' | 'EXCLUSIVE_GATEWAY' | 'INCLUSIVE_GATEWAY' | 'PARALLEL_GATEWAY' | 'EVENT_BASED_GATEWAY' | 'SEQUENCE_FLOW' | 'MULTI_INSTANCE_BODY' | 'CALL_ACTIVITY' | 'BUSINESS_RULE_TASK' | 'SCRIPT_TASK' | 'SEND_TASK' | 'UNKNOWN';
    /**
     * State of element instance as defined set of values.
     */
    state: ElementInstanceStateEnum;
    /**
     * Shows whether this element instance has an incident. If true also an incidentKey is provided.
     */
    hasIncident: boolean;
    /**
     * The tenant ID of the incident.
     */
    tenantId: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this element instance.
     */
    elementInstanceKey: ElementInstanceKey;
    /**
     * The process instance key associated to this element instance.
     */
    processInstanceKey: ProcessInstanceKey;
    /**
     * The process definition key associated to this element instance.
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * Incident key associated with this element instance.
     */
    incidentKey?: IncidentKey;
};
type AdHocSubProcessActivateActivitiesInstruction = {
    /**
     * Activities to activate.
     */
    elements: Array<AdHocSubProcessActivateActivityReference>;
    /**
     * Whether to cancel remaining instances of the ad-hoc sub-process.
     */
    cancelRemainingInstances?: boolean;
};
type AdHocSubProcessActivateActivityReference = {
    /**
     * The ID of the element that should be activated.
     */
    elementId: ElementId;
    /**
     * Variables to be set when activating the element.
     */
    variables?: {
        [key: string]: unknown;
    };
};
type DecisionDefinitionSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'decisionDefinitionKey' | 'decisionDefinitionId' | 'name' | 'version' | 'decisionRequirementsId' | 'decisionRequirementsKey' | 'tenantId';
    order?: SortOrderEnum;
};
type DecisionDefinitionSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<DecisionDefinitionSearchQuerySortRequest>;
    /**
     * The decision definition search filters.
     */
    filter?: DecisionDefinitionFilter;
};
/**
 * Decision definition search filter.
 */
type DecisionDefinitionFilter = {
    /**
     * The DMN ID of the decision definition.
     */
    decisionDefinitionId?: DecisionDefinitionId;
    /**
     * The DMN name of the decision definition.
     */
    name?: string;
    /**
     * The assigned version of the decision definition.
     */
    version?: number;
    /**
     * the DMN ID of the decision requirements graph that the decision definition is part of.
     */
    decisionRequirementsId?: string;
    /**
     * The tenant ID of the decision definition.
     */
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this decision definition.
     */
    decisionDefinitionKey?: DecisionDefinitionKey;
    /**
     * The assigned key of the decision requirements graph that the decision definition is part of.
     */
    decisionRequirementsKey?: DecisionRequirementsKey;
};
type IncidentSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'incidentKey' | 'processDefinitionKey' | 'processDefinitionId' | 'processInstanceKey' | 'errorType' | 'errorMessage' | 'elementId' | 'elementInstanceKey' | 'creationTime' | 'state' | 'jobKey' | 'tenantId';
    order?: SortOrderEnum;
};
type IncidentSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<IncidentSearchQuerySortRequest>;
    /**
     * The incident search filters.
     */
    filter?: IncidentFilter;
};
/**
 * Incident search filter.
 */
type IncidentFilter = {
    /**
     * The process definition ID associated to this incident.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * Incident error type with a defined set of values.
     */
    errorType?: 'UNSPECIFIED' | 'UNKNOWN' | 'IO_MAPPING_ERROR' | 'JOB_NO_RETRIES' | 'EXECUTION_LISTENER_NO_RETRIES' | 'TASK_LISTENER_NO_RETRIES' | 'AD_HOC_SUB_PROCESS_NO_RETRIES' | 'CONDITION_ERROR' | 'EXTRACT_VALUE_ERROR' | 'CALLED_ELEMENT_ERROR' | 'UNHANDLED_ERROR_EVENT' | 'MESSAGE_SIZE_EXCEEDED' | 'CALLED_DECISION_ERROR' | 'DECISION_EVALUATION_ERROR' | 'FORM_NOT_FOUND' | 'RESOURCE_NOT_FOUND';
    /**
     * Error message which describes the error in more detail.
     */
    errorMessage?: string;
    /**
     * The element ID associated to this incident.
     */
    elementId?: ElementId;
    /**
     * Date of incident creation.
     */
    creationTime?: string;
    /**
     * State of this incident with a defined set of values.
     */
    state?: 'ACTIVE' | 'MIGRATED' | 'RESOLVED' | 'PENDING';
    /**
     * The tenant ID of the incident.
     */
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this incident.
     */
    incidentKey?: IncidentKey;
    /**
     * The process definition key associated to this incident.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The process instance key associated to this incident.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * The element instance key associated to this incident.
     */
    elementInstanceKey?: ElementInstanceKey;
    /**
     * The job key, if exists, associated with this incident.
     */
    jobKey?: JobKey;
};
type IncidentSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching incidents.
     */
    items?: Array<IncidentResult>;
};
type CorrelatedMessageSubscriptionSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching correlated message subscriptions.
     */
    items?: Array<CorrelatedMessageSubscriptionResult>;
};
type CorrelatedMessageSubscriptionResult = {
    /**
     * The correlation key of the message.
     */
    correlationKey: string;
    /**
     * The time when the message was correlated.
     */
    correlationTime: string;
    /**
     * The element ID that received the message.
     */
    elementId: string;
    /**
     * The element instance key that received the message.
     */
    elementInstanceKey?: ElementInstanceKey;
    /**
     * The message key.
     */
    messageKey: MessageKey;
    /**
     * The name of the message.
     */
    messageName: string;
    /**
     * The partition ID that correlated the message.
     */
    partitionId: number;
    /**
     * The process definition ID associated with this correlated message subscription.
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * The process definition key associated with this correlated message subscription.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The process instance key associated with this correlated message subscription.
     */
    processInstanceKey: ProcessInstanceKey;
    /**
     * The subscription key that received the message.
     */
    subscriptionKey: MessageSubscriptionKey;
    /**
     * The tenant ID associated with this correlated message subscription.
     */
    tenantId: TenantId;
};
type CorrelatedMessageSubscriptionSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<CorrelatedMessageSubscriptionSearchQuerySortRequest>;
    /**
     * The correlated message subscriptions search filters.
     */
    filter?: CorrelatedMessageSubscriptionFilter;
};
type CorrelatedMessageSubscriptionSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'correlationKey' | 'correlationTime' | 'elementId' | 'elementInstanceKey' | 'messageKey' | 'messageName' | 'partitionId' | 'processDefinitionId' | 'processDefinitionKey' | 'processInstanceKey' | 'subscriptionKey' | 'tenantId';
    order?: SortOrderEnum;
};
/**
 * Correlated message subscriptions search filter.
 */
type CorrelatedMessageSubscriptionFilter = {
    /**
     * The correlation key of the message.
     */
    correlationKey?: StringFilterProperty;
    /**
     * The time when the message was correlated.
     */
    correlationTime?: DateTimeFilterProperty;
    /**
     * The element ID that received the message.
     */
    elementId?: StringFilterProperty;
    /**
     * The element instance key that received the message.
     */
    elementInstanceKey?: ElementInstanceKeyFilterProperty;
    /**
     * The message key.
     */
    messageKey?: BasicStringFilterProperty;
    /**
     * The name of the message.
     */
    messageName?: StringFilterProperty;
    /**
     * The partition ID that correlated the message.
     */
    partitionId?: IntegerFilterProperty;
    /**
     * The process definition ID associated with this correlated message subscription.
     */
    processDefinitionId?: StringFilterProperty;
    /**
     * The process definition key associated with this correlated message subscription.
     */
    processDefinitionKey?: BasicStringFilterProperty;
    /**
     * The process instance key associated with this correlated message subscription.
     */
    processInstanceKey?: BasicStringFilterProperty;
    /**
     * The subscription key that received the message.
     */
    subscriptionKey?: BasicStringFilterProperty;
    /**
     * The tenant ID associated with this correlated message subscription.
     */
    tenantId?: StringFilterProperty;
};
type MessageSubscriptionSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching message subscriptions.
     */
    items?: Array<MessageSubscriptionResult>;
};
type MessageSubscriptionResult = {
    /**
     * The message subscription key associated with this message subscription.
     */
    messageSubscriptionKey?: MessageSubscriptionKey;
    /**
     * The process definition ID associated with this message subscription.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * The process definition key associated with this message subscription.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The process instance key associated with this message subscription.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * The element ID associated with this message subscription.
     */
    elementId?: ElementId;
    /**
     * The element instance key associated with this message subscription.
     */
    elementInstanceKey?: ElementInstanceKey;
    messageSubscriptionState?: MessageSubscriptionStateEnum;
    /**
     * The last updated date of the message subscription.
     */
    lastUpdatedDate?: string;
    /**
     * The name of the message associated with the message subscription.
     */
    messageName?: string;
    /**
     * The correlation key of the message subscription.
     */
    correlationKey?: MessageCorrelationKey;
    tenantId?: TenantId;
};
type MessageSubscriptionSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'messageSubscriptionKey' | 'processDefinitionId' | 'processInstanceKey' | 'elementId' | 'elementInstanceKey' | 'messageSubscriptionState' | 'lastUpdatedDate' | 'messageName' | 'correlationKey' | 'tenantId';
    order?: SortOrderEnum;
};
type MessageSubscriptionSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<MessageSubscriptionSearchQuerySortRequest>;
    /**
     * The incident search filters.
     */
    filter?: MessageSubscriptionFilter;
};
/**
 * Message subscription search filter.
 */
type MessageSubscriptionFilter = {
    /**
     * The message subscription key associated with this message subscription.
     */
    messageSubscriptionKey?: MessageSubscriptionKeyFilterProperty;
    /**
     * The process definition ID associated with this message subscription.
     */
    processDefinitionId?: StringFilterProperty;
    /**
     * The process instance key associated with this message subscription.
     */
    processInstanceKey?: ProcessInstanceKeyFilterProperty;
    /**
     * The element ID associated with this message subscription.
     */
    elementId?: StringFilterProperty;
    /**
     * The element instance key associated with this message subscription.
     */
    elementInstanceKey?: ElementInstanceKeyFilterProperty;
    /**
     * The message subscription state.
     */
    messageSubscriptionState?: MessageSubscriptionStateFilterProperty;
    /**
     * The last updated date of the message subscription.
     */
    lastUpdatedDate?: DateTimeFilterProperty;
    /**
     * The name of the message associated with the message subscription.
     */
    messageName?: StringFilterProperty;
    /**
     * The correlation key of the message subscription.
     */
    correlationKey?: StringFilterProperty;
    /**
     * The unique external tenant ID.
     */
    tenantId?: StringFilterProperty;
};
/**
 * MessageSubscriptionStateEnum with full advanced search capabilities.
 */
type MessageSubscriptionStateFilterProperty = MessageSubscriptionStateEnum | AdvancedMessageSubscriptionStateFilter;
/**
 * The state of message subscription.
 */
type MessageSubscriptionStateEnum = 'CORRELATED' | 'CREATED' | 'DELETED' | 'MIGRATED';
/**
 * Advanced filter
 * Advanced MessageSubscriptionStateEnum filter
 */
type AdvancedMessageSubscriptionStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: MessageSubscriptionStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: MessageSubscriptionStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<MessageSubscriptionStateEnum>;
    $like?: LikeFilter;
};
type IncidentResult = {
    /**
     * The process definition ID associated to this incident.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * Incident error type with a defined set of values.
     */
    errorType?: 'UNSPECIFIED' | 'UNKNOWN' | 'IO_MAPPING_ERROR' | 'JOB_NO_RETRIES' | 'EXECUTION_LISTENER_NO_RETRIES' | 'TASK_LISTENER_NO_RETRIES' | 'AD_HOC_SUB_PROCESS_NO_RETRIES' | 'CONDITION_ERROR' | 'EXTRACT_VALUE_ERROR' | 'CALLED_ELEMENT_ERROR' | 'UNHANDLED_ERROR_EVENT' | 'MESSAGE_SIZE_EXCEEDED' | 'CALLED_DECISION_ERROR' | 'DECISION_EVALUATION_ERROR' | 'FORM_NOT_FOUND' | 'RESOURCE_NOT_FOUND';
    /**
     * Error message which describes the error in more detail.
     */
    errorMessage?: string;
    /**
     * The element ID associated to this incident.
     */
    elementId?: ElementId;
    /**
     * Date of incident creation.
     */
    creationTime?: string;
    /**
     * State of this incident with a defined set of values.
     */
    state?: 'ACTIVE' | 'MIGRATED' | 'RESOLVED' | 'PENDING';
    /**
     * The tenant ID of the incident.
     */
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this incident.
     */
    incidentKey?: IncidentKey;
    /**
     * The process definition key associated to this incident.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The process instance key associated to this incident.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * The element instance key associated to this incident.
     */
    elementInstanceKey?: ElementInstanceKey;
    /**
     * The job key, if exists, associated with this incident.
     */
    jobKey?: JobKey;
};
type DecisionDefinitionSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching decision definitions.
     */
    items?: Array<DecisionDefinitionResult>;
};
type DecisionDefinitionResult = {
    /**
     * The DMN ID of the decision definition.
     */
    decisionDefinitionId?: DecisionDefinitionId;
    /**
     * The DMN name of the decision definition.
     */
    name?: string;
    /**
     * The assigned version of the decision definition.
     */
    version?: number;
    /**
     * the DMN ID of the decision requirements graph that the decision definition is part of.
     */
    decisionRequirementsId?: string;
    /**
     * The tenant ID of the decision definition.
     */
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this decision definition.
     */
    decisionDefinitionKey?: DecisionDefinitionKey;
    /**
     * The assigned key of the decision requirements graph that the decision definition is part of.
     */
    decisionRequirementsKey?: DecisionRequirementsKey;
};
type UsageMetricsResponse = UsageMetricsResponseItem & {
    /**
     * The amount of active tenants.
     */
    activeTenants?: number;
    /**
     * The usage metrics by tenants. Only available if request `withTenants` query parameter was `true`.
     */
    tenants?: {
        [key: string]: UsageMetricsResponseItem;
    };
};
type UsageMetricsResponseItem = {
    /**
     * The amount of created root process instances.
     */
    processInstances?: number;
    /**
     * The amount of executed decision instances.
     */
    decisionInstances?: number;
    /**
     * The amount of unique active task users.
     */
    assignees?: number;
};
/**
 * Specifies the type of permissions.
 */
type PermissionTypeEnum = 'ACCESS' | 'CREATE' | 'CREATE_BATCH_OPERATION_CANCEL_PROCESS_INSTANCE' | 'CREATE_BATCH_OPERATION_DELETE_PROCESS_INSTANCE' | 'CREATE_BATCH_OPERATION_MIGRATE_PROCESS_INSTANCE' | 'CREATE_BATCH_OPERATION_MODIFY_PROCESS_INSTANCE' | 'CREATE_BATCH_OPERATION_RESOLVE_INCIDENT' | 'CREATE_BATCH_OPERATION_DELETE_DECISION_INSTANCE' | 'CREATE_BATCH_OPERATION_DELETE_DECISION_DEFINITION' | 'CREATE_BATCH_OPERATION_DELETE_PROCESS_DEFINITION' | 'CREATE_PROCESS_INSTANCE' | 'CREATE_DECISION_INSTANCE' | 'READ' | 'READ_PROCESS_INSTANCE' | 'READ_USER_TASK' | 'READ_DECISION_INSTANCE' | 'READ_PROCESS_DEFINITION' | 'READ_DECISION_DEFINITION' | 'READ_USAGE_METRIC' | 'UPDATE' | 'UPDATE_PROCESS_INSTANCE' | 'UPDATE_USER_TASK' | 'CANCEL_PROCESS_INSTANCE' | 'MODIFY_PROCESS_INSTANCE' | 'DELETE' | 'DELETE_PROCESS' | 'DELETE_DRD' | 'DELETE_FORM' | 'DELETE_RESOURCE' | 'DELETE_PROCESS_INSTANCE' | 'DELETE_DECISION_INSTANCE';
/**
 * The type of resource to add/remove permissions to/from.
 */
type ResourceTypeEnum = 'AUTHORIZATION' | 'MAPPING_RULE' | 'MESSAGE' | 'BATCH' | 'COMPONENT' | 'SYSTEM' | 'TENANT' | 'RESOURCE' | 'PROCESS_DEFINITION' | 'DECISION_REQUIREMENTS_DEFINITION' | 'DECISION_DEFINITION' | 'GROUP' | 'USER' | 'ROLE' | 'DOCUMENT';
/**
 * The type of the owner of permissions.
 */
type OwnerTypeEnum = 'USER' | 'CLIENT' | 'ROLE' | 'GROUP' | 'MAPPING_RULE' | 'UNSPECIFIED';
type AuthorizationRequest = {
    /**
     * The ID of the owner of the permissions.
     */
    ownerId: string;
    ownerType: OwnerTypeEnum;
    /**
     * The ID of the resource to add permissions to.
     */
    resourceId: string;
    /**
     * The type of resource to add permissions to.
     */
    resourceType: ResourceTypeEnum;
    /**
     * The permission types to add.
     */
    permissionTypes: Array<PermissionTypeEnum>;
};
type AuthorizationCreateResult = {
    /**
     * The key of the created authorization.
     */
    authorizationKey?: AuthorizationKey;
};
type AuthorizationSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'ownerId' | 'ownerType' | 'resourceId' | 'resourceType';
    order?: SortOrderEnum;
};
type AuthorizationSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<AuthorizationSearchQuerySortRequest>;
    /**
     * The authorization search filters.
     */
    filter?: AuthorizationFilter;
};
/**
 * Authorization search filter.
 */
type AuthorizationFilter = {
    /**
     * The ID of the owner of permissions.
     */
    ownerId?: string;
    ownerType?: OwnerTypeEnum;
    /**
     * The IDs of the resource to search permissions for.
     */
    resourceIds?: Array<string>;
    /**
     * The type of resource to search permissions for.
     */
    resourceType?: ResourceTypeEnum;
};
type AuthorizationResult = {
    /**
     * The ID of the owner of permissions.
     */
    ownerId?: string;
    ownerType?: OwnerTypeEnum;
    /**
     * The type of resource that the permissions relate to.
     */
    resourceType?: ResourceTypeEnum;
    /**
     * ID of the resource the permission relates to.
     */
    resourceId?: string;
    /**
     * Specifies the types of the permissions.
     */
    permissionTypes?: Array<PermissionTypeEnum>;
    /**
     * The key of the authorization.
     */
    authorizationKey?: AuthorizationKey;
};
type AuthorizationSearchResult = SearchQueryResponse & {
    /**
     * The matching authorizations.
     */
    items?: Array<AuthorizationResult>;
};
type UserRequest = {
    /**
     * The password of the user.
     */
    password: string;
    /**
     * The username of the user.
     */
    username: string;
    /**
     * The name of the user.
     */
    name?: string;
    /**
     * The email of the user.
     */
    email?: string;
};
type UserCreateResult = {
    username?: Username;
    /**
     * The name of the user.
     */
    name?: string;
    /**
     * The email of the user.
     */
    email?: string;
};
type UserUpdateResult = {
    username?: Username;
    /**
     * The name of the user.
     */
    name?: string;
    /**
     * The email of the user.
     */
    email?: string;
};
type UserSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'username' | 'name' | 'email';
    order?: SortOrderEnum;
};
type UserSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<UserSearchQuerySortRequest>;
    /**
     * The user search filters.
     */
    filter?: UserFilter;
};
type MappingRuleSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'mappingRuleId' | 'claimName' | 'claimValue' | 'name';
    order?: SortOrderEnum;
};
type MappingRuleSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<MappingRuleSearchQuerySortRequest>;
    /**
     * The mapping rule search filters.
     */
    filter?: MappingRuleFilter;
};
/**
 * User search filter.
 */
type UserFilter = {
    /**
     * The username of the user.
     */
    username?: StringFilterProperty;
    /**
     * The name of the user.
     */
    name?: StringFilterProperty;
    /**
     * The email of the user.
     */
    email?: StringFilterProperty;
};
/**
 * Mapping rule search filter.
 */
type MappingRuleFilter = {
    /**
     * The claim name to match against a token.
     */
    claimName?: string;
    /**
     * The value of the claim to match.
     */
    claimValue?: string;
    /**
     * The name of the mapping rule.
     */
    name?: string;
    /**
     * The ID of the mapping rule.
     */
    mappingRuleId?: string;
};
type CamundaUserResult = {
    /**
     * The username of the user.
     */
    username?: Username | null;
    /**
     * The display name of the user.
     */
    displayName?: string | null;
    /**
     * The email of the user.
     */
    email?: string | null;
    /**
     * The web components the user is authorized to use.
     */
    authorizedComponents?: Array<string>;
    /**
     * The tenants the user is a member of.
     */
    tenants: Array<TenantResult>;
    /**
     * The groups assigned to the user.
     */
    groups: Array<string>;
    /**
     * The roles assigned to the user.
     */
    roles: Array<string>;
    /**
     * The plan of the user.
     */
    salesPlanType: string;
    /**
     * The links to the components in the C8 stack.
     */
    c8Links: {
        [key: string]: string;
    };
    /**
     * Flag for understanding if the user is able to perform logout.
     */
    canLogout: boolean;
};
type UserResult = {
    username?: Username;
    /**
     * The name of the user.
     */
    name?: string;
    /**
     * The email of the user.
     */
    email?: string;
};
type UserSearchResult = SearchQueryResponse & {
    /**
     * The matching users.
     */
    items: Array<UserResult>;
};
type UserUpdateRequest = {
    /**
     * The password of the user. If blank, the password is unchanged.
     */
    password?: string;
    /**
     * The name of the user.
     */
    name?: string;
    /**
     * The email of the user.
     */
    email?: string;
};
type TenantClientResult = {
    /**
     * The ID of the client.
     */
    clientId?: string;
};
type TenantClientSearchResult = SearchQueryResponse & {
    /**
     * The matching clients.
     */
    items?: Array<TenantClientResult>;
};
type TenantClientSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<TenantClientSearchQuerySortRequest>;
};
type TenantClientSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'clientId';
    order?: SortOrderEnum;
};
type TenantUserResult = {
    username?: Username;
};
type TenantUserSearchResult = SearchQueryResponse & {
    /**
     * The matching users.
     */
    items?: Array<TenantUserResult>;
};
type TenantUserSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<TenantUserSearchQuerySortRequest>;
};
type TenantUserSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'username';
    order?: SortOrderEnum;
};
type TenantGroupResult = {
    /**
     * The groupId of the group.
     */
    groupId?: string;
};
type TenantGroupSearchResult = SearchQueryResponse & {
    /**
     * The matching groups.
     */
    items?: Array<TenantGroupResult>;
};
type TenantGroupSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<TenantGroupSearchQuerySortRequest>;
};
type TenantGroupSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'groupId';
    order?: SortOrderEnum;
};
type RoleCreateRequest = {
    /**
     * The ID of the new role.
     */
    roleId: string;
    /**
     * The display name of the new role.
     */
    name: string;
    /**
     * The description of the new role.
     */
    description?: string;
};
type RoleCreateResult = {
    /**
     * The ID of the created role.
     */
    roleId?: string;
    /**
     * The display name of the created role.
     */
    name?: string;
    /**
     * The description of the created role.
     */
    description?: string;
};
type RoleUpdateRequest = {
    /**
     * The display name of the new role.
     */
    name: string;
    /**
     * The description of the new role.
     */
    description: string;
};
type RoleUpdateResult = {
    /**
     * The display name of the updated role.
     */
    name?: string;
    /**
     * The description of the updated role.
     */
    description?: string;
    /**
     * The ID of the updated role.
     */
    roleId?: string;
};
/**
 * Role search response item.
 */
type RoleResult = {
    /**
     * The role name.
     */
    name?: string;
    /**
     * The role id.
     */
    roleId?: string;
    /**
     * The description of the role.
     */
    description?: string;
};
type RoleSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'name' | 'roleId';
    order?: SortOrderEnum;
};
/**
 * Role search request.
 */
type RoleSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<RoleSearchQuerySortRequest>;
    /**
     * The role search filters.
     */
    filter?: RoleFilter;
};
/**
 * Role filter request
 */
type RoleFilter = {
    /**
     * The role ID search filters.
     */
    roleId?: string;
    /**
     * The role name search filters.
     */
    name?: string;
};
/**
 * Role search response.
 */
type RoleSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching roles.
     */
    items?: Array<RoleResult>;
};
type RoleUserResult = {
    username?: Username;
};
type RoleUserSearchResult = SearchQueryResponse & {
    /**
     * The matching users.
     */
    items?: Array<RoleUserResult>;
};
type RoleUserSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<RoleUserSearchQuerySortRequest>;
};
type RoleUserSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'username';
    order?: SortOrderEnum;
};
type RoleClientResult = {
    /**
     * The ID of the client.
     */
    clientId?: string;
};
type RoleClientSearchResult = SearchQueryResponse & {
    /**
     * The matching clients.
     */
    items?: Array<RoleClientResult>;
};
type RoleClientSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<RoleClientSearchQuerySortRequest>;
};
type RoleClientSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'clientId';
    order?: SortOrderEnum;
};
type RoleGroupResult = {
    /**
     * The id of the group.
     */
    groupId?: string;
};
type RoleGroupSearchResult = SearchQueryResponse & {
    /**
     * The matching groups.
     */
    items?: Array<RoleGroupResult>;
};
type RoleGroupSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<RoleGroupSearchQuerySortRequest>;
};
type RoleGroupSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'groupId';
    order?: SortOrderEnum;
};
type GroupCreateRequest = {
    /**
     * The ID of the new group.
     */
    groupId: string;
    /**
     * The display name of the new group.
     */
    name: string;
    /**
     * The description of the new group.
     */
    description?: string;
};
type GroupCreateResult = {
    /**
     * The ID of the created group.
     */
    groupId?: string;
    /**
     * The display name of the created group.
     */
    name?: string;
    /**
     * The description of the created group.
     */
    description?: string;
};
type GroupUpdateRequest = {
    /**
     * The new name of the group.
     */
    name: string;
    /**
     * The new description of the group.
     */
    description: string;
};
type GroupUpdateResult = {
    /**
     * The unique external group ID.
     */
    groupId?: string;
    /**
     * The name of the group.
     */
    name?: string;
    /**
     * The description of the group.
     */
    description?: string;
};
/**
 * Group search response item.
 */
type GroupResult = {
    /**
     * The group name.
     */
    name?: string;
    /**
     * The group ID.
     */
    groupId?: string;
    /**
     * The group description.
     */
    description?: string;
};
type GroupSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'name' | 'groupId';
    order?: SortOrderEnum;
};
/**
 * Group search request.
 */
type GroupSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<GroupSearchQuerySortRequest>;
    /**
     * The group search filters.
     */
    filter?: GroupFilter;
};
/**
 * Group filter request
 */
type GroupFilter = {
    /**
     * The group ID search filters.
     */
    groupId?: StringFilterProperty;
    /**
     * The group name search filters.
     */
    name?: string;
};
/**
 * Group search response.
 */
type GroupSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching groups.
     */
    items?: Array<GroupResult>;
};
type GroupUserResult = {
    username?: Username;
};
type GroupUserSearchResult = SearchQueryResponse & {
    /**
     * The matching members.
     */
    items?: Array<GroupUserResult>;
};
type GroupUserSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<GroupUserSearchQuerySortRequest>;
};
type GroupUserSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'username';
    order?: SortOrderEnum;
};
type GroupClientResult = {
    /**
     * The ID of the client.
     */
    clientId?: string;
};
type GroupClientSearchResult = SearchQueryResponse & {
    /**
     * The matching client IDs.
     */
    items?: Array<GroupClientResult>;
};
type GroupClientSearchQueryRequest = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<GroupClientSearchQuerySortRequest>;
};
type GroupClientSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'clientId';
    order?: SortOrderEnum;
};
type MappingRuleCreateUpdateRequest = {
    /**
     * The name of the claim to map.
     */
    claimName: string;
    /**
     * The value of the claim to map.
     */
    claimValue: string;
    /**
     * The name of the mapping rule.
     */
    name: string;
};
type MappingRuleCreateRequest = MappingRuleCreateUpdateRequest & {
    /**
     * The unique ID of the mapping rule.
     */
    mappingRuleId: string;
};
type MappingRuleUpdateRequest = MappingRuleCreateUpdateRequest;
type MappingRuleCreateUpdateResult = {
    /**
     * The name of the claim to map.
     */
    claimName?: string;
    /**
     * The value of the claim to map.
     */
    claimValue?: string;
    /**
     * The name of the mapping rule.
     */
    name?: string;
    /**
     * The unique ID of the mapping rule.
     */
    mappingRuleId?: string;
};
type MappingRuleCreateResult = MappingRuleCreateUpdateResult;
type MappingRuleUpdateResult = MappingRuleCreateUpdateResult;
type MappingRuleSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching mapping rules.
     */
    items?: Array<MappingRuleResult>;
};
type MappingRuleResult = {
    /**
     * The name of the claim to map.
     */
    claimName?: string;
    /**
     * The value of the claim to map.
     */
    claimValue?: string;
    /**
     * The name of the mapping rule.
     */
    name?: string;
    /**
     * The ID of the mapping rule.
     */
    mappingRuleId?: string;
};
/**
 * The response of a topology request.
 */
type TopologyResponse = {
    /**
     * A list of brokers that are part of this cluster.
     */
    brokers: Array<BrokerInfo>;
    /**
     * The number of brokers in the cluster.
     */
    clusterSize: number;
    /**
     * The number of partitions are spread across the cluster.
     */
    partitionsCount: number;
    /**
     * The configured replication factor for this cluster.
     */
    replicationFactor: number;
    /**
     * The version of the Zeebe Gateway.
     */
    gatewayVersion: string;
    /**
     * ID of the last completed change
     */
    lastCompletedChangeId: string;
};
/**
 * The response of a license request.
 */
type LicenseResponse = {
    /**
     * True if the Camunda license is valid, false if otherwise
     */
    validLicense: boolean;
    /**
     * Will return the license type property of the Camunda license
     */
    licenseType: string;
    /**
     * Will be false when a license contains a non-commerical=true property
     */
    isCommercial: boolean;
    /**
     * The date when the Camunda license expires
     */
    expiresAt?: string | null;
};
/**
 * Provides information on a broker node.
 */
type BrokerInfo = {
    /**
     * The unique (within a cluster) node ID for the broker.
     */
    nodeId: number;
    /**
     * The hostname for reaching the broker.
     */
    host: string;
    /**
     * The port for reaching the broker.
     */
    port: number;
    /**
     * A list of partitions managed or replicated on this broker.
     */
    partitions: Array<Partition>;
    /**
     * The broker version.
     */
    version: string;
};
/**
 * Provides information on a partition within a broker node.
 */
type Partition = {
    /**
     * The unique ID of this partition.
     */
    partitionId: number;
    /**
     * Describes the Raft role of the broker for a given partition.
     */
    role: 'leader' | 'follower' | 'inactive';
    /**
     * Describes the current health of the partition.
     */
    health: 'healthy' | 'unhealthy' | 'dead';
};
type UserTaskCompletionRequest = {
    /**
     * The variables to complete the user task with.
     */
    variables?: {
        [key: string]: unknown;
    } | null;
    /**
     * A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "complete".
     *
     */
    action?: string | null;
};
type UserTaskAssignmentRequest = {
    /**
     * The assignee for the user task. The assignee must not be empty or `null`.
     */
    assignee: string;
    /**
     * By default, the task is reassigned if it was already assigned. Set this to `false` to return an error in such cases. The task must then first be unassigned to be assigned again. Use this when you have users picking from group task queues to prevent race conditions.
     *
     */
    allowOverride?: boolean | null;
    /**
     * A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "assign".
     *
     */
    action?: string | null;
};
type UserTaskUpdateRequest = {
    changeset?: Changeset;
    /**
     * A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "update".
     *
     */
    action?: string | null;
};
/**
 * JSON object with changed task attribute values.
 *
 * The following attributes can be adjusted with this endpoint, additional attributes
 * will be ignored:
 *
 * * `candidateGroups` - reset by providing an empty list
 * * `candidateUsers` - reset by providing an empty list
 * * `dueDate` - reset by providing an empty String
 * * `followUpDate` - reset by providing an empty String
 * * `priority` - minimum 0, maximum 100, default 50
 *
 * Providing any of those attributes with a `null` value or omitting it preserves
 * the persisted attribute's value.
 *
 * The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
 * This ensures correct event emission for assignee changes.
 *
 */
type Changeset = {
    /**
     * The due date of the task. Reset by providing an empty String.
     */
    dueDate?: string | null;
    /**
     * The follow-up date of the task. Reset by providing an empty String.
     */
    followUpDate?: string | null;
    /**
     * The list of candidate users of the task. Reset by providing an empty list.
     */
    candidateUsers?: Array<string> | null;
    /**
     * The list of candidate groups of the task. Reset by providing an empty list.
     */
    candidateGroups?: Array<string> | null;
    /**
     * The priority of the task.
     */
    priority?: number | null;
    [key: string]: unknown | (string | null) | (string | null) | (Array<string> | null) | (Array<string> | null) | (number | null) | undefined;
} | null;
type ClockPinRequest = {
    /**
     * The exact time in epoch milliseconds to which the clock should be pinned.
     */
    timestamp: number;
};
type JobActivationRequest = {
    /**
     * The job type, as defined in the BPMN process (e.g. <zeebe:taskDefinition type="payment-service" />).
     *
     */
    type: string;
    /**
     * The name of the worker activating the jobs, mostly used for logging purposes.
     */
    worker?: string;
    /**
     * A job returned after this call will not be activated by another call until the timeout (in ms) has been reached.
     *
     */
    timeout: number;
    /**
     * The maximum jobs to activate by this request.
     */
    maxJobsToActivate: number;
    /**
     * A list of variables to fetch as the job variables; if empty, all visible variables at the time of activation for the scope of the job will be returned.
     *
     */
    fetchVariable?: Array<string>;
    /**
     * The request will be completed when at least one job is activated or after the requestTimeout (in ms). If the requestTimeout = 0, a default timeout is used. If the requestTimeout < 0, long polling is disabled and the request is completed immediately, even when no job is activated.
     *
     */
    requestTimeout?: number;
    /**
     * A list of IDs of tenants for which to activate jobs.
     */
    tenantIds?: Array<TenantId>;
};
/**
 * The list of activated jobs
 */
type JobActivationResult = {
    /**
     * The activated jobs.
     */
    jobs: Array<ActivatedJobResult>;
};
type ActivatedJobResult = {
    /**
     * The type of the job (should match what was requested).
     */
    type: string;
    /**
     * The bpmn process ID of the job's process definition.
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * The version of the job's process definition.
     */
    processDefinitionVersion: number;
    /**
     * The associated task element ID.
     */
    elementId: ElementId;
    /**
     * A set of custom headers defined during modelling; returned as a serialized JSON document.
     */
    customHeaders: {
        [key: string]: unknown;
    };
    /**
     * The name of the worker which activated this job.
     */
    worker: string;
    /**
     * The amount of retries left to this job (should always be positive).
     */
    retries: number;
    /**
     * When the job can be activated again, sent as a UNIX epoch timestamp.
     */
    deadline: number;
    /**
     * All variables visible to the task scope, computed at activation time.
     */
    variables: {
        [key: string]: unknown;
    };
    /**
     * The ID of the tenant that owns the job.
     */
    tenantId: TenantId;
    /**
     * The key, a unique identifier for the job.
     */
    jobKey: JobKey;
    /**
     * The job's process instance key.
     */
    processInstanceKey: ProcessInstanceKey;
    /**
     * The key of the job's process definition.
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * The unique key identifying the associated task, unique within the scope of the process instance.
     *
     */
    elementInstanceKey: ElementInstanceKey;
    kind: JobKindEnum;
    listenerEventType: JobListenerEventTypeEnum;
    userTask?: UserTaskProperties;
    tags?: TagSet;
};
/**
 * Contains properties of a user task.
 */
type UserTaskProperties = {
    /**
     * The action performed on the user task.
     */
    action?: string;
    /**
     * The user assigned to the task.
     */
    assignee?: string | null;
    /**
     * The groups eligible to claim the task.
     */
    candidateGroups?: Array<string>;
    /**
     * The users eligible to claim the task.
     */
    candidateUsers?: Array<string>;
    /**
     * The attributes that were changed in the task.
     */
    changedAttributes?: Array<string>;
    /**
     * The due date of the user task in ISO 8601 format.
     */
    dueDate?: string | null;
    /**
     * The follow-up date of the user task in ISO 8601 format.
     */
    followUpDate?: string | null;
    /**
     * The key of the form associated with the user task.
     */
    formKey?: FormKey;
    /**
     * The priority of the user task.
     */
    priority?: number | null;
    /**
     * The unique key identifying the user task.
     */
    userTaskKey?: UserTaskKey | null;
};
type JobFailRequest = {
    /**
     * The amount of retries the job should have left
     *
     */
    retries?: number;
    /**
     * An optional message describing why the job failed. This is particularly useful if a job runs out of retries and an incident is raised, as this message can help explain why an incident was raised.
     *
     */
    errorMessage?: string;
    /**
     * The backoff timeout (in ms) for the next retry.
     *
     */
    retryBackOff?: number;
    /**
     * JSON object that will instantiate the variables at the local scope of the job's associated task.
     *
     */
    variables?: {
        [key: string]: unknown;
    };
};
type JobErrorRequest = {
    /**
     * The error code that will be matched with an error catch event.
     *
     */
    errorCode: string;
    /**
     * An error message that provides additional context.
     *
     */
    errorMessage?: string | null;
    /**
     * JSON object that will instantiate the variables at the local scope of the error catch event that catches the thrown error.
     *
     */
    variables?: {
        [key: string]: unknown;
    } | null;
};
type JobCompletionRequest = {
    /**
     * The variables to complete the job with.
     */
    variables?: {
        [key: string]: unknown;
    } | null;
    result?: JobResult;
};
type JobResult = (({
    type: 'userTask';
} & JobResultUserTask) | ({
    type: 'adHocSubProcess';
} & JobResultAdHocSubProcess)) & {
    /**
     * Used to distinguish between different types of job results.
     */
    type: 'userTask' | 'adHocSubProcess';
};
type JobResultUserTask = {
    /**
     * Indicates whether the worker denies the work, i.e. explicitly doesn't approve it. For example, a user task listener can deny the completion of a task by setting this flag to true. In this example, the completion of a task is represented by a job that the worker can complete as denied. As a result, the completion request is rejected and the task remains active. Defaults to false.
     *
     */
    denied?: boolean | null;
    /**
     * The reason provided by the user task listener for denying the work.
     */
    deniedReason?: string | null;
    corrections?: JobResultCorrections;
} | null;
/**
 * JSON object with attributes that were corrected by the worker.
 *
 * The following attributes can be corrected, additional attributes will be ignored:
 *
 * * `assignee` - clear by providing an empty String
 * * `dueDate` - clear by providing an empty String
 * * `followUpDate` - clear by providing an empty String
 * * `candidateGroups` - clear by providing an empty list
 * * `candidateUsers` - clear by providing an empty list
 * * `priority` - minimum 0, maximum 100, default 50
 *
 * Providing any of those attributes with a `null` value or omitting it preserves
 * the persisted attribute's value.
 *
 */
type JobResultCorrections = {
    /**
     * Assignee of the task.
     */
    assignee?: string | null;
    /**
     * The due date of the task.
     */
    dueDate?: string | null;
    /**
     * The follow-up date of the task.
     */
    followUpDate?: string | null;
    /**
     * The list of candidate users of the task.
     */
    candidateUsers?: Array<string> | null;
    /**
     * The list of candidate groups of the task.
     */
    candidateGroups?: Array<string> | null;
    /**
     * The priority of the task.
     */
    priority?: number | null;
} | null;
type JobResultAdHocSubProcess = {
    /**
     * Indicates which elements need to be activated in the ad-hoc subprocess.
     */
    activateElements?: Array<JobResultActivateElement>;
    /**
     * Indicates whether the completion condition of the ad-hoc subprocess is fulfilled.
     */
    isCompletionConditionFulfilled?: boolean;
    /**
     * Indicates whether the remaining instances of the ad-hoc subprocess should be canceled.
     */
    isCancelRemainingInstances?: boolean;
} | null;
type JobResultActivateElement = {
    /**
     * The ID of the element to activate.
     */
    elementId?: ElementId;
    /**
     * JSON document that will create the variables on the scope of the activated element.
     * It must be a JSON object, as variables will be mapped in a key-value fashion.
     *
     */
    variables?: {
        [key: string]: unknown;
    } | null;
};
type JobUpdateRequest = {
    changeset: JobChangeset;
    operationReference?: OperationReference;
};
/**
 * JSON object with changed job attribute values.
 *
 * The following attributes can be adjusted with this endpoint, additional attributes
 * will be ignored:
 *
 * * `retries` - The new amount of retries for the job; must be a positive number.
 * * `timeout` - The duration of the new timeout in ms, starting from the current moment.
 *
 * Providing any of those attributes with a null value or omitting it preserves the persisted attributes value.
 *
 * The job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.
 *
 */
type JobChangeset = {
    /**
     * The new amount of retries for the job; must be a positive number.
     */
    retries?: number | null;
    /**
     * The duration of the new timeout in ms, starting from the current moment.
     */
    timeout?: number | null;
};
/**
 * Job search request.
 */
type JobSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<JobSearchQuerySortRequest>;
    /**
     * The job search filters.
     */
    filter?: JobFilter;
};
type JobSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'deadline' | 'deniedReason' | 'elementId' | 'elementInstanceKey' | 'endTime' | 'errorCode' | 'errorMessage' | 'hasFailedWithRetriesLeft' | 'isDenied' | 'jobKey' | 'kind' | 'listenerEventType' | 'processDefinitionId' | 'processDefinitionKey' | 'processInstanceKey' | 'retries' | 'state' | 'tenantId' | 'type' | 'worker';
    order?: SortOrderEnum;
};
/**
 * Job search filter.
 */
type JobFilter = {
    /**
     * When the job can next be activated.
     */
    deadline?: DateTimeFilterProperty | null;
    /**
     * The reason provided by the user task listener for denying the work.
     */
    deniedReason?: StringFilterProperty;
    /**
     * The element ID associated with the job.
     */
    elementId?: StringFilterProperty;
    /**
     * The element instance key associated with the job.
     */
    elementInstanceKey?: ElementInstanceKeyFilterProperty;
    /**
     * When the job ended.
     */
    endTime?: DateTimeFilterProperty;
    /**
     * The error code provided for the failed job.
     */
    errorCode?: StringFilterProperty;
    /**
     * The error message that provides additional context for a failed job.
     */
    errorMessage?: StringFilterProperty;
    /**
     * Indicates whether the job has failed with retries left.
     */
    hasFailedWithRetriesLeft?: boolean;
    /**
     * Indicates whether the user task listener denies the work.
     */
    isDenied?: boolean | null;
    /**
     * The key, a unique identifier for the job.
     */
    jobKey?: JobKeyFilterProperty;
    /**
     * The kind of the job.
     */
    kind?: JobKindFilterProperty;
    /**
     * The listener event type of the job.
     */
    listenerEventType?: JobListenerEventTypeFilterProperty;
    /**
     * The process definition ID associated with the job.
     */
    processDefinitionId?: StringFilterProperty;
    /**
     * The process definition key associated with the job.
     */
    processDefinitionKey?: ProcessDefinitionKeyFilterProperty;
    /**
     * The process instance key associated with the job.
     */
    processInstanceKey?: ProcessInstanceKeyFilterProperty;
    /**
     * The number of retries left.
     */
    retries?: IntegerFilterProperty;
    /**
     * The state of the job.
     */
    state?: JobStateFilterProperty;
    /**
     * The tenant ID.
     */
    tenantId?: StringFilterProperty;
    /**
     * The type of the job.
     */
    type?: StringFilterProperty;
    /**
     * The name of the worker for this job.
     */
    worker?: StringFilterProperty;
};
/**
 * Job search response.
 */
type JobSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching jobs.
     */
    items: Array<JobSearchResult>;
};
type JobSearchResult = {
    /**
     * A set of custom headers defined during modelling.
     */
    customHeaders: {
        [key: string]: string;
    };
    /**
     * If the job has been activated, when it will next be available to be activated.
     */
    deadline?: string | null;
    /**
     * The reason provided by the user task listener for denying the work.
     */
    deniedReason?: string | null;
    /**
     * The element ID associated with the job.
     */
    elementId: ElementId;
    /**
     * The element instance key associated with the job.
     */
    elementInstanceKey: ElementInstanceKey;
    /**
     * When the job ended.
     */
    endTime?: string;
    /**
     * The error code provided for a failed job.
     */
    errorCode?: string | null;
    /**
     * The error message that provides additional context for a failed job.
     */
    errorMessage?: string | null;
    /**
     * Indicates whether the job has failed with retries left.
     */
    hasFailedWithRetriesLeft?: boolean;
    /**
     * Indicates whether the user task listener denies the work.
     */
    isDenied?: boolean | null;
    /**
     * The key, a unique identifier for the job.
     */
    jobKey: JobKey;
    kind: JobKindEnum;
    listenerEventType: JobListenerEventTypeEnum;
    /**
     * The process definition ID associated with the job.
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * The process definition key associated with the job.
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * The process instance key associated with the job.
     */
    processInstanceKey: ProcessInstanceKey;
    /**
     * The amount of retries left to this job.
     */
    retries: number;
    state: JobStateEnum;
    tenantId: TenantId;
    /**
     * The type of the job.
     */
    type: string;
    /**
     * The name of the worker of this job.
     */
    worker: string;
};
/**
 * The state of the job.
 */
type JobStateEnum = 'CANCELED' | 'COMPLETED' | 'CREATED' | 'ERROR_THROWN' | 'FAILED' | 'MIGRATED' | 'RETRIES_UPDATED' | 'TIMED_OUT';
/**
 * The job kind.
 */
type JobKindEnum = 'BPMN_ELEMENT' | 'EXECUTION_LISTENER' | 'TASK_LISTENER' | 'AD_HOC_SUB_PROCESS';
/**
 * The listener event type of the job.
 */
type JobListenerEventTypeEnum = 'ASSIGNING' | 'CANCELING' | 'COMPLETING' | 'CREATING' | 'END' | 'START' | 'UNSPECIFIED' | 'UPDATING';
/**
 * JobStateEnum property with full advanced search capabilities.
 */
type JobStateFilterProperty = JobStateEnum | AdvancedJobStateFilter;
/**
 * Advanced filter
 * Advanced JobStateEnum filter.
 */
type AdvancedJobStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: JobStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: JobStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<JobStateEnum>;
    $like?: LikeFilter;
};
/**
 * JobKindEnum property with full advanced search capabilities.
 */
type JobKindFilterProperty = JobKindEnum | AdvancedJobKindFilter;
/**
 * Advanced filter
 * Advanced JobKindEnum filter.
 */
type AdvancedJobKindFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: JobKindEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: JobKindEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<JobKindEnum>;
    $like?: LikeFilter;
};
/**
 * JobListenerEventTypeEnum property with full advanced search capabilities.
 */
type JobListenerEventTypeFilterProperty = JobListenerEventTypeEnum | AdvancedJobListenerEventTypeFilter;
/**
 * Advanced filter
 * Advanced JobListenerEventTypeEnum filter.
 */
type AdvancedJobListenerEventTypeFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: JobListenerEventTypeEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: JobListenerEventTypeEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<JobListenerEventTypeEnum>;
    $like?: LikeFilter;
};
/**
 * A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
 *
 */
type ProblemDetail = {
    /**
     * A URI identifying the problem type.
     */
    type?: string;
    /**
     * A summary of the problem type.
     */
    title?: string;
    /**
     * The HTTP status code for this problem.
     */
    status?: number;
    /**
     * An explanation of the problem in more detail.
     */
    detail?: string;
    /**
     * A URI path identifying the origin of the problem.
     */
    instance?: string;
};
type SearchQueryRequest = {
    /**
     * Pagination criteria.
     */
    page?: SearchQueryPageRequest;
};
/**
 * Pagination criteria. Can use offset-based pagination (from/limit) OR cursor-based pagination (after/before + limit), but not both.
 */
type SearchQueryPageRequest = OffsetPagination | CursorForwardPagination | CursorBackwardPagination;
/**
 * Offset-based pagination
 */
type OffsetPagination = {
    /**
     * The index of items to start searching from.
     */
    from?: number;
    /**
     * The maximum number of items to return in one request.
     */
    limit?: number;
};
/**
 * Cursor-based forward pagination
 */
type CursorForwardPagination = {
    /**
     * Use the `endCursor` value from the previous response to fetch the next page of results.
     */
    after: EndCursor;
    /**
     * The maximum number of items to return in one request.
     */
    limit?: number;
};
/**
 * Cursor-based backward pagination
 */
type CursorBackwardPagination = {
    /**
     * Use the `startCursor` value from the previous response to fetch the previous page of results.
     */
    before: StartCursor;
    /**
     * The maximum number of items to return in one request.
     */
    limit?: number;
};
type SearchQueryResponse = {
    /**
     * Pagination information about the search results.
     */
    page: SearchQueryPageResponse;
};
/**
 * Pagination information about the search results.
 */
type SearchQueryPageResponse = {
    /**
     * Total items matching the criteria.
     */
    totalItems: number;
    /**
     * Indicates if more results exist beyond the reported totalItems value. Due to system limitations, the totalItems value can be capped.
     *
     */
    hasMoreTotalItems?: boolean;
    /**
     * The cursor value for getting the previous page of results. Use this in the `before` field of an ensuing request.
     */
    startCursor?: StartCursor;
    /**
     * The cursor value for getting the next page of results. Use this in the `after` field of an ensuing request.
     */
    endCursor?: EndCursor;
};
type DecisionRequirementsSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'decisionRequirementsKey' | 'decisionRequirementsName' | 'version' | 'decisionRequirementsId' | 'tenantId';
    order?: SortOrderEnum;
};
type DecisionRequirementsSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<DecisionRequirementsSearchQuerySortRequest>;
    /**
     * The decision definition search filters.
     */
    filter?: DecisionRequirementsFilter;
};
/**
 * Decision requirements search filter.
 */
type DecisionRequirementsFilter = {
    /**
     * The DMN name of the decision requirements.
     */
    decisionRequirementsName?: string;
    /**
     * The assigned version of the decision requirements.
     */
    version?: number;
    /**
     * the DMN ID of the decision requirements.
     */
    decisionRequirementsId?: string;
    /**
     * The tenant ID of the decision requirements.
     */
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this decision requirements.
     */
    decisionRequirementsKey?: DecisionRequirementsKey;
    /**
     * The name of the resource from which the decision requirements were parsed.
     */
    resourceName?: string;
};
type DecisionRequirementsSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching decision requirements.
     */
    items?: Array<DecisionRequirementsResult>;
};
type DecisionRequirementsResult = {
    /**
     * The DMN name of the decision requirements.
     */
    decisionRequirementsName?: string;
    /**
     * The assigned version of the decision requirements.
     */
    version?: number;
    /**
     * The DMN ID of the decision requirements.
     */
    decisionRequirementsId?: string;
    /**
     * The name of the resource from which this decision requirements was parsed.
     */
    resourceName?: string;
    /**
     * The tenant ID of the decision requirements.
     */
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this decision requirements.
     */
    decisionRequirementsKey?: DecisionRequirementsKey;
};
type DecisionEvaluationInstruction = DecisionEvaluationById | DecisionEvaluationByKey;
/**
 * Decision evaluation by ID
 */
type DecisionEvaluationById = {
    /**
     * The ID of the decision to be evaluated.
     * When using the decision ID, the latest
     * deployed version of the decision is used.
     *
     */
    decisionDefinitionId: DecisionDefinitionId;
    /**
     * The message variables as JSON document.
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * The tenant ID of the decision.
     */
    tenantId?: TenantId;
};
/**
 * Decision evaluation by key
 */
type DecisionEvaluationByKey = {
    decisionDefinitionKey: DecisionDefinitionKey;
    /**
     * The message variables as JSON document.
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * The tenant ID of the decision.
     */
    tenantId?: TenantId;
};
type EvaluateDecisionResult = {
    /**
     * The ID of the decision which was evaluated.
     */
    decisionDefinitionId: DecisionDefinitionId;
    /**
     * The name of the decision which was evaluated.
     */
    decisionDefinitionName: string;
    /**
     * The version of the decision which was evaluated.
     */
    decisionDefinitionVersion: number;
    /**
     * The ID of the decision requirements graph that the decision which was evaluated is part of.
     */
    decisionRequirementsId: string;
    /**
     * JSON document that will instantiate the result of the decision which was evaluated.
     *
     */
    output: string;
    /**
     * The ID of the decision which failed during evaluation.
     */
    failedDecisionDefinitionId: DecisionDefinitionId;
    /**
     * Message describing why the decision which was evaluated failed.
     */
    failureMessage: string;
    /**
     * The tenant ID of the evaluated decision.
     */
    tenantId: TenantId;
    /**
     * The unique key identifying the decision which was evaluated.
     */
    decisionDefinitionKey: DecisionDefinitionKey;
    /**
     * The unique key identifying the decision requirements graph that the decision which was evaluated is part of.
     */
    decisionRequirementsKey: DecisionRequirementsKey;
    /**
     * Deprecated, please refer to `decisionEvaluationKey`.
     * @deprecated
     */
    decisionInstanceKey?: DecisionInstanceKey;
    /**
     * The unique key identifying this decision evaluation.
     */
    decisionEvaluationKey: DecisionEvaluationKey;
    /**
     * Decisions that were evaluated within the requested decision evaluation.
     */
    evaluatedDecisions: Array<EvaluatedDecisionResult>;
};
/**
 * A decision that was evaluated.
 */
type EvaluatedDecisionResult = {
    /**
     * The ID of the decision which was evaluated.
     */
    decisionDefinitionId?: DecisionDefinitionId;
    /**
     * The name of the decision which was evaluated.
     */
    decisionDefinitionName?: string;
    /**
     * The version of the decision which was evaluated.
     */
    decisionDefinitionVersion?: number;
    /**
     * The type of the decision which was evaluated.
     */
    decisionDefinitionType?: string;
    /**
     * JSON document that will instantiate the result of the decision which was evaluated.
     *
     */
    output?: string;
    /**
     * The tenant ID of the evaluated decision.
     */
    tenantId?: TenantId;
    /**
     * The decision rules that matched within this decision evaluation.
     */
    matchedRules?: Array<MatchedDecisionRuleItem>;
    /**
     * The decision inputs that were evaluated within this decision evaluation.
     */
    evaluatedInputs?: Array<EvaluatedDecisionInputItem>;
    /**
     * The unique key identifying the decision which was evaluate.
     */
    decisionDefinitionKey?: DecisionDefinitionKey;
    /**
     * The unique key identifying this decision evaluation instance.
     */
    decisionEvaluationInstanceKey?: DecisionEvaluationInstanceKey;
};
/**
 * A decision rule that matched within this decision evaluation.
 */
type MatchedDecisionRuleItem = {
    /**
     * The ID of the matched rule.
     */
    ruleId?: string;
    /**
     * The index of the matched rule.
     */
    ruleIndex?: number;
    /**
     * The evaluated decision outputs.
     */
    evaluatedOutputs?: Array<EvaluatedDecisionOutputItem>;
};
/**
 * A decision input that was evaluated within this decision evaluation.
 */
type EvaluatedDecisionInputItem = {
    /**
     * The ID of the evaluated decision input.
     */
    inputId?: string;
    /**
     * The name of the evaluated decision input.
     */
    inputName?: string;
    /**
     * The value of the evaluated decision input.
     */
    inputValue?: string;
};
/**
 * The evaluated decision outputs.
 */
type EvaluatedDecisionOutputItem = {
    /**
     * The ID of the evaluated decision output.
     */
    outputId?: string;
    /**
     * The name of the evaluated decision output.
     */
    outputName?: string;
    /**
     * The value of the evaluated decision output.
     */
    outputValue?: string;
};
type DecisionInstanceSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'decisionDefinitionId' | 'decisionDefinitionKey' | 'decisionDefinitionName' | 'decisionDefinitionType' | 'decisionDefinitionVersion' | 'decisionEvaluationInstanceKey' | 'decisionEvaluationKey' | 'elementInstanceKey' | 'evaluationDate' | 'evaluationFailure' | 'processDefinitionKey' | 'processInstanceKey' | 'state' | 'tenantId';
    order?: SortOrderEnum;
};
type DecisionInstanceSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<DecisionInstanceSearchQuerySortRequest>;
    /**
     * The decision instance search filters.
     */
    filter?: DecisionInstanceFilter;
};
/**
 * Decision instance search filter.
 */
type DecisionInstanceFilter = {
    decisionEvaluationInstanceKey?: DecisionEvaluationInstanceKey;
    state?: DecisionInstanceStateEnum;
    /**
     * The evaluation failure of the decision instance.
     */
    evaluationFailure?: string;
    /**
     * The evaluation date of the decision instance.
     */
    evaluationDate?: DateTimeFilterProperty;
    /**
     * The ID of the DMN decision.
     */
    decisionDefinitionId?: DecisionDefinitionId;
    /**
     * The name of the DMN decision.
     */
    decisionDefinitionName?: string;
    /**
     * The version of the decision.
     */
    decisionDefinitionVersion?: number;
    decisionDefinitionType?: DecisionDefinitionTypeEnum;
    /**
     * The tenant ID of the decision instance.
     */
    tenantId?: TenantId;
    /**
     * The key of the parent decision evaluation. Note that this is not the identifier of an individual decision instance; the `decisionEvaluationInstanceKey` is the identifier for a decision instance.
     *
     */
    decisionEvaluationKey?: DecisionEvaluationKey;
    /**
     * The key of the process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The key of the process instance.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * The key of the decision.
     */
    decisionDefinitionKey?: DecisionDefinitionKeyFilterProperty;
    /**
     * The key of the element instance this decision instance is linked to.
     */
    elementInstanceKey?: ElementInstanceKeyFilterProperty;
};
type DecisionInstanceSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching decision instances.
     */
    items?: Array<DecisionInstanceResult>;
};
type DecisionInstanceResult = {
    decisionEvaluationInstanceKey?: DecisionEvaluationInstanceKey;
    state?: DecisionInstanceStateEnum;
    /**
     * The evaluation date of the decision instance.
     */
    evaluationDate?: string;
    /**
     * The evaluation failure of the decision instance.
     */
    evaluationFailure?: string;
    /**
     * The ID of the DMN decision.
     */
    decisionDefinitionId?: DecisionDefinitionId;
    /**
     * The name of the DMN decision.
     */
    decisionDefinitionName?: string;
    /**
     * The version of the decision.
     */
    decisionDefinitionVersion?: number;
    decisionDefinitionType?: DecisionDefinitionTypeEnum;
    /**
     * The result of the decision instance.
     */
    result?: string;
    /**
     * The tenant ID of the decision instance.
     */
    tenantId?: TenantId;
    /**
     * The key of the decision evaluation where this instance was created.
     */
    decisionEvaluationKey?: DecisionEvaluationKey;
    /**
     * The key of the process definition.
     */
    processDefinitionKey?: ProcessDefinitionKey;
    /**
     * The key of the process instance.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * The key of the decision.
     */
    decisionDefinitionKey?: DecisionDefinitionKey;
    /**
     * The key of the element instance this decision instance is linked to.
     */
    elementInstanceKey?: ElementInstanceKey;
};
type DecisionInstanceGetQueryResult = DecisionInstanceResult & {
    /**
     * The evaluated inputs of the decision instance.
     *
     */
    evaluatedInputs?: Array<EvaluatedDecisionInputItem>;
    /**
     * The matched rules of the decision instance.
     *
     */
    matchedRules?: Array<MatchedDecisionRuleItem>;
};
/**
 * The type of the decision.
 */
type DecisionDefinitionTypeEnum = 'DECISION_TABLE' | 'LITERAL_EXPRESSION' | 'UNSPECIFIED' | 'UNKNOWN';
/**
 * The state of the decision instance.
 */
type DecisionInstanceStateEnum = 'EVALUATED' | 'FAILED' | 'UNSPECIFIED' | 'UNKNOWN';
/**
 * The order in which to sort the related field.
 */
type SortOrderEnum = 'ASC' | 'DESC';
/**
 * A reference key chosen by the user that will be part of all records resulting from this operation.
 * Must be > 0 if provided.
 *
 */
type OperationReference = number;
type MessageCorrelationRequest = {
    /**
     * The message name as defined in the BPMN process
     *
     */
    name: string;
    /**
     * The correlation key of the message.
     */
    correlationKey?: string;
    /**
     * The message variables as JSON document
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * the tenant for which the message is published
     */
    tenantId?: TenantId;
};
/**
 * The message key of the correlated message, as well as the first process instance key it
 * correlated with.
 *
 */
type MessageCorrelationResult = {
    /**
     * The tenant ID of the correlated message
     */
    tenantId?: TenantId;
    /**
     * The key of the correlated message
     */
    messageKey?: MessageCorrelationKey;
    /**
     * The key of the first process instance the message correlated with
     */
    processInstanceKey?: ProcessInstanceKey;
};
type MessagePublicationRequest = {
    /**
     * The name of the message.
     */
    name: string;
    /**
     * The correlation key of the message.
     */
    correlationKey?: string;
    /**
     * Timespan (in ms) to buffer the message on the broker.
     */
    timeToLive?: number;
    /**
     * The unique ID of the message. This is used to ensure only one message with the given ID
     * will be published during the lifetime of the message (if `timeToLive` is set).
     *
     */
    messageId?: string;
    /**
     * The message variables as JSON document.
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * The tenant of the message sender.
     */
    tenantId?: TenantId;
};
/**
 * The message key of the published message.
 */
type MessagePublicationResult = {
    /**
     * The tenant ID of the message.
     */
    tenantId?: TenantId;
    /**
     * The key of the message
     */
    messageKey?: MessageKey;
};
type DocumentReference = {
    /**
     * Document discriminator. Always set to "camunda".
     */
    'camunda.document.type'?: 'camunda';
    /**
     * The ID of the document store.
     */
    storeId?: string;
    /**
     * The ID of the document.
     */
    documentId?: DocumentId;
    /**
     * The hash of the document.
     */
    contentHash?: string;
    metadata?: DocumentMetadata;
};
type DocumentCreationFailureDetail = {
    /**
     * The name of the file.
     */
    fileName?: string;
    /**
     * The detail of the failure.
     */
    detail?: string;
};
type DocumentCreationBatchResponse = {
    /**
     * Documents that were successfully created.
     */
    createdDocuments?: Array<DocumentReference>;
    /**
     * Documents that failed creation.
     */
    failedDocuments?: Array<DocumentCreationFailureDetail>;
};
/**
 * Information about the document.
 */
type DocumentMetadata = {
    /**
     * The content type of the document.
     */
    contentType?: string;
    /**
     * The name of the file.
     */
    fileName?: string;
    /**
     * The date and time when the document expires.
     */
    expiresAt?: string;
    /**
     * The size of the document in bytes.
     */
    size?: number;
    /**
     * The ID of the process definition that created the document.
     */
    processDefinitionId?: ProcessDefinitionId;
    /**
     * The key of the process instance that created the document.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * Custom properties of the document.
     */
    customProperties?: {
        [key: string]: unknown;
    };
};
type DocumentLinkRequest = {
    /**
     * The time-to-live of the document link in ms.
     */
    timeToLive?: number;
};
type DocumentLink = {
    /**
     * The link to the document.
     */
    url?: string;
    /**
     * The date and time when the link expires.
     */
    expiresAt?: string;
};
type DeploymentResult = {
    /**
     * The tenant ID associated with the deployment.
     */
    tenantId: TenantId;
    /**
     * The unique key identifying the deployment.
     */
    deploymentKey: DeploymentKey;
    /**
     * Items deployed by the request.
     */
    deployments: Array<DeploymentMetadataResult>;
};
type DeploymentMetadataResult = {
    processDefinition?: DeploymentProcessResult;
    decisionDefinition?: DeploymentDecisionResult;
    decisionRequirements?: DeploymentDecisionRequirementsResult;
    form?: DeploymentFormResult;
    resource?: DeploymentResourceResult;
};
/**
 * A deployed process.
 */
type DeploymentProcessResult = {
    /**
     * The bpmn process ID, as parsed during deployment, together with the version forms a
     * unique identifier for a specific process definition.
     *
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * The assigned process version.
     */
    processDefinitionVersion: number;
    /**
     * The resource name from which this process was parsed.
     */
    resourceName: string;
    /**
     * The tenant ID of the deployed process.
     */
    tenantId: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this process.
     */
    processDefinitionKey: ProcessDefinitionKey;
};
/**
 * A deployed decision.
 */
type DeploymentDecisionResult = {
    /**
     * The dmn decision ID, as parsed during deployment, together with the version forms a
     * unique identifier for a specific decision.
     *
     */
    decisionDefinitionId?: DecisionDefinitionId;
    /**
     * The assigned decision version.
     */
    version?: number;
    /**
     * The DMN name of the decision, as parsed during deployment.
     */
    name?: string;
    /**
     * The tenant ID of the deployed decision.
     */
    tenantId?: TenantId;
    /**
     * The dmn ID of the decision requirements graph that this decision is part of, as parsed during deployment.
     *
     */
    decisionRequirementsId?: string;
    /**
     * The assigned decision key, which acts as a unique identifier for this decision.
     *
     */
    decisionDefinitionKey?: DecisionDefinitionKey;
    /**
     * The assigned key of the decision requirements graph that this decision is part of.
     *
     */
    decisionRequirementsKey?: DecisionRequirementsKey;
};
/**
 * Deployed decision requirements.
 */
type DeploymentDecisionRequirementsResult = {
    /**
     * The dmn decision requirements ID, as parsed during deployment; together with the versions forms a unique identifier for a specific decision.
     *
     */
    decisionRequirementsId?: string;
    /**
     * The assigned decision requirements version.
     */
    version?: number;
    /**
     * The DMN name of the decision requirements, as parsed during deployment.
     */
    decisionRequirementsName?: string;
    /**
     * The tenant ID of the deployed decision requirements.
     */
    tenantId?: TenantId;
    /**
     * The resource name from which this decision requirements was parsed.
     */
    resourceName?: string;
    /**
     * The assigned decision requirements key, which acts as a unique identifier for this decision requirements.
     *
     */
    decisionRequirementsKey?: DecisionRequirementsKey;
};
/**
 * A deployed form.
 */
type DeploymentFormResult = {
    /**
     * The form ID, as parsed during deployment, together with the version forms a
     * unique identifier for a specific form.
     *
     */
    formId?: FormId;
    /**
     * The assigned form version.
     */
    version?: number;
    /**
     * The resource name from which this form was parsed.
     */
    resourceName?: string;
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this form.
     */
    formKey?: FormKey;
};
/**
 * A deployed Resource.
 */
type DeploymentResourceResult = {
    /**
     * The resource ID, as parsed during deployment, together with the version forms a
     * unique identifier for a specific form.
     *
     */
    resourceId?: string;
    /**
     * The assigned resource version.
     */
    version?: number;
    /**
     * The resource name from which this resource was parsed.
     */
    resourceName?: string;
    tenantId?: TenantId;
    /**
     * The assigned key, which acts as a unique identifier for this Resource.
     */
    resourceKey?: ResourceKey;
};
type IncidentResolutionRequest = {
    operationReference?: OperationReference;
};
/**
 * Instructions for creating a process instance. The process definition can be specified
 * either by ID or by key.
 *
 */
type ProcessInstanceCreationInstruction = ProcessInstanceCreationInstructionById | ProcessInstanceCreationInstructionByKey;
/**
 * Process creation by ID
 */
type ProcessInstanceCreationInstructionById = {
    /**
     * The BPMN process ID of the process definition to start an instance of.
     *
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * The version of the process. By default, the latest version of the process is used.
     *
     */
    processDefinitionVersion?: number;
    /**
     * JSON object that will instantiate the variables for the root variable scope
     * of the process instance.
     *
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * The tenant ID of the process definition.
     */
    tenantId?: TenantId;
    operationReference?: OperationReference;
    /**
     * List of start instructions. By default, the process instance will start at
     * the start event. If provided, the process instance will apply start instructions
     * after it has been created.
     *
     */
    startInstructions?: Array<ProcessInstanceCreationStartInstruction>;
    /**
     * Runtime instructions (alpha). List of instructions that affect the runtime behavior of
     * the process instance. Refer to specific instruction types for more details.
     *
     * This parameter is an alpha feature and may be subject to change
     * in future releases.
     *
     */
    runtimeInstructions?: Array<ProcessInstanceCreationRuntimeInstruction>;
    /**
     * Wait for the process instance to complete. If the process instance completion does
     * not occur within the requestTimeout, the request will be closed. This can lead to a 504
     * response status. Disabled by default.
     *
     */
    awaitCompletion?: boolean;
    /**
     * List of variables by name to be included in the response when awaitCompletion is set to true.
     * If empty, all visible variables in the root scope will be returned.
     *
     */
    fetchVariables?: Array<string>;
    /**
     * Timeout (in ms) the request waits for the process to complete. By default or
     * when set to 0, the generic request timeout configured in the cluster is applied.
     *
     */
    requestTimeout?: number;
    tags?: TagSet;
};
/**
 * Process creation by key
 */
type ProcessInstanceCreationInstructionByKey = {
    /**
     * The unique key identifying the process definition, for example, returned for a process in the
     * deploy resources endpoint.
     *
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * JSON object that will instantiate the variables for the root variable scope
     * of the process instance.
     *
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * The tenant ID of the process definition.
     */
    tenantId?: TenantId;
    operationReference?: OperationReference;
    /**
     * List of start instructions. By default, the process instance will start at
     * the start event. If provided, the process instance will apply start instructions
     * after it has been created.
     *
     */
    startInstructions?: Array<ProcessInstanceCreationStartInstruction>;
    /**
     * Runtime instructions (alpha). List of instructions that affect the runtime behavior of
     * the process instance. Refer to specific instruction types for more details.
     *
     * This parameter is an alpha feature and may be subject to change
     * in future releases.
     *
     */
    runtimeInstructions?: Array<ProcessInstanceCreationRuntimeInstruction>;
    /**
     * Wait for the process instance to complete. If the process instance completion does
     * not occur within the requestTimeout, the request will be closed. This can lead to a 504
     * response status. Disabled by default.
     *
     */
    awaitCompletion?: boolean;
    /**
     * List of variables by name to be included in the response when awaitCompletion is set to true.
     * If empty, all visible variables in the root scope will be returned.
     *
     */
    fetchVariables?: Array<string>;
    /**
     * Timeout (in ms) the request waits for the process to complete. By default or
     * when set to 0, the generic request timeout configured in the cluster is applied.
     *
     */
    requestTimeout?: number;
    tags?: TagSet;
};
type ProcessInstanceCreationStartInstruction = {
    /**
     * Future extensions might include:
     * - different types of start instructions
     * - ability to set local variables for different flow scopes
     *
     * For now, however, the start instruction is implicitly a "startBeforeElement" instruction
     *
     */
    elementId: ElementId;
};
type ProcessInstanceCreationRuntimeInstruction = ({
    type: 'TERMINATE_PROCESS_INSTANCE';
} & ProcessInstanceCreationTerminateInstruction) & {
    /**
     * The type of the runtime instruction
     */
    type: 'TERMINATE_PROCESS_INSTANCE';
};
/**
 * Terminates the process instance after a specific BPMN element is completed or terminated.
 *
 */
type ProcessInstanceCreationTerminateInstruction = {
    /**
     * The ID of the element that, once completed or terminated, will cause the process to be terminated.
     *
     */
    afterElementId: ElementId;
};
type CreateProcessInstanceResult = {
    /**
     * The BPMN process ID of the process definition which was used to create the process.
     * instance
     *
     */
    processDefinitionId: ProcessDefinitionId;
    /**
     * The version of the process definition which was used to create the process instance.
     *
     */
    processDefinitionVersion: number;
    /**
     * The tenant ID of the created process instance.
     */
    tenantId: TenantId;
    /**
     * All the variables visible in the root scope.
     */
    variables: {
        [key: string]: unknown;
    };
    /**
     * The key of the process definition which was used to create the process instance.
     *
     */
    processDefinitionKey: ProcessDefinitionKey;
    /**
     * The unique identifier of the created process instance; to be used wherever a request
     * needs a process instance key (e.g. CancelProcessInstanceRequest).
     *
     */
    processInstanceKey: ProcessInstanceKey;
    tags?: TagSet;
};
type ProcessInstanceMigrationBatchOperationRequest = {
    filter: ProcessInstanceFilter;
    migrationPlan: ProcessInstanceMigrationBatchOperationPlan;
};
/**
 * The migration instructions describe how to migrate a process instance from one process definition to another.
 *
 */
type ProcessInstanceMigrationBatchOperationPlan = {
    /**
     * Element mappings from the source process instance to the target process instance.
     */
    mappingInstructions: Array<MigrateProcessInstanceMappingInstruction>;
    /**
     * The key of process definition to migrate the process instance to.
     */
    targetProcessDefinitionKey: ProcessDefinitionKey;
};
/**
 * The migration instructions describe how to migrate a process instance from one process definition to another.
 *
 */
type ProcessInstanceMigrationInstruction = {
    /**
     * Element mappings from the source process instance to the target process instance.
     */
    mappingInstructions: Array<MigrateProcessInstanceMappingInstruction>;
    operationReference?: OperationReference;
    /**
     * The key of process definition to migrate the process instance to.
     */
    targetProcessDefinitionKey: ProcessDefinitionKey;
};
/**
 * The mapping instructions describe how to map elements from the source process definition to the target process definition.
 *
 */
type MigrateProcessInstanceMappingInstruction = {
    /**
     * The element ID to migrate from.
     */
    sourceElementId: ElementId;
    /**
     * The element ID to migrate into.
     */
    targetElementId: ElementId;
};
type ProcessInstanceModificationInstruction = {
    operationReference?: OperationReference;
    /**
     * Instructions describing which elements should be activated in which scopes and which variables should be created.
     */
    activateInstructions?: Array<ProcessInstanceModificationActivateInstruction>;
    /**
     * Instructions describing which elements should be terminated.
     */
    terminateInstructions?: Array<ProcessInstanceModificationTerminateInstruction>;
};
/**
 * Instructions describing an element that should be activated.
 */
type ProcessInstanceModificationActivateInstruction = {
    /**
     * The ID of the element that should be activated.
     */
    elementId: ElementId;
    /**
     * Instructions describing which variables should be created.
     */
    variableInstructions?: Array<ModifyProcessInstanceVariableInstruction>;
    /**
     * The key of the ancestor scope the element instance should be created in.
     * Set to -1 to create the new element instance within an existing element instance of the
     * flow scope.
     *
     */
    ancestorElementInstanceKey?: string | ElementInstanceKey;
};
/**
 * Instructions describing which variables should be created.
 */
type ModifyProcessInstanceVariableInstruction = {
    /**
     * JSON document that will instantiate the variables for the root variable scope of the process instance.
     * It must be a JSON object, as variables will be mapped in a key-value fashion.
     *
     */
    variables: {
        [key: string]: unknown;
    };
    /**
     * The ID of the element in which scope the variables should be created.
     * Leave empty to create the variables in the global scope of the process instance
     *
     */
    scopeId?: string;
};
/**
 * Instructions describing which elements should be terminated.
 */
type ProcessInstanceModificationTerminateInstruction = {
    /**
     * The ID of the element that should be terminated.
     */
    elementInstanceKey: ElementInstanceKey;
};
type SetVariableRequest = {
    /**
     * JSON object representing the variables to set in the elements scope.
     */
    variables: {
        [key: string]: unknown;
    };
    /**
     * If set to true, the variables are merged strictly into the local scope (as specified by the `elementInstanceKey`).
     * Otherwise, the variables are propagated to upper scopes and set at the outermost one.
     *
     * Lets consider the following example:
     *
     * There are two scopes '1' and '2'.
     * Scope '1' is the parent scope of '2'. The effective variables of the scopes are:
     * 1 => { "foo" : 2 }
     * 2 => { "bar" : 1 }
     *
     * An update request with elementInstanceKey as '2', variables { "foo" : 5 }, and local set
     * to true leaves scope '1' unchanged and adjusts scope '2' to { "bar" : 1, "foo" 5 }.
     *
     * By default, with local set to false, scope '1' will be { "foo": 5 }
     * and scope '2' will be { "bar" : 1 }.
     *
     */
    local?: boolean;
    operationReference?: OperationReference;
};
type DeleteResourceRequest = {
    operationReference?: OperationReference;
} | null;
type SignalBroadcastRequest = {
    /**
     * The name of the signal to broadcast.
     */
    signalName: string;
    /**
     * The signal variables as a JSON object.
     */
    variables?: {
        [key: string]: unknown;
    };
    /**
     * The ID of the tenant that owns the signal.
     */
    tenantId?: TenantId;
};
type SignalBroadcastResult = {
    /**
     * The tenant ID of the signal that was broadcast.
     */
    tenantId: TenantId;
    /**
     * The unique ID of the signal that was broadcast.
     */
    signalKey: SignalKey;
};
type FormResult = {
    /**
     * The tenant ID of the form.
     */
    tenantId?: TenantId;
    /**
     * The user-provided identifier of the form.
     */
    formId?: FormId;
    /**
     * The form content.
     */
    schema?: {
        [key: string]: unknown;
    };
    /**
     * The version of the the deployed form.
     */
    version?: number;
    /**
     * The assigned key, which acts as a unique identifier for this form.
     */
    formKey?: FormKey;
};
type ResourceResult = {
    /**
     * The resource name from which this resource was parsed.
     */
    resourceName?: string;
    /**
     * The assigned resource version.
     */
    version?: number;
    /**
     * The version tag of this resource.
     */
    versionTag?: string;
    /**
     * The resource ID of this resource.
     */
    resourceId?: string;
    /**
     * The tenant ID of this resource.
     */
    tenantId?: TenantId;
    /**
     * The unique key of this resource.
     */
    resourceKey?: ResourceKey;
};
/**
 * The type of the batch operation.
 */
type BatchOperationTypeEnum = 'CANCEL_PROCESS_INSTANCE' | 'RESOLVE_INCIDENT' | 'MIGRATE_PROCESS_INSTANCE' | 'MODIFY_PROCESS_INSTANCE' | 'DELETE_PROCESS_INSTANCE' | 'ADD_VARIABLE' | 'UPDATE_VARIABLE' | 'DELETE_DECISION_DEFINITION' | 'DELETE_PROCESS_DEFINITION';
/**
 * The created batch operation.
 */
type BatchOperationCreatedResult = {
    /**
     * Key of the batch operation.
     */
    batchOperationKey?: BatchOperationKey;
    batchOperationType?: BatchOperationTypeEnum;
};
type BatchOperationSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'batchOperationKey' | 'operationType' | 'state' | 'startDate' | 'endDate';
    order?: SortOrderEnum;
};
/**
 * Batch operation search request.
 */
type BatchOperationSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<BatchOperationSearchQuerySortRequest>;
    /**
     * The batch operation search filters.
     */
    filter?: BatchOperationFilter;
};
/**
 * Batch operation filter request.
 */
type BatchOperationFilter = {
    /**
     * The key (or operate legacy ID) of the batch operation.
     */
    batchOperationKey?: BasicStringFilterProperty;
    /**
     * The type of the batch operation.
     */
    operationType?: BatchOperationTypeFilterProperty;
    /**
     * The state of the batch operation.
     */
    state?: BatchOperationStateFilterProperty;
};
/**
 * BatchOperationTypeEnum property with full advanced search capabilities.
 */
type BatchOperationTypeFilterProperty = BatchOperationTypeEnum | AdvancedBatchOperationTypeFilter;
/**
 * Advanced filter
 * Advanced BatchOperationTypeEnum filter.
 */
type AdvancedBatchOperationTypeFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: BatchOperationTypeEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: BatchOperationTypeEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<BatchOperationTypeEnum>;
    $like?: LikeFilter;
};
/**
 * BatchOperationStateEnum property with full advanced search capabilities.
 */
type BatchOperationStateFilterProperty = BatchOperationStateEnum | AdvancedBatchOperationStateFilter;
/**
 * Advanced filter
 * Advanced BatchOperationStateEnum filter.
 */
type AdvancedBatchOperationStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: BatchOperationStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: BatchOperationStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<BatchOperationStateEnum>;
    $like?: LikeFilter;
};
/**
 * The batch operation state.
 */
type BatchOperationStateEnum = 'ACTIVE' | 'CANCELED' | 'COMPLETED' | 'CREATED' | 'FAILED' | 'PARTIALLY_COMPLETED' | 'SUSPENDED';
type BatchOperationItemSearchQuerySortRequest = {
    /**
     * The field to sort by.
     */
    field: 'batchOperationKey' | 'itemKey' | 'processInstanceKey' | 'state';
    order?: SortOrderEnum;
};
/**
 * Batch operation item search request.
 */
type BatchOperationItemSearchQuery = SearchQueryRequest & {
    /**
     * Sort field criteria.
     */
    sort?: Array<BatchOperationItemSearchQuerySortRequest>;
    /**
     * The batch operation search filters.
     */
    filter?: BatchOperationItemFilter;
};
/**
 * Batch operation item filter request.
 */
type BatchOperationItemFilter = {
    /**
     * The key (or operate legacy ID) of the batch operation.
     */
    batchOperationKey?: BasicStringFilterProperty;
    /**
     * The key of the item, e.g. a process instance key.
     */
    itemKey?: BasicStringFilterProperty;
    /**
     * The process instance key of the processed item.
     */
    processInstanceKey?: ProcessInstanceKeyFilterProperty;
    /**
     * The state of the batch operation.
     */
    state?: BatchOperationItemStateFilterProperty;
};
/**
 * BatchOperationItemStateEnum property with full advanced search capabilities.
 */
type BatchOperationItemStateFilterProperty = BatchOperationItemStateEnum | AdvancedBatchOperationItemStateFilter;
/**
 * Advanced filter
 * Advanced BatchOperationItemStateEnum filter.
 */
type AdvancedBatchOperationItemStateFilter = {
    /**
     * Checks for equality with the provided value.
     */
    $eq?: BatchOperationItemStateEnum;
    /**
     * Checks for inequality with the provided value.
     */
    $neq?: BatchOperationItemStateEnum;
    /**
     * Checks if the current property exists.
     */
    $exists?: boolean;
    /**
     * Checks if the property matches any of the provided values.
     */
    $in?: Array<BatchOperationItemStateEnum>;
    $like?: LikeFilter;
};
/**
 * The state, one of ACTIVE, COMPLETED, TERMINATED.
 */
type BatchOperationItemStateEnum = 'ACTIVE' | 'COMPLETED' | 'CANCELED' | 'FAILED';
/**
 * The batch operation search query result.
 */
type BatchOperationSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching batch operations.
     */
    items?: Array<BatchOperationResponse>;
};
type BatchOperationResponse = {
    /**
     * Key or (Operate Legacy ID = UUID) of the batch operation.
     */
    batchOperationKey?: BatchOperationKey;
    /**
     * The state of the batch operation.
     */
    state?: 'ACTIVE' | 'CANCELED' | 'COMPLETED' | 'CREATED' | 'FAILED' | 'PARTIALLY_COMPLETED' | 'SUSPENDED';
    batchOperationType?: BatchOperationTypeEnum;
    /**
     * The start date of the batch operation.
     */
    startDate?: string;
    /**
     * The end date of the batch operation.
     */
    endDate?: string;
    /**
     * The total number of items contained in this batch operation.
     */
    operationsTotalCount?: number;
    /**
     * The number of items which failed during execution of the batch operation. (e.g. because they are rejected by the Zeebe engine).
     */
    operationsFailedCount?: number;
    /**
     * The number of successfully completed tasks.
     */
    operationsCompletedCount?: number;
    /**
     * The errors that occurred per partition during the batch operation.
     */
    errors?: Array<BatchOperationError>;
};
type BatchOperationError = {
    /**
     * The partition ID where the error occurred.
     */
    partitionId?: number;
    /**
     * The type of the error that occurred during the batch operation.
     */
    type?: 'QUERY_FAILED' | 'RESULT_BUFFER_SIZE_EXCEEDED';
    /**
     * The error message that occurred during the batch operation.
     */
    message?: string;
};
type BatchOperationItemSearchQueryResult = SearchQueryResponse & {
    /**
     * The matching batch operations.
     */
    items?: Array<BatchOperationItemResponse>;
};
type BatchOperationItemResponse = {
    operationType?: BatchOperationTypeEnum;
    /**
     * The key (or operate legacy ID) of the batch operation.
     */
    batchOperationKey?: BatchOperationKey;
    /**
     * Key of the item, e.g. a process instance key.
     */
    itemKey?: string;
    /**
     * the process instance key of the processed item.
     */
    processInstanceKey?: ProcessInstanceKey;
    /**
     * State of the item.
     */
    state?: 'ACTIVE' | 'COMPLETED' | 'SKIPPED' | 'CANCELED' | 'FAILED';
    /**
     * the date this item was processed.
     */
    processedDate?: string;
    /**
     * the error message from the engine in case of a failed operation.
     */
    errorMessage?: string;
};
/**
 * The process instance filter that defines which process instances should be canceled.
 */
type ProcessInstanceCancellationBatchOperationRequest = {
    filter: ProcessInstanceFilter;
};
/**
 * The process instance filter that defines which process instances should have their incidents resolved.
 */
type ProcessInstanceIncidentResolutionBatchOperationRequest = {
    filter: ProcessInstanceFilter;
};
/**
 * The process instance filter to define on which process instances tokens should be moved,
 * as well as mapping instructions which active element instances should be terminated and which
 * new element instances should be activated
 *
 */
type ProcessInstanceModificationBatchOperationRequest = {
    filter: ProcessInstanceFilter;
    /**
     * Instructions describing which elements should be activated in which scopes and which variables should be created.
     */
    moveInstructions: Array<ProcessInstanceModificationMoveBatchOperationInstruction>;
};
/**
 * Instructions describing a move operation. This instruction will terminate all active elementInstance
 * at sourceElementId and activate a new element instance for each terminated one at targetElementId.
 */
type ProcessInstanceModificationMoveBatchOperationInstruction = {
    /**
     * The ID of the element that should be terminated.
     */
    sourceElementId: ElementId;
    /**
     * The ID of the element that should be activated.
     */
    targetElementId: ElementId;
};
/**
 * List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length  100.
 */
type TagSet = Array<Tag> & {
    readonly length: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
};
type GetTopologyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/topology';
};
type GetTopologyErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetTopologyError = GetTopologyErrors[keyof GetTopologyErrors];
type GetTopologyResponses = {
    /**
     * Obtains the current topology of the cluster the gateway is part of.
     */
    200: TopologyResponse;
};
type GetTopologyResponse = GetTopologyResponses[keyof GetTopologyResponses];
type GetStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/status';
};
type GetStatusErrors = {
    /**
     * The cluster is DOWN and does not have any partition with a healthy leader.
     */
    503: unknown;
};
type GetStatusResponses = {
    /**
     * The cluster is UP and has at least one partition with a healthy leader.
     */
    204: void;
};
type GetStatusResponse = GetStatusResponses[keyof GetStatusResponses];
type GetLicenseData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/license';
};
type GetLicenseErrors = {
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetLicenseError = GetLicenseErrors[keyof GetLicenseErrors];
type GetLicenseResponses = {
    /**
     * Obtains the current status of the Camunda license.
     */
    200: LicenseResponse;
};
type GetLicenseResponse = GetLicenseResponses[keyof GetLicenseResponses];
type GetAuthenticationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/authentication/me';
};
type GetAuthenticationErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetAuthenticationError = GetAuthenticationErrors[keyof GetAuthenticationErrors];
type GetAuthenticationResponses = {
    /**
     * The current user is successfully returned.
     */
    200: CamundaUserResult;
};
type GetAuthenticationResponse = GetAuthenticationResponses[keyof GetAuthenticationResponses];
type ActivateJobsData = {
    body: JobActivationRequest;
    path?: never;
    query?: never;
    url: '/jobs/activation';
};
type ActivateJobsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * An Internal Error occurred. More details are provided in the response body. If the response body contains RESOURCE_EXHAUSTED, this signals back pressure.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type ActivateJobsError = ActivateJobsErrors[keyof ActivateJobsErrors];
type ActivateJobsResponses = {
    /**
     * The list of activated jobs.
     */
    200: JobActivationResult;
};
type ActivateJobsResponse = ActivateJobsResponses[keyof ActivateJobsResponses];
type SearchJobsData = {
    body?: JobSearchQuery;
    path?: never;
    query?: never;
    url: '/jobs/search';
};
type SearchJobsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchJobsError = SearchJobsErrors[keyof SearchJobsErrors];
type SearchJobsResponses = {
    /**
     * The job search result.
     */
    200: JobSearchQueryResult;
};
type SearchJobsResponse = SearchJobsResponses[keyof SearchJobsResponses];
type FailJobData = {
    body?: JobFailRequest;
    path: {
        /**
         * The key of the job to fail.
         */
        jobKey: JobKey;
    };
    query?: never;
    url: '/jobs/{jobKey}/failure';
};
type FailJobErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The job with the given jobKey is not found. It was completed by another worker, or the process instance itself was canceled.
     *
     */
    404: ProblemDetail;
    /**
     * The job with the given key is in the wrong state (i.e: not ACTIVATED or ACTIVATABLE). The job was failed by another worker with retries = 0, and the process is now in an incident state.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type FailJobError = FailJobErrors[keyof FailJobErrors];
type FailJobResponses = {
    /**
     * The job is failed.
     */
    204: void;
};
type FailJobResponse = FailJobResponses[keyof FailJobResponses];
type ThrowJobErrorData = {
    body: JobErrorRequest;
    path: {
        /**
         * The key of the job.
         */
        jobKey: JobKey;
    };
    query?: never;
    url: '/jobs/{jobKey}/error';
};
type ThrowJobErrorErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The job with the given jobKey is not found.
     *
     */
    404: ProblemDetail;
    /**
     * The job with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type ThrowJobErrorError = ThrowJobErrorErrors[keyof ThrowJobErrorErrors];
type ThrowJobErrorResponses = {
    /**
     * An error is thrown for the job.
     */
    204: void;
};
type ThrowJobErrorResponse = ThrowJobErrorResponses[keyof ThrowJobErrorResponses];
type CompleteJobData = {
    body?: JobCompletionRequest;
    path: {
        /**
         * The key of the job to complete.
         */
        jobKey: JobKey;
    };
    query?: never;
    url: '/jobs/{jobKey}/completion';
};
type CompleteJobErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The job with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * The job with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type CompleteJobError = CompleteJobErrors[keyof CompleteJobErrors];
type CompleteJobResponses = {
    /**
     * The job was completed successfully.
     */
    204: void;
};
type CompleteJobResponse = CompleteJobResponses[keyof CompleteJobResponses];
type UpdateJobData = {
    body: JobUpdateRequest;
    path: {
        /**
         * The key of the job to update.
         */
        jobKey: JobKey;
    };
    query?: never;
    url: '/jobs/{jobKey}';
};
type UpdateJobErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The job with the jobKey is not found.
     */
    404: ProblemDetail;
    /**
     * The job with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UpdateJobError = UpdateJobErrors[keyof UpdateJobErrors];
type UpdateJobResponses = {
    /**
     * The job was updated successfully.
     */
    204: void;
};
type UpdateJobResponse = UpdateJobResponses[keyof UpdateJobResponses];
type ResolveIncidentData = {
    body?: IncidentResolutionRequest;
    path: {
        /**
         * Key of the incident to resolve.
         */
        incidentKey: IncidentKey;
    };
    query?: never;
    url: '/incidents/{incidentKey}/resolution';
};
type ResolveIncidentErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The incident with the incidentKey is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type ResolveIncidentError = ResolveIncidentErrors[keyof ResolveIncidentErrors];
type ResolveIncidentResponses = {
    /**
     * The incident is marked as resolved.
     */
    204: void;
};
type ResolveIncidentResponse = ResolveIncidentResponses[keyof ResolveIncidentResponses];
type CreateTenantData = {
    body: TenantCreateRequest;
    path?: never;
    query?: never;
    url: '/tenants';
};
type CreateTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The resource was not found.
     */
    404: ProblemDetail;
    /**
     * Tenant with this id already exists.
     */
    409: unknown;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type CreateTenantError = CreateTenantErrors[keyof CreateTenantErrors];
type CreateTenantResponses = {
    /**
     * The tenant was created successfully.
     */
    201: TenantCreateResult;
};
type CreateTenantResponse = CreateTenantResponses[keyof CreateTenantResponses];
type DeleteTenantData = {
    body?: never;
    path: {
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}';
};
type DeleteTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type DeleteTenantError = DeleteTenantErrors[keyof DeleteTenantErrors];
type DeleteTenantResponses = {
    /**
     * The tenant was deleted successfully.
     */
    204: void;
};
type DeleteTenantResponse = DeleteTenantResponses[keyof DeleteTenantResponses];
type GetTenantData = {
    body?: never;
    path: {
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}';
};
type GetTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Tenant not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetTenantError = GetTenantErrors[keyof GetTenantErrors];
type GetTenantResponses = {
    /**
     * The tenant was retrieved successfully.
     */
    200: TenantResult;
};
type GetTenantResponse = GetTenantResponses[keyof GetTenantResponses];
type UpdateTenantData = {
    body: TenantUpdateRequest;
    path: {
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}';
};
type UpdateTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UpdateTenantError = UpdateTenantErrors[keyof UpdateTenantErrors];
type UpdateTenantResponses = {
    /**
     * The tenant was updated successfully.
     */
    200: TenantUpdateResult;
};
type UpdateTenantResponse = UpdateTenantResponses[keyof UpdateTenantResponses];
type UnassignUserFromTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
        /**
         * The unique identifier of the user.
         */
        username: Username;
    };
    query?: never;
    url: '/tenants/{tenantId}/users/{username}';
};
type UnassignUserFromTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or user was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UnassignUserFromTenantError = UnassignUserFromTenantErrors[keyof UnassignUserFromTenantErrors];
type UnassignUserFromTenantResponses = {
    /**
     * The user was successfully unassigned from the tenant.
     */
    204: void;
};
type UnassignUserFromTenantResponse = UnassignUserFromTenantResponses[keyof UnassignUserFromTenantResponses];
type AssignUserToTenantData = {
    body?: never;
    path: {
        /**
         * The unique identifier of the tenant.
         */
        tenantId: TenantId;
        /**
         * The username of the user to assign.
         */
        username: Username;
    };
    query?: never;
    url: '/tenants/{tenantId}/users/{username}';
};
type AssignUserToTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or user was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type AssignUserToTenantError = AssignUserToTenantErrors[keyof AssignUserToTenantErrors];
type AssignUserToTenantResponses = {
    /**
     * The user was successfully assigned to the tenant.
     */
    204: void;
};
type AssignUserToTenantResponse = AssignUserToTenantResponses[keyof AssignUserToTenantResponses];
type SearchUsersForTenantData = {
    body?: TenantUserSearchQueryRequest;
    path: {
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}/users/search';
};
type SearchUsersForTenantResponses = {
    /**
     * The search result of users for the tenant.
     */
    200: TenantUserSearchResult;
};
type SearchUsersForTenantResponse = SearchUsersForTenantResponses[keyof SearchUsersForTenantResponses];
type SearchClientsForTenantData = {
    body?: TenantClientSearchQueryRequest;
    path: {
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}/clients/search';
};
type SearchClientsForTenantResponses = {
    /**
     * The search result of users for the tenant.
     */
    200: TenantClientSearchResult;
};
type SearchClientsForTenantResponse = SearchClientsForTenantResponses[keyof SearchClientsForTenantResponses];
type SearchGroupIdsForTenantData = {
    body?: TenantGroupSearchQueryRequest;
    path: {
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}/groups/search';
};
type SearchGroupIdsForTenantResponses = {
    /**
     * The search result of groups for the tenant.
     */
    200: TenantGroupSearchResult;
};
type SearchGroupIdsForTenantResponse = SearchGroupIdsForTenantResponses[keyof SearchGroupIdsForTenantResponses];
type SearchRolesForTenantData = {
    body?: RoleSearchQueryRequest;
    path: {
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}/roles/search';
};
type SearchRolesForTenantResponses = {
    /**
     * The search result of roles for the tenant.
     */
    200: RoleSearchQueryResult;
};
type SearchRolesForTenantResponse = SearchRolesForTenantResponses[keyof SearchRolesForTenantResponses];
type UnassignClientFromTenantData = {
    body?: never;
    path: {
        tenantId: TenantId;
        /**
         * The unique identifier of the application.
         */
        clientId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/clients/{clientId}';
};
type UnassignClientFromTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The tenant does not exist or the client was not assigned to it.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UnassignClientFromTenantError = UnassignClientFromTenantErrors[keyof UnassignClientFromTenantErrors];
type UnassignClientFromTenantResponses = {
    /**
     * The client was successfully unassigned from the tenant.
     */
    204: void;
};
type UnassignClientFromTenantResponse = UnassignClientFromTenantResponses[keyof UnassignClientFromTenantResponses];
type AssignClientToTenantData = {
    body?: never;
    path: {
        tenantId: TenantId;
        /**
         * The ID of the client to assign.
         */
        clientId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/clients/{clientId}';
};
type AssignClientToTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The tenant was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type AssignClientToTenantError = AssignClientToTenantErrors[keyof AssignClientToTenantErrors];
type AssignClientToTenantResponses = {
    /**
     * The client was successfully assigned to the tenant.
     */
    204: void;
};
type AssignClientToTenantResponse = AssignClientToTenantResponses[keyof AssignClientToTenantResponses];
type UnassignMappingRuleFromTenantData = {
    body?: never;
    path: {
        tenantId: TenantId;
        /**
         * The unique identifier of the mapping rule.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/mapping-rules/{mappingRuleId}';
};
type UnassignMappingRuleFromTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or mapping rule was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UnassignMappingRuleFromTenantError = UnassignMappingRuleFromTenantErrors[keyof UnassignMappingRuleFromTenantErrors];
type UnassignMappingRuleFromTenantResponses = {
    /**
     * The mapping rule was successfully unassigned from the tenant.
     */
    204: void;
};
type UnassignMappingRuleFromTenantResponse = UnassignMappingRuleFromTenantResponses[keyof UnassignMappingRuleFromTenantResponses];
type AssignMappingRuleToTenantData = {
    body?: never;
    path: {
        tenantId: TenantId;
        /**
         * The unique identifier of the mapping rule.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/mapping-rules/{mappingRuleId}';
};
type AssignMappingRuleToTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or mapping rule was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type AssignMappingRuleToTenantError = AssignMappingRuleToTenantErrors[keyof AssignMappingRuleToTenantErrors];
type AssignMappingRuleToTenantResponses = {
    /**
     * The mapping rule was successfully assigned to the tenant.
     */
    204: void;
};
type AssignMappingRuleToTenantResponse = AssignMappingRuleToTenantResponses[keyof AssignMappingRuleToTenantResponses];
type SearchMappingRulesForTenantData = {
    body?: MappingRuleSearchQueryRequest;
    path: {
        tenantId: TenantId;
    };
    query?: never;
    url: '/tenants/{tenantId}/mapping-rules/search';
};
type SearchMappingRulesForTenantResponses = {
    /**
     * The search result of MappingRules for the tenant.
     */
    200: MappingRuleSearchQueryResult;
};
type SearchMappingRulesForTenantResponse = SearchMappingRulesForTenantResponses[keyof SearchMappingRulesForTenantResponses];
type UnassignGroupFromTenantData = {
    body?: never;
    path: {
        tenantId: TenantId;
        /**
         * The unique identifier of the group.
         */
        groupId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/groups/{groupId}';
};
type UnassignGroupFromTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or group was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UnassignGroupFromTenantError = UnassignGroupFromTenantErrors[keyof UnassignGroupFromTenantErrors];
type UnassignGroupFromTenantResponses = {
    /**
     * The group was successfully unassigned from the tenant.
     */
    204: void;
};
type UnassignGroupFromTenantResponse = UnassignGroupFromTenantResponses[keyof UnassignGroupFromTenantResponses];
type AssignGroupToTenantData = {
    body?: never;
    path: {
        tenantId: TenantId;
        /**
         * The unique identifier of the group.
         */
        groupId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/groups/{groupId}';
};
type AssignGroupToTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or group was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type AssignGroupToTenantError = AssignGroupToTenantErrors[keyof AssignGroupToTenantErrors];
type AssignGroupToTenantResponses = {
    /**
     * The group was successfully assigned to the tenant.
     */
    204: void;
};
type AssignGroupToTenantResponse = AssignGroupToTenantResponses[keyof AssignGroupToTenantResponses];
type UnassignRoleFromTenantData = {
    body?: never;
    path: {
        tenantId: TenantId;
        /**
         * The unique identifier of the role.
         */
        roleId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/roles/{roleId}';
};
type UnassignRoleFromTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or role was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UnassignRoleFromTenantError = UnassignRoleFromTenantErrors[keyof UnassignRoleFromTenantErrors];
type UnassignRoleFromTenantResponses = {
    /**
     * The role was successfully unassigned from the tenant.
     */
    204: void;
};
type UnassignRoleFromTenantResponse = UnassignRoleFromTenantResponses[keyof UnassignRoleFromTenantResponses];
type AssignRoleToTenantData = {
    body?: never;
    path: {
        tenantId: TenantId;
        /**
         * The unique identifier of the role.
         */
        roleId: string;
    };
    query?: never;
    url: '/tenants/{tenantId}/roles/{roleId}';
};
type AssignRoleToTenantErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The tenant or role was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type AssignRoleToTenantError = AssignRoleToTenantErrors[keyof AssignRoleToTenantErrors];
type AssignRoleToTenantResponses = {
    /**
     * The role was successfully assigned to the tenant.
     */
    204: void;
};
type AssignRoleToTenantResponse = AssignRoleToTenantResponses[keyof AssignRoleToTenantResponses];
type SearchTenantsData = {
    body?: TenantSearchQueryRequest;
    path?: never;
    query?: never;
    url: '/tenants/search';
};
type SearchTenantsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchTenantsError = SearchTenantsErrors[keyof SearchTenantsErrors];
type SearchTenantsResponses = {
    /**
     * The tenants search result
     */
    200: TenantSearchQueryResult;
};
type SearchTenantsResponse = SearchTenantsResponses[keyof SearchTenantsResponses];
type CompleteUserTaskData = {
    body?: UserTaskCompletionRequest;
    path: {
        /**
         * The key of the user task to complete.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}/completion';
};
type CompleteUserTaskErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The user task with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * The user task with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type CompleteUserTaskError = CompleteUserTaskErrors[keyof CompleteUserTaskErrors];
type CompleteUserTaskResponses = {
    /**
     * The user task was completed successfully.
     */
    204: void;
};
type CompleteUserTaskResponse = CompleteUserTaskResponses[keyof CompleteUserTaskResponses];
type AssignUserTaskData = {
    body: UserTaskAssignmentRequest;
    path: {
        /**
         * The key of the user task to assign.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}/assignment';
};
type AssignUserTaskErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The user task with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * The user task with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type AssignUserTaskError = AssignUserTaskErrors[keyof AssignUserTaskErrors];
type AssignUserTaskResponses = {
    /**
     * The user task's assignment was adjusted.
     */
    204: void;
};
type AssignUserTaskResponse = AssignUserTaskResponses[keyof AssignUserTaskResponses];
type GetUserTaskData = {
    body?: never;
    path: {
        /**
         * The user task key.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}';
};
type GetUserTaskErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The user task with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetUserTaskError = GetUserTaskErrors[keyof GetUserTaskErrors];
type GetUserTaskResponses = {
    /**
     * The user task is successfully returned.
     *
     */
    200: UserTaskResult;
};
type GetUserTaskResponse = GetUserTaskResponses[keyof GetUserTaskResponses];
type UpdateUserTaskData = {
    body?: UserTaskUpdateRequest;
    path: {
        /**
         * The key of the user task to update.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}';
};
type UpdateUserTaskErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The user task with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * The user task with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UpdateUserTaskError = UpdateUserTaskErrors[keyof UpdateUserTaskErrors];
type UpdateUserTaskResponses = {
    /**
     * The user task was updated successfully.
     */
    204: void;
};
type UpdateUserTaskResponse = UpdateUserTaskResponses[keyof UpdateUserTaskResponses];
type GetUserTaskFormData = {
    body?: never;
    path: {
        /**
         * The user task key.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}/form';
};
type GetUserTaskFormErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetUserTaskFormError = GetUserTaskFormErrors[keyof GetUserTaskFormErrors];
type GetUserTaskFormResponses = {
    /**
     * The form is successfully returned.
     */
    200: FormResult;
    /**
     * The user task was found, but no form is associated with it.
     */
    204: void;
};
type GetUserTaskFormResponse = GetUserTaskFormResponses[keyof GetUserTaskFormResponses];
type UnassignUserTaskData = {
    body?: never;
    path: {
        /**
         * The key of the user task.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}/assignee';
};
type UnassignUserTaskErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The user task with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * The user task with the given key is in the wrong state currently. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UnassignUserTaskError = UnassignUserTaskErrors[keyof UnassignUserTaskErrors];
type UnassignUserTaskResponses = {
    /**
     * The user task was unassigned successfully.
     */
    204: void;
};
type UnassignUserTaskResponse = UnassignUserTaskResponses[keyof UnassignUserTaskResponses];
type SearchUserTasksData = {
    body?: UserTaskSearchQuery;
    path?: never;
    query?: never;
    url: '/user-tasks/search';
};
type SearchUserTasksErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchUserTasksError = SearchUserTasksErrors[keyof SearchUserTasksErrors];
type SearchUserTasksResponses = {
    /**
     * The user task search result.
     */
    200: UserTaskSearchQueryResult;
};
type SearchUserTasksResponse = SearchUserTasksResponses[keyof SearchUserTasksResponses];
type SearchUserTaskVariablesData = {
    body?: UserTaskVariableSearchQueryRequest;
    path: {
        /**
         * The key of the user task.
         */
        userTaskKey: UserTaskKey;
    };
    query?: never;
    url: '/user-tasks/{userTaskKey}/variables/search';
};
type SearchUserTaskVariablesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchUserTaskVariablesError = SearchUserTaskVariablesErrors[keyof SearchUserTaskVariablesErrors];
type SearchUserTaskVariablesResponses = {
    /**
     * The user task variables search response.
     *
     */
    200: VariableSearchQueryResult;
};
type SearchUserTaskVariablesResponse = SearchUserTaskVariablesResponses[keyof SearchUserTaskVariablesResponses];
type SearchVariablesData = {
    body?: VariableSearchQuery;
    path?: never;
    query?: never;
    url: '/variables/search';
};
type SearchVariablesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchVariablesError = SearchVariablesErrors[keyof SearchVariablesErrors];
type SearchVariablesResponses = {
    /**
     * The variable search result.
     */
    200: VariableSearchQueryResult;
};
type SearchVariablesResponse = SearchVariablesResponses[keyof SearchVariablesResponses];
type GetVariableData = {
    body?: never;
    path: {
        /**
         * The variable key.
         */
        variableKey: VariableKey;
    };
    query?: never;
    url: '/variables/{variableKey}';
};
type GetVariableErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetVariableError = GetVariableErrors[keyof GetVariableErrors];
type GetVariableResponses = {
    /**
     * The variable is successfully returned.
     */
    200: VariableResult;
};
type GetVariableResponse = GetVariableResponses[keyof GetVariableResponses];
type PinClockData = {
    body: ClockPinRequest;
    path?: never;
    query?: never;
    url: '/clock';
};
type PinClockErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type PinClockError = PinClockErrors[keyof PinClockErrors];
type PinClockResponses = {
    /**
     * The clock was successfully pinned to the specified time in epoch milliseconds.
     *
     */
    204: void;
};
type PinClockResponse = PinClockResponses[keyof PinClockResponses];
type ResetClockData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/clock/reset';
};
type ResetClockErrors = {
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type ResetClockError = ResetClockErrors[keyof ResetClockErrors];
type ResetClockResponses = {
    /**
     * The clock was successfully reset to the system time.
     */
    204: void;
};
type ResetClockResponse = ResetClockResponses[keyof ResetClockResponses];
type SearchProcessDefinitionsData = {
    body?: ProcessDefinitionSearchQuery;
    path?: never;
    query?: never;
    url: '/process-definitions/search';
};
type SearchProcessDefinitionsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchProcessDefinitionsError = SearchProcessDefinitionsErrors[keyof SearchProcessDefinitionsErrors];
type SearchProcessDefinitionsResponses = {
    /**
     * The process definition search result.
     */
    200: ProcessDefinitionSearchQueryResult;
};
type SearchProcessDefinitionsResponse = SearchProcessDefinitionsResponses[keyof SearchProcessDefinitionsResponses];
type GetProcessDefinitionData = {
    body?: never;
    path: {
        /**
         * The assigned key of the process definition, which acts as a unique identifier for this process definition.
         *
         */
        processDefinitionKey: ProcessDefinitionKey;
    };
    query?: never;
    url: '/process-definitions/{processDefinitionKey}';
};
type GetProcessDefinitionErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The process definition with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetProcessDefinitionError = GetProcessDefinitionErrors[keyof GetProcessDefinitionErrors];
type GetProcessDefinitionResponses = {
    /**
     * The process definition is successfully returned.
     */
    200: ProcessDefinitionResult;
};
type GetProcessDefinitionResponse = GetProcessDefinitionResponses[keyof GetProcessDefinitionResponses];
type GetProcessDefinitionXmlData = {
    body?: never;
    path: {
        /**
         * The assigned key of the process definition, which acts as a unique identifier for this process definition.
         */
        processDefinitionKey: ProcessDefinitionKey;
    };
    query?: never;
    url: '/process-definitions/{processDefinitionKey}/xml';
};
type GetProcessDefinitionXmlErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The decision with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetProcessDefinitionXmlError = GetProcessDefinitionXmlErrors[keyof GetProcessDefinitionXmlErrors];
type GetProcessDefinitionXmlResponses = {
    /**
     * The XML of the process definition is successfully returned.
     */
    200: string;
    /**
     * The process definition was found but does not have XML.
     */
    204: string;
};
type GetProcessDefinitionXmlResponse = GetProcessDefinitionXmlResponses[keyof GetProcessDefinitionXmlResponses];
type GetStartProcessFormData = {
    body?: never;
    path: {
        /**
         * The process key.
         */
        processDefinitionKey: ProcessDefinitionKey;
    };
    query?: never;
    url: '/process-definitions/{processDefinitionKey}/form';
};
type GetStartProcessFormErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetStartProcessFormError = GetStartProcessFormErrors[keyof GetStartProcessFormErrors];
type GetStartProcessFormResponses = {
    /**
     * The form is successfully returned.
     */
    200: FormResult;
    /**
     * The process was found, but no form is associated with it.
     */
    204: void;
};
type GetStartProcessFormResponse = GetStartProcessFormResponses[keyof GetStartProcessFormResponses];
type GetProcessDefinitionStatisticsData = {
    body?: ProcessDefinitionElementStatisticsQuery;
    path: {
        /**
         * The assigned key of the process definition, which acts as a unique identifier for this process definition.
         */
        processDefinitionKey: ProcessDefinitionKey;
    };
    query?: never;
    url: '/process-definitions/{processDefinitionKey}/statistics/element-instances';
};
type GetProcessDefinitionStatisticsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetProcessDefinitionStatisticsError = GetProcessDefinitionStatisticsErrors[keyof GetProcessDefinitionStatisticsErrors];
type GetProcessDefinitionStatisticsResponses = {
    /**
     * The process definition statistics result.
     */
    200: ProcessDefinitionElementStatisticsQueryResult;
};
type GetProcessDefinitionStatisticsResponse = GetProcessDefinitionStatisticsResponses[keyof GetProcessDefinitionStatisticsResponses];
type CreateProcessInstanceData = {
    body: ProcessInstanceCreationInstruction;
    path?: never;
    query?: never;
    url: '/process-instances';
};
type CreateProcessInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
    /**
     * The process instance creation request timed out in the gateway.
     *
     * This can happen if the `awaitCompletion` request parameter is set to `true`
     * and the created process instance did not complete within the defined request timeout.
     * This often happens when the created instance is not fully automated or contains wait states.
     *
     */
    504: ProblemDetail;
};
type CreateProcessInstanceError = CreateProcessInstanceErrors[keyof CreateProcessInstanceErrors];
type CreateProcessInstanceResponses = {
    /**
     * The process instance was created.
     */
    200: CreateProcessInstanceResult;
};
type CreateProcessInstanceResponse = CreateProcessInstanceResponses[keyof CreateProcessInstanceResponses];
type GetProcessInstanceData = {
    body?: never;
    path: {
        /**
         * The process instance key.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}';
};
type GetProcessInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The process instance with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetProcessInstanceError = GetProcessInstanceErrors[keyof GetProcessInstanceErrors];
type GetProcessInstanceResponses = {
    /**
     * The process instance is successfully returned.
     */
    200: ProcessInstanceResult;
};
type GetProcessInstanceResponse = GetProcessInstanceResponses[keyof GetProcessInstanceResponses];
type GetProcessInstanceSequenceFlowsData = {
    body?: never;
    path: {
        /**
         * The assigned key of the process instance, which acts as a unique identifier for this process instance.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/sequence-flows';
};
type GetProcessInstanceSequenceFlowsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetProcessInstanceSequenceFlowsError = GetProcessInstanceSequenceFlowsErrors[keyof GetProcessInstanceSequenceFlowsErrors];
type GetProcessInstanceSequenceFlowsResponses = {
    /**
     * The process instance sequence flows result.
     */
    200: ProcessInstanceSequenceFlowsQueryResult;
};
type GetProcessInstanceSequenceFlowsResponse = GetProcessInstanceSequenceFlowsResponses[keyof GetProcessInstanceSequenceFlowsResponses];
type GetProcessInstanceStatisticsData = {
    body?: never;
    path: {
        /**
         * The assigned key of the process instance, which acts as a unique identifier for this process instance.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/statistics/element-instances';
};
type GetProcessInstanceStatisticsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetProcessInstanceStatisticsError = GetProcessInstanceStatisticsErrors[keyof GetProcessInstanceStatisticsErrors];
type GetProcessInstanceStatisticsResponses = {
    /**
     * The process instance statistics result.
     */
    200: ProcessInstanceElementStatisticsQueryResult;
};
type GetProcessInstanceStatisticsResponse = GetProcessInstanceStatisticsResponses[keyof GetProcessInstanceStatisticsResponses];
type SearchProcessInstancesData = {
    body?: ProcessInstanceSearchQuery;
    path?: never;
    query?: never;
    url: '/process-instances/search';
};
type SearchProcessInstancesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchProcessInstancesError = SearchProcessInstancesErrors[keyof SearchProcessInstancesErrors];
type SearchProcessInstancesResponses = {
    /**
     * The process instance search result.
     */
    200: ProcessInstanceSearchQueryResult;
};
type SearchProcessInstancesResponse = SearchProcessInstancesResponses[keyof SearchProcessInstancesResponses];
type SearchProcessInstanceIncidentsData = {
    body?: ProcessInstanceIncidentSearchQuery;
    path: {
        /**
         * The assigned key of the process instance, which acts as a unique identifier for this process instance.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/incidents/search';
};
type SearchProcessInstanceIncidentsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The process instance with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchProcessInstanceIncidentsError = SearchProcessInstanceIncidentsErrors[keyof SearchProcessInstanceIncidentsErrors];
type SearchProcessInstanceIncidentsResponses = {
    /**
     * The process instance search result.
     */
    200: IncidentSearchQueryResult;
};
type SearchProcessInstanceIncidentsResponse = SearchProcessInstanceIncidentsResponses[keyof SearchProcessInstanceIncidentsResponses];
type CancelProcessInstanceData = {
    body?: CancelProcessInstanceRequest;
    path: {
        /**
         * The key of the process instance to cancel.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/cancellation';
};
type CancelProcessInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The process instance is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type CancelProcessInstanceError = CancelProcessInstanceErrors[keyof CancelProcessInstanceErrors];
type CancelProcessInstanceResponses = {
    /**
     * The process instance is canceled.
     */
    204: void;
};
type CancelProcessInstanceResponse = CancelProcessInstanceResponses[keyof CancelProcessInstanceResponses];
type CancelProcessInstancesBatchOperationData = {
    body: ProcessInstanceCancellationBatchOperationRequest;
    path?: never;
    query?: never;
    url: '/process-instances/cancellation';
};
type CancelProcessInstancesBatchOperationErrors = {
    /**
     * The process instance batch operation failed. More details are provided in the response body.
     *
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type CancelProcessInstancesBatchOperationError = CancelProcessInstancesBatchOperationErrors[keyof CancelProcessInstancesBatchOperationErrors];
type CancelProcessInstancesBatchOperationResponses = {
    /**
     * The batch operation request was created.
     */
    200: BatchOperationCreatedResult;
};
type CancelProcessInstancesBatchOperationResponse = CancelProcessInstancesBatchOperationResponses[keyof CancelProcessInstancesBatchOperationResponses];
type ResolveIncidentsBatchOperationData = {
    body?: ProcessInstanceIncidentResolutionBatchOperationRequest;
    path?: never;
    query?: never;
    url: '/process-instances/incident-resolution';
};
type ResolveIncidentsBatchOperationErrors = {
    /**
     * The process instance batch operation failed. More details are provided in the response body.
     *
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type ResolveIncidentsBatchOperationError = ResolveIncidentsBatchOperationErrors[keyof ResolveIncidentsBatchOperationErrors];
type ResolveIncidentsBatchOperationResponses = {
    /**
     * The batch operation request was created.
     */
    200: BatchOperationCreatedResult;
};
type ResolveIncidentsBatchOperationResponse = ResolveIncidentsBatchOperationResponses[keyof ResolveIncidentsBatchOperationResponses];
type MigrateProcessInstancesBatchOperationData = {
    body: ProcessInstanceMigrationBatchOperationRequest;
    path?: never;
    query?: never;
    url: '/process-instances/migration';
};
type MigrateProcessInstancesBatchOperationErrors = {
    /**
     * The process instance batch operation failed. More details are provided in the response body.
     *
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type MigrateProcessInstancesBatchOperationError = MigrateProcessInstancesBatchOperationErrors[keyof MigrateProcessInstancesBatchOperationErrors];
type MigrateProcessInstancesBatchOperationResponses = {
    /**
     * The batch operation request was created.
     */
    200: BatchOperationCreatedResult;
};
type MigrateProcessInstancesBatchOperationResponse = MigrateProcessInstancesBatchOperationResponses[keyof MigrateProcessInstancesBatchOperationResponses];
type ModifyProcessInstancesBatchOperationData = {
    body: ProcessInstanceModificationBatchOperationRequest;
    path?: never;
    query?: never;
    url: '/process-instances/modification';
};
type ModifyProcessInstancesBatchOperationErrors = {
    /**
     * The process instance batch operation failed. More details are provided in the response body.
     *
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type ModifyProcessInstancesBatchOperationError = ModifyProcessInstancesBatchOperationErrors[keyof ModifyProcessInstancesBatchOperationErrors];
type ModifyProcessInstancesBatchOperationResponses = {
    /**
     * The batch operation request was created.
     */
    200: BatchOperationCreatedResult;
};
type ModifyProcessInstancesBatchOperationResponse = ModifyProcessInstancesBatchOperationResponses[keyof ModifyProcessInstancesBatchOperationResponses];
type MigrateProcessInstanceData = {
    body: ProcessInstanceMigrationInstruction;
    path: {
        /**
         * The key of the process instance that should be migrated.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/migration';
};
type MigrateProcessInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The process instance is not found.
     */
    404: ProblemDetail;
    /**
     * The process instance migration failed. More details are provided in the response body.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type MigrateProcessInstanceError = MigrateProcessInstanceErrors[keyof MigrateProcessInstanceErrors];
type MigrateProcessInstanceResponses = {
    /**
     * The process instance is migrated.
     */
    204: void;
};
type MigrateProcessInstanceResponse = MigrateProcessInstanceResponses[keyof MigrateProcessInstanceResponses];
type ModifyProcessInstanceData = {
    body: ProcessInstanceModificationInstruction;
    path: {
        /**
         * The key of the process instance that should be modified.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/modification';
};
type ModifyProcessInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The process instance is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type ModifyProcessInstanceError = ModifyProcessInstanceErrors[keyof ModifyProcessInstanceErrors];
type ModifyProcessInstanceResponses = {
    /**
     * The process instance is modified.
     */
    204: void;
};
type ModifyProcessInstanceResponse = ModifyProcessInstanceResponses[keyof ModifyProcessInstanceResponses];
type GetProcessInstanceCallHierarchyData = {
    body?: never;
    path: {
        /**
         * The key of the process instance to fetch the hierarchy for.
         */
        processInstanceKey: ProcessInstanceKey;
    };
    query?: never;
    url: '/process-instances/{processInstanceKey}/call-hierarchy';
};
type GetProcessInstanceCallHierarchyErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The process instance is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetProcessInstanceCallHierarchyError = GetProcessInstanceCallHierarchyErrors[keyof GetProcessInstanceCallHierarchyErrors];
type GetProcessInstanceCallHierarchyResponses = {
    /**
     * The call hierarchy is successfully returned.
     */
    200: Array<ProcessInstanceCallHierarchyEntry>;
};
type GetProcessInstanceCallHierarchyResponse = GetProcessInstanceCallHierarchyResponses[keyof GetProcessInstanceCallHierarchyResponses];
type SearchElementInstancesData = {
    body?: ElementInstanceSearchQuery;
    path?: never;
    query?: never;
    url: '/element-instances/search';
};
type SearchElementInstancesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchElementInstancesError = SearchElementInstancesErrors[keyof SearchElementInstancesErrors];
type SearchElementInstancesResponses = {
    /**
     * The element instance search result.
     */
    200: ElementInstanceSearchQueryResult;
};
type SearchElementInstancesResponse = SearchElementInstancesResponses[keyof SearchElementInstancesResponses];
type GetElementInstanceData = {
    body?: never;
    path: {
        /**
         * The assigned key of the element instance, which acts as a unique identifier for this element instance.
         */
        elementInstanceKey: ElementInstanceKey;
    };
    query?: never;
    url: '/element-instances/{elementInstanceKey}';
};
type GetElementInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The element instance with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetElementInstanceError = GetElementInstanceErrors[keyof GetElementInstanceErrors];
type GetElementInstanceResponses = {
    /**
     * The element instance is successfully returned.
     */
    200: ElementInstanceResult;
};
type GetElementInstanceResponse = GetElementInstanceResponses[keyof GetElementInstanceResponses];
type SearchDecisionDefinitionsData = {
    body?: DecisionDefinitionSearchQuery;
    path?: never;
    query?: never;
    url: '/decision-definitions/search';
};
type SearchDecisionDefinitionsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchDecisionDefinitionsError = SearchDecisionDefinitionsErrors[keyof SearchDecisionDefinitionsErrors];
type SearchDecisionDefinitionsResponses = {
    /**
     * The decision definition search result.
     */
    200: DecisionDefinitionSearchQueryResult;
};
type SearchDecisionDefinitionsResponse = SearchDecisionDefinitionsResponses[keyof SearchDecisionDefinitionsResponses];
type GetDecisionDefinitionData = {
    body?: never;
    path: {
        /**
         * The assigned key of the decision definition, which acts as a unique identifier for this decision.
         */
        decisionDefinitionKey: DecisionDefinitionKey;
    };
    query?: never;
    url: '/decision-definitions/{decisionDefinitionKey}';
};
type GetDecisionDefinitionErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The decision with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetDecisionDefinitionError = GetDecisionDefinitionErrors[keyof GetDecisionDefinitionErrors];
type GetDecisionDefinitionResponses = {
    /**
     * The decision definition is successfully returned.
     *
     */
    200: DecisionDefinitionResult;
};
type GetDecisionDefinitionResponse = GetDecisionDefinitionResponses[keyof GetDecisionDefinitionResponses];
type GetDecisionDefinitionXmlData = {
    body?: never;
    path: {
        /**
         * The assigned key of the decision definition, which acts as a unique identifier for this decision.
         */
        decisionDefinitionKey: DecisionDefinitionKey;
    };
    query?: never;
    url: '/decision-definitions/{decisionDefinitionKey}/xml';
};
type GetDecisionDefinitionXmlErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The decision with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetDecisionDefinitionXmlError = GetDecisionDefinitionXmlErrors[keyof GetDecisionDefinitionXmlErrors];
type GetDecisionDefinitionXmlResponses = {
    /**
     * The XML of the decision definition is successfully returned.
     */
    200: string;
};
type GetDecisionDefinitionXmlResponse = GetDecisionDefinitionXmlResponses[keyof GetDecisionDefinitionXmlResponses];
type SearchDecisionRequirementsData = {
    body?: DecisionRequirementsSearchQuery;
    path?: never;
    query?: never;
    url: '/decision-requirements/search';
};
type SearchDecisionRequirementsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchDecisionRequirementsError = SearchDecisionRequirementsErrors[keyof SearchDecisionRequirementsErrors];
type SearchDecisionRequirementsResponses = {
    /**
     * The decision requirements search result.
     */
    200: DecisionRequirementsSearchQueryResult;
};
type SearchDecisionRequirementsResponse = SearchDecisionRequirementsResponses[keyof SearchDecisionRequirementsResponses];
type GetDecisionRequirementsData = {
    body?: never;
    path: {
        /**
         * The assigned key of the decision requirements, which acts as a unique identifier for this decision requirements.
         */
        decisionRequirementsKey: DecisionRequirementsKey;
    };
    query?: never;
    url: '/decision-requirements/{decisionRequirementsKey}';
};
type GetDecisionRequirementsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The decision requirements with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetDecisionRequirementsError = GetDecisionRequirementsErrors[keyof GetDecisionRequirementsErrors];
type GetDecisionRequirementsResponses = {
    /**
     * The decision requirements is successfully returned.
     */
    200: DecisionRequirementsResult;
};
type GetDecisionRequirementsResponse = GetDecisionRequirementsResponses[keyof GetDecisionRequirementsResponses];
type GetDecisionRequirementsXmlData = {
    body?: never;
    path: {
        /**
         * The assigned key of the decision requirements, which acts as a unique identifier for this decision.
         */
        decisionRequirementsKey: DecisionRequirementsKey;
    };
    query?: never;
    url: '/decision-requirements/{decisionRequirementsKey}/xml';
};
type GetDecisionRequirementsXmlErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The decision requirements with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetDecisionRequirementsXmlError = GetDecisionRequirementsXmlErrors[keyof GetDecisionRequirementsXmlErrors];
type GetDecisionRequirementsXmlResponses = {
    /**
     * The XML of the decision requirements is successfully returned.
     */
    200: string;
};
type GetDecisionRequirementsXmlResponse = GetDecisionRequirementsXmlResponses[keyof GetDecisionRequirementsXmlResponses];
type SearchDecisionInstancesData = {
    body?: DecisionInstanceSearchQuery;
    path?: never;
    query?: never;
    url: '/decision-instances/search';
};
type SearchDecisionInstancesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchDecisionInstancesError = SearchDecisionInstancesErrors[keyof SearchDecisionInstancesErrors];
type SearchDecisionInstancesResponses = {
    /**
     * The decision instance search result.
     */
    200: DecisionInstanceSearchQueryResult;
};
type SearchDecisionInstancesResponse = SearchDecisionInstancesResponses[keyof SearchDecisionInstancesResponses];
type GetDecisionInstanceData = {
    body?: never;
    path: {
        decisionEvaluationInstanceKey: DecisionEvaluationInstanceKey;
    };
    query?: never;
    url: '/decision-instances/{decisionEvaluationInstanceKey}';
};
type GetDecisionInstanceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The decision instance with the given ID was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetDecisionInstanceError = GetDecisionInstanceErrors[keyof GetDecisionInstanceErrors];
type GetDecisionInstanceResponses = {
    /**
     * The decision instance is successfully returned.
     */
    200: DecisionInstanceGetQueryResult;
};
type GetDecisionInstanceResponse = GetDecisionInstanceResponses[keyof GetDecisionInstanceResponses];
type EvaluateDecisionData = {
    body: DecisionEvaluationInstruction;
    path?: never;
    query?: never;
    url: '/decision-definitions/evaluation';
};
type EvaluateDecisionErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The decision is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type EvaluateDecisionError = EvaluateDecisionErrors[keyof EvaluateDecisionErrors];
type EvaluateDecisionResponses = {
    /**
     * The decision was evaluated.
     */
    200: EvaluateDecisionResult;
};
type EvaluateDecisionResponse = EvaluateDecisionResponses[keyof EvaluateDecisionResponses];
type CreateAuthorizationData = {
    body: AuthorizationRequest;
    path?: never;
    query?: never;
    url: '/authorizations';
};
type CreateAuthorizationErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The owner was not found.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type CreateAuthorizationError = CreateAuthorizationErrors[keyof CreateAuthorizationErrors];
type CreateAuthorizationResponses = {
    /**
     * The authorization was created successfully.
     *
     */
    201: AuthorizationCreateResult;
};
type CreateAuthorizationResponse = CreateAuthorizationResponses[keyof CreateAuthorizationResponses];
type DeleteAuthorizationData = {
    body?: never;
    path: {
        /**
         * The key of the authorization to delete.
         */
        authorizationKey: AuthorizationKey;
    };
    query?: never;
    url: '/authorizations/{authorizationKey}';
};
type DeleteAuthorizationErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The authorization with the authorizationKey was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type DeleteAuthorizationError = DeleteAuthorizationErrors[keyof DeleteAuthorizationErrors];
type DeleteAuthorizationResponses = {
    /**
     * The authorization was deleted successfully.
     */
    204: void;
};
type DeleteAuthorizationResponse = DeleteAuthorizationResponses[keyof DeleteAuthorizationResponses];
type GetAuthorizationData = {
    body?: never;
    path: {
        /**
         * The key of the authorization to get.
         */
        authorizationKey: AuthorizationKey;
    };
    query?: never;
    url: '/authorizations/{authorizationKey}';
};
type GetAuthorizationErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The authorization with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetAuthorizationError = GetAuthorizationErrors[keyof GetAuthorizationErrors];
type GetAuthorizationResponses = {
    /**
     * The authorization was successfully returned.
     */
    200: AuthorizationResult;
};
type GetAuthorizationResponse = GetAuthorizationResponses[keyof GetAuthorizationResponses];
type UpdateAuthorizationData = {
    body: AuthorizationRequest;
    path: {
        /**
         * The key of the authorization to delete.
         */
        authorizationKey: AuthorizationKey;
    };
    query?: never;
    url: '/authorizations/{authorizationKey}';
};
type UpdateAuthorizationErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The authorization with the authorizationKey was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UpdateAuthorizationError = UpdateAuthorizationErrors[keyof UpdateAuthorizationErrors];
type UpdateAuthorizationResponses = {
    /**
     * The authorization was updated successfully.
     */
    204: void;
};
type UpdateAuthorizationResponse = UpdateAuthorizationResponses[keyof UpdateAuthorizationResponses];
type SearchAuthorizationsData = {
    body?: AuthorizationSearchQuery;
    path?: never;
    query?: never;
    url: '/authorizations/search';
};
type SearchAuthorizationsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchAuthorizationsError = SearchAuthorizationsErrors[keyof SearchAuthorizationsErrors];
type SearchAuthorizationsResponses = {
    /**
     * The authorization search result.
     */
    200: AuthorizationSearchResult;
};
type SearchAuthorizationsResponse = SearchAuthorizationsResponses[keyof SearchAuthorizationsResponses];
type CreateRoleData = {
    body?: RoleCreateRequest;
    path?: never;
    query?: never;
    url: '/roles';
};
type CreateRoleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type CreateRoleError = CreateRoleErrors[keyof CreateRoleErrors];
type CreateRoleResponses = {
    /**
     * The role was created successfully.
     *
     */
    201: RoleCreateResult;
};
type CreateRoleResponse = CreateRoleResponses[keyof CreateRoleResponses];
type DeleteRoleData = {
    body?: never;
    path: {
        /**
         * The ID of the role to delete.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}';
};
type DeleteRoleErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The role with the ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type DeleteRoleError = DeleteRoleErrors[keyof DeleteRoleErrors];
type DeleteRoleResponses = {
    /**
     * The role was deleted successfully.
     */
    204: void;
};
type DeleteRoleResponse = DeleteRoleResponses[keyof DeleteRoleResponses];
type GetRoleData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}';
};
type GetRoleErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetRoleError = GetRoleErrors[keyof GetRoleErrors];
type GetRoleResponses = {
    /**
     * The role is successfully returned.
     */
    200: RoleResult;
};
type GetRoleResponse = GetRoleResponses[keyof GetRoleResponses];
type UpdateRoleData = {
    body: RoleUpdateRequest;
    path: {
        /**
         * The ID of the role to update.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}';
};
type UpdateRoleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The role with the ID is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UpdateRoleError = UpdateRoleErrors[keyof UpdateRoleErrors];
type UpdateRoleResponses = {
    /**
     * The role was updated successfully.
     */
    200: RoleUpdateResult;
};
type UpdateRoleResponse = UpdateRoleResponses[keyof UpdateRoleResponses];
type SearchUsersForRoleData = {
    body?: RoleUserSearchQueryRequest;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}/users/search';
};
type SearchUsersForRoleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchUsersForRoleError = SearchUsersForRoleErrors[keyof SearchUsersForRoleErrors];
type SearchUsersForRoleResponses = {
    /**
     * The users with the assigned role.
     */
    200: RoleUserSearchResult;
};
type SearchUsersForRoleResponse = SearchUsersForRoleResponses[keyof SearchUsersForRoleResponses];
type SearchClientsForRoleData = {
    body?: RoleClientSearchQueryRequest;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}/clients/search';
};
type SearchClientsForRoleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchClientsForRoleError = SearchClientsForRoleErrors[keyof SearchClientsForRoleErrors];
type SearchClientsForRoleResponses = {
    /**
     * The clients with the assigned role.
     */
    200: RoleClientSearchResult;
};
type SearchClientsForRoleResponse = SearchClientsForRoleResponses[keyof SearchClientsForRoleResponses];
type UnassignRoleFromUserData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The user username.
         */
        username: Username;
    };
    query?: never;
    url: '/roles/{roleId}/users/{username}';
};
type UnassignRoleFromUserErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or user with the given ID or username was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UnassignRoleFromUserError = UnassignRoleFromUserErrors[keyof UnassignRoleFromUserErrors];
type UnassignRoleFromUserResponses = {
    /**
     * The role was unassigned successfully from the user.
     */
    204: void;
};
type UnassignRoleFromUserResponse = UnassignRoleFromUserResponses[keyof UnassignRoleFromUserResponses];
type AssignRoleToUserData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The user username.
         */
        username: Username;
    };
    query?: never;
    url: '/roles/{roleId}/users/{username}';
};
type AssignRoleToUserErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or user with the given ID or username was not found.
     */
    404: ProblemDetail;
    /**
     * The role is already assigned to the user with the given ID.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type AssignRoleToUserError = AssignRoleToUserErrors[keyof AssignRoleToUserErrors];
type AssignRoleToUserResponses = {
    /**
     * The role was assigned successfully to the user.
     */
    204: void;
};
type AssignRoleToUserResponse = AssignRoleToUserResponses[keyof AssignRoleToUserResponses];
type UnassignRoleFromClientData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The client ID.
         */
        clientId: string;
    };
    query?: never;
    url: '/roles/{roleId}/clients/{clientId}';
};
type UnassignRoleFromClientErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or client with the given ID or username was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UnassignRoleFromClientError = UnassignRoleFromClientErrors[keyof UnassignRoleFromClientErrors];
type UnassignRoleFromClientResponses = {
    /**
     * The role was unassigned successfully from the client.
     */
    204: void;
};
type UnassignRoleFromClientResponse = UnassignRoleFromClientResponses[keyof UnassignRoleFromClientResponses];
type AssignRoleToClientData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The client ID.
         */
        clientId: string;
    };
    query?: never;
    url: '/roles/{roleId}/clients/{clientId}';
};
type AssignRoleToClientErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * The role was already assigned to the client with the given ID.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type AssignRoleToClientError = AssignRoleToClientErrors[keyof AssignRoleToClientErrors];
type AssignRoleToClientResponses = {
    /**
     * The role was assigned successfully to the client.
     */
    204: void;
};
type AssignRoleToClientResponse = AssignRoleToClientResponses[keyof AssignRoleToClientResponses];
type SearchRolesData = {
    body?: RoleSearchQueryRequest;
    path?: never;
    query?: never;
    url: '/roles/search';
};
type SearchRolesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};
type SearchRolesError = SearchRolesErrors[keyof SearchRolesErrors];
type SearchRolesResponses = {
    /**
     * The roles search result.
     */
    200: RoleSearchQueryResult;
};
type SearchRolesResponse = SearchRolesResponses[keyof SearchRolesResponses];
type UnassignRoleFromGroupData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/roles/{roleId}/groups/{groupId}';
};
type UnassignRoleFromGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UnassignRoleFromGroupError = UnassignRoleFromGroupErrors[keyof UnassignRoleFromGroupErrors];
type UnassignRoleFromGroupResponses = {
    /**
     * The role was unassigned successfully from the group.
     */
    204: void;
};
type UnassignRoleFromGroupResponse = UnassignRoleFromGroupResponses[keyof UnassignRoleFromGroupResponses];
type AssignRoleToGroupData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/roles/{roleId}/groups/{groupId}';
};
type AssignRoleToGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * The role is already assigned to the group with the given ID.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type AssignRoleToGroupError = AssignRoleToGroupErrors[keyof AssignRoleToGroupErrors];
type AssignRoleToGroupResponses = {
    /**
     * The role was assigned successfully to the group.
     */
    204: void;
};
type AssignRoleToGroupResponse = AssignRoleToGroupResponses[keyof AssignRoleToGroupResponses];
type SearchGroupsForRoleData = {
    body?: RoleGroupSearchQueryRequest;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}/groups/search';
};
type SearchGroupsForRoleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchGroupsForRoleError = SearchGroupsForRoleErrors[keyof SearchGroupsForRoleErrors];
type SearchGroupsForRoleResponses = {
    /**
     * The groups with assigned role.
     */
    200: RoleGroupSearchResult;
};
type SearchGroupsForRoleResponse = SearchGroupsForRoleResponses[keyof SearchGroupsForRoleResponses];
type UnassignRoleFromMappingRuleData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The mapping rule ID.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/roles/{roleId}/mapping-rules/{mappingRuleId}';
};
type UnassignRoleFromMappingRuleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or mapping rule with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UnassignRoleFromMappingRuleError = UnassignRoleFromMappingRuleErrors[keyof UnassignRoleFromMappingRuleErrors];
type UnassignRoleFromMappingRuleResponses = {
    /**
     * The role was unassigned successfully from the mapping rule.
     */
    204: void;
};
type UnassignRoleFromMappingRuleResponse = UnassignRoleFromMappingRuleResponses[keyof UnassignRoleFromMappingRuleResponses];
type AssignRoleToMappingRuleData = {
    body?: never;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
        /**
         * The mapping rule ID.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/roles/{roleId}/mapping-rules/{mappingRuleId}';
};
type AssignRoleToMappingRuleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role or mapping rule with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * The role is already assigned to the mapping rule with the given ID.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type AssignRoleToMappingRuleError = AssignRoleToMappingRuleErrors[keyof AssignRoleToMappingRuleErrors];
type AssignRoleToMappingRuleResponses = {
    /**
     * The role was assigned successfully to the mapping rule.
     */
    204: void;
};
type AssignRoleToMappingRuleResponse = AssignRoleToMappingRuleResponses[keyof AssignRoleToMappingRuleResponses];
type SearchMappingRulesForRoleData = {
    body?: MappingRuleSearchQueryRequest;
    path: {
        /**
         * The role ID.
         */
        roleId: string;
    };
    query?: never;
    url: '/roles/{roleId}/mapping-rules/search';
};
type SearchMappingRulesForRoleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The role with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchMappingRulesForRoleError = SearchMappingRulesForRoleErrors[keyof SearchMappingRulesForRoleErrors];
type SearchMappingRulesForRoleResponses = {
    /**
     * The mapping rules with assigned role.
     */
    200: MappingRuleSearchQueryResult;
};
type SearchMappingRulesForRoleResponse = SearchMappingRulesForRoleResponses[keyof SearchMappingRulesForRoleResponses];
type CreateGroupData = {
    body?: GroupCreateRequest;
    path?: never;
    query?: never;
    url: '/groups';
};
type CreateGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type CreateGroupError = CreateGroupErrors[keyof CreateGroupErrors];
type CreateGroupResponses = {
    /**
     * The group was created successfully.
     */
    201: GroupCreateResult;
};
type CreateGroupResponse = CreateGroupResponses[keyof CreateGroupResponses];
type DeleteGroupData = {
    body?: never;
    path: {
        /**
         * The ID of the group to delete.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}';
};
type DeleteGroupErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type DeleteGroupError = DeleteGroupErrors[keyof DeleteGroupErrors];
type DeleteGroupResponses = {
    /**
     * The group was deleted successfully.
     */
    204: void;
};
type DeleteGroupResponse = DeleteGroupResponses[keyof DeleteGroupResponses];
type GetGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}';
};
type GetGroupErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetGroupError = GetGroupErrors[keyof GetGroupErrors];
type GetGroupResponses = {
    /**
     * The group is successfully returned.
     */
    200: GroupResult;
};
type GetGroupResponse = GetGroupResponses[keyof GetGroupResponses];
type UpdateGroupData = {
    body: GroupUpdateRequest;
    path: {
        /**
         * The ID of the group to update.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}';
};
type UpdateGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UpdateGroupError = UpdateGroupErrors[keyof UpdateGroupErrors];
type UpdateGroupResponses = {
    /**
     * The group was updated successfully.
     */
    200: GroupUpdateResult;
};
type UpdateGroupResponse = UpdateGroupResponses[keyof UpdateGroupResponses];
type SearchUsersForGroupData = {
    body?: GroupUserSearchQueryRequest;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/users/search';
};
type SearchUsersForGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchUsersForGroupError = SearchUsersForGroupErrors[keyof SearchUsersForGroupErrors];
type SearchUsersForGroupResponses = {
    /**
     * The users assigned to the group.
     */
    200: GroupUserSearchResult;
};
type SearchUsersForGroupResponse = SearchUsersForGroupResponses[keyof SearchUsersForGroupResponses];
type SearchMappingRulesForGroupData = {
    body?: MappingRuleSearchQueryRequest;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/mapping-rules/search';
};
type SearchMappingRulesForGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchMappingRulesForGroupError = SearchMappingRulesForGroupErrors[keyof SearchMappingRulesForGroupErrors];
type SearchMappingRulesForGroupResponses = {
    /**
     * The mapping rules assigned to the group.
     */
    200: MappingRuleSearchQueryResult;
};
type SearchMappingRulesForGroupResponse = SearchMappingRulesForGroupResponses[keyof SearchMappingRulesForGroupResponses];
type SearchRolesForGroupData = {
    body?: RoleSearchQueryRequest;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/roles/search';
};
type SearchRolesForGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchRolesForGroupError = SearchRolesForGroupErrors[keyof SearchRolesForGroupErrors];
type SearchRolesForGroupResponses = {
    /**
     * The roles assigned to the group.
     */
    200: RoleSearchQueryResult;
};
type SearchRolesForGroupResponse = SearchRolesForGroupResponses[keyof SearchRolesForGroupResponses];
type SearchClientsForGroupData = {
    body?: GroupClientSearchQueryRequest;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/clients/search';
};
type SearchClientsForGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchClientsForGroupError = SearchClientsForGroupErrors[keyof SearchClientsForGroupErrors];
type SearchClientsForGroupResponses = {
    /**
     * The clients assigned to the group.
     */
    200: GroupClientSearchResult;
};
type SearchClientsForGroupResponse = SearchClientsForGroupResponses[keyof SearchClientsForGroupResponses];
type UnassignUserFromGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
        /**
         * The user username.
         */
        username: Username;
    };
    query?: never;
    url: '/groups/{groupId}/users/{username}';
};
type UnassignUserFromGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group or user with the given ID was not found, or the user is not assigned to this group.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UnassignUserFromGroupError = UnassignUserFromGroupErrors[keyof UnassignUserFromGroupErrors];
type UnassignUserFromGroupResponses = {
    /**
     * The user was unassigned successfully from the group.
     */
    204: void;
};
type UnassignUserFromGroupResponse = UnassignUserFromGroupResponses[keyof UnassignUserFromGroupResponses];
type AssignUserToGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
        /**
         * The user username.
         */
        username: Username;
    };
    query?: never;
    url: '/groups/{groupId}/users/{username}';
};
type AssignUserToGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group or user with the given ID or username was not found.
     */
    404: ProblemDetail;
    /**
     * The user with the given ID is already assigned to the group.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type AssignUserToGroupError = AssignUserToGroupErrors[keyof AssignUserToGroupErrors];
type AssignUserToGroupResponses = {
    /**
     * The user was assigned successfully to the group.
     */
    204: void;
};
type AssignUserToGroupResponse = AssignUserToGroupResponses[keyof AssignUserToGroupResponses];
type UnassignClientFromGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
        /**
         * The client ID.
         */
        clientId: string;
    };
    query?: never;
    url: '/groups/{groupId}/clients/{clientId}';
};
type UnassignClientFromGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found, or the client is not assigned to this group.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UnassignClientFromGroupError = UnassignClientFromGroupErrors[keyof UnassignClientFromGroupErrors];
type UnassignClientFromGroupResponses = {
    /**
     * The client was unassigned successfully from the group.
     */
    204: void;
};
type UnassignClientFromGroupResponse = UnassignClientFromGroupResponses[keyof UnassignClientFromGroupResponses];
type AssignClientToGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
        /**
         * The client ID.
         */
        clientId: string;
    };
    query?: never;
    url: '/groups/{groupId}/clients/{clientId}';
};
type AssignClientToGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * The client with the given ID is already assigned to the group.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type AssignClientToGroupError = AssignClientToGroupErrors[keyof AssignClientToGroupErrors];
type AssignClientToGroupResponses = {
    /**
     * The client was assigned successfully to the group.
     */
    204: void;
};
type AssignClientToGroupResponse = AssignClientToGroupResponses[keyof AssignClientToGroupResponses];
type UnassignMappingRuleFromGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
        /**
         * The mapping rule ID.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/groups/{groupId}/mapping-rules/{mappingRuleId}';
};
type UnassignMappingRuleFromGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group or mapping rule with the given ID was not found, or the mapping rule is not assigned to this group.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UnassignMappingRuleFromGroupError = UnassignMappingRuleFromGroupErrors[keyof UnassignMappingRuleFromGroupErrors];
type UnassignMappingRuleFromGroupResponses = {
    /**
     * The mapping rule was unassigned successfully from the group.
     */
    204: void;
};
type UnassignMappingRuleFromGroupResponse = UnassignMappingRuleFromGroupResponses[keyof UnassignMappingRuleFromGroupResponses];
type AssignMappingRuleToGroupData = {
    body?: never;
    path: {
        /**
         * The group ID.
         */
        groupId: string;
        /**
         * The mapping rule ID.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/groups/{groupId}/mapping-rules/{mappingRuleId}';
};
type AssignMappingRuleToGroupErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The group or mapping rule with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * The mapping rule with the given ID is already assigned to the group.
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type AssignMappingRuleToGroupError = AssignMappingRuleToGroupErrors[keyof AssignMappingRuleToGroupErrors];
type AssignMappingRuleToGroupResponses = {
    /**
     * The mapping rule was assigned successfully to the group.
     */
    204: void;
};
type AssignMappingRuleToGroupResponse = AssignMappingRuleToGroupResponses[keyof AssignMappingRuleToGroupResponses];
type SearchGroupsData = {
    body?: GroupSearchQueryRequest;
    path?: never;
    query?: never;
    url: '/groups/search';
};
type SearchGroupsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     */
    500: ProblemDetail;
};
type SearchGroupsError = SearchGroupsErrors[keyof SearchGroupsErrors];
type SearchGroupsResponses = {
    /**
     * The groups search result.
     */
    200: GroupSearchQueryResult;
};
type SearchGroupsResponse = SearchGroupsResponses[keyof SearchGroupsResponses];
type CreateMappingRuleData = {
    body?: MappingRuleCreateRequest;
    path?: never;
    query?: never;
    url: '/mapping-rules';
};
type CreateMappingRuleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request to create a mapping rule was denied.
     * More details are provided in the response body.
     *
     */
    403: ProblemDetail;
    /**
     * The request to create a mapping rule was denied.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type CreateMappingRuleError = CreateMappingRuleErrors[keyof CreateMappingRuleErrors];
type CreateMappingRuleResponses = {
    /**
     * The mapping rule was created successfully.
     */
    201: MappingRuleCreateResult;
};
type CreateMappingRuleResponse = CreateMappingRuleResponses[keyof CreateMappingRuleResponses];
type DeleteMappingRuleData = {
    body?: never;
    path: {
        /**
         * The ID of the mapping rule to delete.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/mapping-rules/{mappingRuleId}';
};
type DeleteMappingRuleErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The mapping rule with the mappingRuleId was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type DeleteMappingRuleError = DeleteMappingRuleErrors[keyof DeleteMappingRuleErrors];
type DeleteMappingRuleResponses = {
    /**
     * The mapping rule was deleted successfully.
     */
    204: void;
};
type DeleteMappingRuleResponse = DeleteMappingRuleResponses[keyof DeleteMappingRuleResponses];
type GetMappingRuleData = {
    body?: never;
    path: {
        /**
         * The ID of the mapping rule to get.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/mapping-rules/{mappingRuleId}';
};
type GetMappingRuleErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * The mapping rule with the mappingRuleId was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetMappingRuleError = GetMappingRuleErrors[keyof GetMappingRuleErrors];
type GetMappingRuleResponses = {
    /**
     * The mapping rule was returned successfully.
     */
    200: MappingRuleResult;
};
type GetMappingRuleResponse = GetMappingRuleResponses[keyof GetMappingRuleResponses];
type UpdateMappingRuleData = {
    body?: MappingRuleUpdateRequest;
    path: {
        /**
         * The ID of the mapping rule to update.
         */
        mappingRuleId: string;
    };
    query?: never;
    url: '/mapping-rules/{mappingRuleId}';
};
type UpdateMappingRuleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request to update a mapping rule was denied.
     * More details are provided in the response body.
     *
     */
    403: ProblemDetail;
    /**
     * The request to update a mapping rule was denied.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UpdateMappingRuleError = UpdateMappingRuleErrors[keyof UpdateMappingRuleErrors];
type UpdateMappingRuleResponses = {
    /**
     * The mapping rule was updated successfully.
     */
    200: MappingRuleUpdateResult;
};
type UpdateMappingRuleResponse = UpdateMappingRuleResponses[keyof UpdateMappingRuleResponses];
type SearchMappingRuleData = {
    body?: MappingRuleSearchQueryRequest;
    path?: never;
    query?: never;
    url: '/mapping-rules/search';
};
type SearchMappingRuleErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchMappingRuleError = SearchMappingRuleErrors[keyof SearchMappingRuleErrors];
type SearchMappingRuleResponses = {
    /**
     * The mapping rule search result.
     */
    200: MappingRuleSearchQueryResult;
};
type SearchMappingRuleResponse = SearchMappingRuleResponses[keyof SearchMappingRuleResponses];
type PublishMessageData = {
    body: MessagePublicationRequest;
    path?: never;
    query?: never;
    url: '/messages/publication';
};
type PublishMessageErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type PublishMessageError = PublishMessageErrors[keyof PublishMessageErrors];
type PublishMessageResponses = {
    /**
     * The message was published.
     */
    200: MessagePublicationResult;
};
type PublishMessageResponse = PublishMessageResponses[keyof PublishMessageResponses];
type CorrelateMessageData = {
    body: MessageCorrelationRequest;
    path?: never;
    query?: never;
    url: '/messages/correlation';
};
type CorrelateMessageErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type CorrelateMessageError = CorrelateMessageErrors[keyof CorrelateMessageErrors];
type CorrelateMessageResponses = {
    /**
     * The message is correlated to one or more process instances
     */
    200: MessageCorrelationResult;
};
type CorrelateMessageResponse = CorrelateMessageResponses[keyof CorrelateMessageResponses];
type SearchCorrelatedMessageSubscriptionsData = {
    body?: CorrelatedMessageSubscriptionSearchQuery;
    path?: never;
    query?: never;
    url: '/correlated-message-subscriptions/search';
};
type SearchCorrelatedMessageSubscriptionsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchCorrelatedMessageSubscriptionsError = SearchCorrelatedMessageSubscriptionsErrors[keyof SearchCorrelatedMessageSubscriptionsErrors];
type SearchCorrelatedMessageSubscriptionsResponses = {
    /**
     * The correlated message subscriptions search result.
     */
    200: CorrelatedMessageSubscriptionSearchQueryResult;
};
type SearchCorrelatedMessageSubscriptionsResponse = SearchCorrelatedMessageSubscriptionsResponses[keyof SearchCorrelatedMessageSubscriptionsResponses];
type SearchMessageSubscriptionsData = {
    body?: MessageSubscriptionSearchQuery;
    path?: never;
    query?: never;
    url: '/message-subscriptions/search';
};
type SearchMessageSubscriptionsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchMessageSubscriptionsError = SearchMessageSubscriptionsErrors[keyof SearchMessageSubscriptionsErrors];
type SearchMessageSubscriptionsResponses = {
    /**
     * The message subscription search result.
     */
    200: MessageSubscriptionSearchQueryResult;
};
type SearchMessageSubscriptionsResponse = SearchMessageSubscriptionsResponses[keyof SearchMessageSubscriptionsResponses];
type CreateDocumentData = {
    body: {
        file: Blob | File;
        metadata?: DocumentMetadata;
    };
    path?: never;
    query?: {
        /**
         * The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.
         */
        storeId?: string;
        /**
         * The ID of the document to upload. If not provided, a new ID will be generated. Specifying an existing ID will result in an error if the document already exists.
         *
         */
        documentId?: string;
    };
    url: '/documents';
};
type CreateDocumentErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The server cannot process the request because the media type (Content-Type) of the request payload is not supported  by the server for the requested resource and method.
     *
     */
    415: ProblemDetail;
};
type CreateDocumentError = CreateDocumentErrors[keyof CreateDocumentErrors];
type CreateDocumentResponses = {
    /**
     * The document was uploaded successfully.
     */
    201: DocumentReference;
};
type CreateDocumentResponse = CreateDocumentResponses[keyof CreateDocumentResponses];
type CreateDocumentsData = {
    body: {
        /**
         * The documents to upload.
         */
        files: Array<Blob | File>;
        /**
         * Optional JSON array of metadata object whose index aligns with each file entry. The metadata array must have the same length as the files array.
         *
         */
        metadataList?: Array<DocumentMetadata>;
    };
    path?: never;
    query?: {
        /**
         * The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores.
         */
        storeId?: string;
    };
    url: '/documents/batch';
};
type CreateDocumentsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The server cannot process the request because the media type (Content-Type) of the request payload is not supported  by the server for the requested resource and method.
     *
     */
    415: ProblemDetail;
};
type CreateDocumentsError = CreateDocumentsErrors[keyof CreateDocumentsErrors];
type CreateDocumentsResponses = {
    /**
     * All documents were uploaded successfully.
     */
    201: DocumentCreationBatchResponse;
    /**
     * Not all documents were uploaded successfully. More details are provided in the response body.
     *
     */
    207: DocumentCreationBatchResponse;
};
type CreateDocumentsResponse = CreateDocumentsResponses[keyof CreateDocumentsResponses];
type DeleteDocumentData = {
    body?: never;
    path: {
        /**
         * The ID of the document to delete.
         */
        documentId: DocumentId;
    };
    query?: {
        /**
         * The ID of the document store to delete the document from.
         */
        storeId?: string;
    };
    url: '/documents/{documentId}';
};
type DeleteDocumentErrors = {
    /**
     * The document with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type DeleteDocumentError = DeleteDocumentErrors[keyof DeleteDocumentErrors];
type DeleteDocumentResponses = {
    /**
     * The document was deleted successfully.
     */
    204: void;
};
type DeleteDocumentResponse = DeleteDocumentResponses[keyof DeleteDocumentResponses];
type GetDocumentData = {
    body?: never;
    path: {
        /**
         * The ID of the document to download.
         */
        documentId: DocumentId;
    };
    query: {
        /**
         * The ID of the document store to download the document from.
         */
        storeId?: string;
        /**
         * The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.
         *
         */
        contentHash: string;
    };
    url: '/documents/{documentId}';
};
type GetDocumentErrors = {
    /**
     * The document with the given ID was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetDocumentError = GetDocumentErrors[keyof GetDocumentErrors];
type GetDocumentResponses = {
    /**
     * The document was downloaded successfully.
     */
    200: Blob | File;
};
type GetDocumentResponse = GetDocumentResponses[keyof GetDocumentResponses];
type CreateDocumentLinkData = {
    body?: DocumentLinkRequest;
    path: {
        /**
         * The ID of the document to link.
         */
        documentId: DocumentId;
    };
    query: {
        /**
         * The ID of the document store to link the document from.
         */
        storeId?: string;
        /**
         * The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.
         *
         */
        contentHash: string;
    };
    url: '/documents/{documentId}/links';
};
type CreateDocumentLinkErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
};
type CreateDocumentLinkError = CreateDocumentLinkErrors[keyof CreateDocumentLinkErrors];
type CreateDocumentLinkResponses = {
    /**
     * The document link was created successfully.
     */
    201: DocumentLink;
};
type CreateDocumentLinkResponse = CreateDocumentLinkResponses[keyof CreateDocumentLinkResponses];
type CreateUserData = {
    body: UserRequest;
    path?: never;
    query?: never;
    url: '/users';
};
type CreateUserErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * A user with the given username already exists.
     *
     */
    409: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type CreateUserError = CreateUserErrors[keyof CreateUserErrors];
type CreateUserResponses = {
    /**
     * The user was created successfully.
     *
     */
    201: UserCreateResult;
};
type CreateUserResponse = CreateUserResponses[keyof CreateUserResponses];
type SearchUsersData = {
    body?: UserSearchQueryRequest;
    path?: never;
    query?: never;
    url: '/users/search';
};
type SearchUsersErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchUsersError = SearchUsersErrors[keyof SearchUsersErrors];
type SearchUsersResponses = {
    /**
     * The user search result.
     */
    200: UserSearchResult;
};
type SearchUsersResponse = SearchUsersResponses[keyof SearchUsersResponses];
type DeleteUserData = {
    body?: never;
    path: {
        /**
         * The username of the user to delete.
         */
        username: Username;
    };
    query?: never;
    url: '/users/{username}';
};
type DeleteUserErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The user is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type DeleteUserError = DeleteUserErrors[keyof DeleteUserErrors];
type DeleteUserResponses = {
    /**
     * The user was deleted successfully.
     */
    204: void;
};
type DeleteUserResponse = DeleteUserResponses[keyof DeleteUserResponses];
type GetUserData = {
    body?: never;
    path: {
        /**
         * The username of the user.
         */
        username: Username;
    };
    query?: never;
    url: '/users/{username}';
};
type GetUserErrors = {
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The user with the given username was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetUserError = GetUserErrors[keyof GetUserErrors];
type GetUserResponses = {
    /**
     * The user is successfully returned.
     */
    200: UserResult;
};
type GetUserResponse = GetUserResponses[keyof GetUserResponses];
type UpdateUserData = {
    body: UserUpdateRequest;
    path: {
        /**
         * The username of the user to update.
         */
        username: Username;
    };
    query?: never;
    url: '/users/{username}';
};
type UpdateUserErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The user was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type UpdateUserError = UpdateUserErrors[keyof UpdateUserErrors];
type UpdateUserResponses = {
    /**
     * The user was updated successfully.
     */
    200: UserUpdateResult;
};
type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses];
type CreateAdminUserData = {
    body: UserRequest;
    path?: never;
    query?: never;
    url: '/setup/user';
};
type CreateAdminUserErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type CreateAdminUserError = CreateAdminUserErrors[keyof CreateAdminUserErrors];
type CreateAdminUserResponses = {
    /**
     * The user was created and got assigned the admin role successfully.
     *
     */
    201: UserCreateResult;
};
type CreateAdminUserResponse = CreateAdminUserResponses[keyof CreateAdminUserResponses];
type SearchIncidentsData = {
    body?: IncidentSearchQuery;
    path?: never;
    query?: never;
    url: '/incidents/search';
};
type SearchIncidentsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchIncidentsError = SearchIncidentsErrors[keyof SearchIncidentsErrors];
type SearchIncidentsResponses = {
    /**
     * The incident search result.
     *
     */
    200: IncidentSearchQueryResult;
};
type SearchIncidentsResponse = SearchIncidentsResponses[keyof SearchIncidentsResponses];
type GetIncidentData = {
    body?: never;
    path: {
        /**
         * The assigned key of the incident, which acts as a unique identifier for this incident.
         */
        incidentKey: IncidentKey;
    };
    query?: never;
    url: '/incidents/{incidentKey}';
};
type GetIncidentErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The incident with the given key was not found. More details are provided in the response body.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetIncidentError = GetIncidentErrors[keyof GetIncidentErrors];
type GetIncidentResponses = {
    /**
     * The incident is successfully returned.
     */
    200: IncidentResult;
};
type GetIncidentResponse = GetIncidentResponses[keyof GetIncidentResponses];
type GetUsageMetricsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The start date for usage metrics, including this date. Value in ISO 8601 format.
         */
        startTime: string;
        /**
         * The end date for usage metrics, including this date. Value in ISO 8601 format.
         */
        endTime: string;
        /**
         * Restrict results to a specific tenant ID. If not provided, results for all tenants are returned.
         */
        tenantId?: TenantId;
        /**
         * Whether to return tenant metrics in addition to the total metrics or not. Default false.
         */
        withTenants?: boolean;
    };
    url: '/system/usage-metrics';
};
type GetUsageMetricsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetUsageMetricsError = GetUsageMetricsErrors[keyof GetUsageMetricsErrors];
type GetUsageMetricsResponses = {
    /**
     * The usage metrics search result.
     */
    200: UsageMetricsResponse;
};
type GetUsageMetricsResponse = GetUsageMetricsResponses[keyof GetUsageMetricsResponses];
type CreateDeploymentData = {
    body: {
        /**
         * The binary data to create the deployment resources. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
         *
         */
        resources: Array<Blob | File>;
        /**
         * The tenant to deploy the resources to.
         */
        tenantId?: string;
    };
    path?: never;
    query?: never;
    url: '/deployments';
};
type CreateDeploymentErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type CreateDeploymentError = CreateDeploymentErrors[keyof CreateDeploymentErrors];
type CreateDeploymentResponses = {
    /**
     * The resources are deployed.
     */
    200: DeploymentResult;
};
type CreateDeploymentResponse = CreateDeploymentResponses[keyof CreateDeploymentResponses];
type DeleteResourceData = {
    body?: DeleteResourceRequest;
    path: {
        /**
         * The key of the resource to delete.
         * This can be the key of a process definition, the key of a decision requirements
         * definition or the key of a form definition
         *
         */
        resourceKey: ResourceKey;
    };
    query?: never;
    url: '/resources/{resourceKey}/deletion';
};
type DeleteResourceErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The resource is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type DeleteResourceError = DeleteResourceErrors[keyof DeleteResourceErrors];
type DeleteResourceResponses = {
    /**
     * The resource is deleted.
     */
    200: unknown;
};
type GetResourceData = {
    body?: never;
    path: {
        /**
         * The unique key identifying the resource.
         */
        resourceKey: ResourceKey;
    };
    query?: never;
    url: '/resources/{resourceKey}';
};
type GetResourceErrors = {
    /**
     * A resource with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetResourceError = GetResourceErrors[keyof GetResourceErrors];
type GetResourceResponses = {
    /**
     * The resource is successfully returned.
     */
    200: ResourceResult;
};
type GetResourceResponse = GetResourceResponses[keyof GetResourceResponses];
type GetResourceContentData = {
    body?: never;
    path: {
        /**
         * The unique key identifying the resource.
         */
        resourceKey: ResourceKey;
    };
    query?: never;
    url: '/resources/{resourceKey}/content';
};
type GetResourceContentErrors = {
    /**
     * A resource with the given key was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetResourceContentError = GetResourceContentErrors[keyof GetResourceContentErrors];
type GetResourceContentResponses = {
    /**
     * The resource content is successfully returned.
     */
    200: string;
};
type GetResourceContentResponse = GetResourceContentResponses[keyof GetResourceContentResponses];
type CreateElementInstanceVariablesData = {
    body: SetVariableRequest;
    path: {
        /**
         * The key of the element instance to update the variables for.
         * This can be the process instance key (as obtained during instance creation), or a given
         * element, such as a service task (see the `elementInstanceKey` on the job message).
         *
         */
        elementInstanceKey: ElementInstanceKey;
    };
    query?: never;
    url: '/element-instances/{elementInstanceKey}/variables';
};
type CreateElementInstanceVariablesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type CreateElementInstanceVariablesError = CreateElementInstanceVariablesErrors[keyof CreateElementInstanceVariablesErrors];
type CreateElementInstanceVariablesResponses = {
    /**
     * The variables were updated.
     */
    204: void;
};
type CreateElementInstanceVariablesResponse = CreateElementInstanceVariablesResponses[keyof CreateElementInstanceVariablesResponses];
type ActivateAdHocSubProcessActivitiesData = {
    body: AdHocSubProcessActivateActivitiesInstruction;
    path: {
        /**
         * The key of the ad-hoc sub-process instance that contains the activities.
         */
        adHocSubProcessInstanceKey: ElementInstanceKey;
    };
    query?: never;
    url: '/element-instances/ad-hoc-activities/{adHocSubProcessInstanceKey}/activation';
};
type ActivateAdHocSubProcessActivitiesErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The request lacks valid authentication credentials.
     */
    401: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * The ad-hoc sub-process instance is not found or the provided key does not identify an
     * ad-hoc sub-process.
     *
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type ActivateAdHocSubProcessActivitiesError = ActivateAdHocSubProcessActivitiesErrors[keyof ActivateAdHocSubProcessActivitiesErrors];
type ActivateAdHocSubProcessActivitiesResponses = {
    /**
     * The ad-hoc sub-process instance is modified.
     */
    204: void;
};
type ActivateAdHocSubProcessActivitiesResponse = ActivateAdHocSubProcessActivitiesResponses[keyof ActivateAdHocSubProcessActivitiesResponses];
type BroadcastSignalData = {
    body: SignalBroadcastRequest;
    path?: never;
    query?: never;
    url: '/signals/broadcast';
};
type BroadcastSignalErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The signal is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type BroadcastSignalError = BroadcastSignalErrors[keyof BroadcastSignalErrors];
type BroadcastSignalResponses = {
    /**
     * The signal was broadcast.
     */
    200: SignalBroadcastResult;
};
type BroadcastSignalResponse = BroadcastSignalResponses[keyof BroadcastSignalResponses];
type GetBatchOperationData = {
    body?: never;
    path: {
        /**
         * The key (or operate legacy ID) of the batch operation.
         *
         */
        batchOperationKey: BatchOperationKey;
    };
    query?: never;
    url: '/batch-operations/{batchOperationKey}';
};
type GetBatchOperationErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * The batch operation is not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type GetBatchOperationError = GetBatchOperationErrors[keyof GetBatchOperationErrors];
type GetBatchOperationResponses = {
    /**
     * The batch operation was found.
     */
    200: BatchOperationResponse;
};
type GetBatchOperationResponse = GetBatchOperationResponses[keyof GetBatchOperationResponses];
type SearchBatchOperationsData = {
    body?: BatchOperationSearchQuery;
    path?: never;
    query?: never;
    url: '/batch-operations/search';
};
type SearchBatchOperationsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchBatchOperationsError = SearchBatchOperationsErrors[keyof SearchBatchOperationsErrors];
type SearchBatchOperationsResponses = {
    /**
     * The batch operation search result.
     */
    200: BatchOperationSearchQueryResult;
};
type SearchBatchOperationsResponse = SearchBatchOperationsResponses[keyof SearchBatchOperationsResponses];
type CancelBatchOperationData = {
    body?: unknown;
    path: {
        /**
         * The key (or operate legacy ID) of the batch operation.
         *
         */
        batchOperationKey: BatchOperationKey;
    };
    query?: never;
    url: '/batch-operations/{batchOperationKey}/cancellation';
};
type CancelBatchOperationErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The batch operation was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type CancelBatchOperationError = CancelBatchOperationErrors[keyof CancelBatchOperationErrors];
type CancelBatchOperationResponses = {
    /**
     * The batch operation cancel request was created.
     */
    204: void;
};
type CancelBatchOperationResponse = CancelBatchOperationResponses[keyof CancelBatchOperationResponses];
type SuspendBatchOperationData = {
    body?: unknown;
    path: {
        /**
         * The key (or operate legacy ID) of the batch operation.
         *
         */
        batchOperationKey: BatchOperationKey;
    };
    query?: never;
    url: '/batch-operations/{batchOperationKey}/suspension';
};
type SuspendBatchOperationErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The batch operation was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type SuspendBatchOperationError = SuspendBatchOperationErrors[keyof SuspendBatchOperationErrors];
type SuspendBatchOperationResponses = {
    /**
     * The batch operation pause request was created.
     */
    204: void;
};
type SuspendBatchOperationResponse = SuspendBatchOperationResponses[keyof SuspendBatchOperationResponses];
type ResumeBatchOperationData = {
    body?: unknown;
    path: {
        /**
         * The key (or operate legacy ID) of the batch operation.
         *
         */
        batchOperationKey: BatchOperationKey;
    };
    query?: never;
    url: '/batch-operations/{batchOperationKey}/resumption';
};
type ResumeBatchOperationErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * Forbidden. The request is not allowed.
     */
    403: ProblemDetail;
    /**
     * Not found. The batch operation was not found.
     */
    404: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
    /**
     * The service is currently unavailable. This may happen only on some requests where the system creates backpressure to prevent the server's compute resources from being exhausted, avoiding more severe failures. In this case, the title of the error object contains `RESOURCE_EXHAUSTED`. Clients are recommended to eventually retry those requests after a backoff period. You can learn more about the backpressure mechanism here: https://docs.camunda.io/docs/components/zeebe/technical-concepts/internal-processing/#handling-backpressure .
     *
     */
    503: ProblemDetail;
};
type ResumeBatchOperationError = ResumeBatchOperationErrors[keyof ResumeBatchOperationErrors];
type ResumeBatchOperationResponses = {
    /**
     * The batch operation resume request was created.
     */
    204: void;
};
type ResumeBatchOperationResponse = ResumeBatchOperationResponses[keyof ResumeBatchOperationResponses];
type SearchBatchOperationItemsData = {
    body?: BatchOperationItemSearchQuery;
    path?: never;
    query?: never;
    url: '/batch-operation-items/search';
};
type SearchBatchOperationItemsErrors = {
    /**
     * The provided data is not valid.
     */
    400: ProblemDetail;
    /**
     * An internal error occurred while processing the request.
     *
     */
    500: ProblemDetail;
};
type SearchBatchOperationItemsError = SearchBatchOperationItemsErrors[keyof SearchBatchOperationItemsErrors];
type SearchBatchOperationItemsResponses = {
    /**
     * The batch operation search result.
     */
    200: BatchOperationItemSearchQueryResult;
};
type SearchBatchOperationItemsResponse = SearchBatchOperationItemsResponses[keyof SearchBatchOperationItemsResponses];
type ClientOptions = {
    baseUrl: '{schema}://{host}:{port}/v2' | (string & {});
};
declare function assertConstraint(value: string, label: string, c: {
    pattern?: string;
    minLength?: number;
    maxLength?: number;
}): void;
/**
 * System-generated key for an authorization.
 */
type AuthorizationKey = CamundaKey<'AuthorizationKey'>;
declare namespace AuthorizationKey {
    function assumeExists(value: string): AuthorizationKey;
    function getValue(key: AuthorizationKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for an batch operation.
 */
type BatchOperationKey = CamundaKey<'BatchOperationKey'>;
declare namespace BatchOperationKey {
    function assumeExists(value: string): BatchOperationKey;
    function getValue(key: BatchOperationKey): string;
    function isValid(value: string): boolean;
}
/**
 * Id of a decision definition, from the model. Only ids of decision definitions that are deployed are useful.
 */
type DecisionDefinitionId = CamundaKey<'DecisionDefinitionId'>;
declare namespace DecisionDefinitionId {
    function assumeExists(value: string): DecisionDefinitionId;
    function getValue(key: DecisionDefinitionId): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a decision definition.
 */
type DecisionDefinitionKey = CamundaKey<'DecisionDefinitionKey'>;
declare namespace DecisionDefinitionKey {
    function assumeExists(value: string): DecisionDefinitionKey;
    function getValue(key: DecisionDefinitionKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a decision evaluation instance.
 */
type DecisionEvaluationInstanceKey = CamundaKey<'DecisionEvaluationInstanceKey'>;
declare namespace DecisionEvaluationInstanceKey {
    function assumeExists(value: string): DecisionEvaluationInstanceKey;
    function getValue(key: DecisionEvaluationInstanceKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a decision evaluation.
 */
type DecisionEvaluationKey = CamundaKey<'DecisionEvaluationKey'>;
declare namespace DecisionEvaluationKey {
    function assumeExists(value: string): DecisionEvaluationKey;
    function getValue(key: DecisionEvaluationKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a deployed decision instance.
 */
type DecisionInstanceKey = CamundaKey<'DecisionInstanceKey'>;
declare namespace DecisionInstanceKey {
    function assumeExists(value: string): DecisionInstanceKey;
    function getValue(key: DecisionInstanceKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a deployed decision requirements definition.
 */
type DecisionRequirementsKey = CamundaKey<'DecisionRequirementsKey'>;
declare namespace DecisionRequirementsKey {
    function assumeExists(value: string): DecisionRequirementsKey;
    function getValue(key: DecisionRequirementsKey): string;
    function isValid(value: string): boolean;
}
/**
 * Key for a deployment.
 */
type DeploymentKey = CamundaKey<'DeploymentKey'>;
declare namespace DeploymentKey {
    function assumeExists(value: string): DeploymentKey;
    function getValue(key: DeploymentKey): string;
    function isValid(value: string): boolean;
}
/**
 * Document Id that uniquely identifies a document.
 */
type DocumentId = CamundaKey<'DocumentId'>;
declare namespace DocumentId {
    function assumeExists(value: string): DocumentId;
    function getValue(key: DocumentId): string;
    function isValid(value: string): boolean;
}
/**
 * The model-defined id of an element.
 */
type ElementId = CamundaKey<'ElementId'>;
declare namespace ElementId {
    function assumeExists(value: string): ElementId;
    function getValue(key: ElementId): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a element instance.
 */
type ElementInstanceKey = CamundaKey<'ElementInstanceKey'>;
declare namespace ElementInstanceKey {
    function assumeExists(value: string): ElementInstanceKey;
    function getValue(key: ElementInstanceKey): string;
    function isValid(value: string): boolean;
}
/**
 * The end cursor in a search query result set.
 */
type EndCursor = CamundaKey<'EndCursor'>;
declare namespace EndCursor {
    function assumeExists(value: string): EndCursor;
    function getValue(key: EndCursor): string;
    function isValid(value: string): boolean;
}
/**
 * The user-defined id for the form
 */
type FormId = CamundaKey<'FormId'>;
declare namespace FormId {
    function assumeExists(value: string): FormId;
    function getValue(key: FormId): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a deployed form.
 */
type FormKey = CamundaKey<'FormKey'>;
declare namespace FormKey {
    function assumeExists(value: string): FormKey;
    function getValue(key: FormKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a incident.
 */
type IncidentKey = CamundaKey<'IncidentKey'>;
declare namespace IncidentKey {
    function assumeExists(value: string): IncidentKey;
    function getValue(key: IncidentKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a job.
 */
type JobKey = CamundaKey<'JobKey'>;
declare namespace JobKey {
    function assumeExists(value: string): JobKey;
    function getValue(key: JobKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a message correlation.
 */
type MessageCorrelationKey = CamundaKey<'MessageCorrelationKey'>;
declare namespace MessageCorrelationKey {
    function assumeExists(value: string): MessageCorrelationKey;
    function getValue(key: MessageCorrelationKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for an message.
 */
type MessageKey = CamundaKey<'MessageKey'>;
declare namespace MessageKey {
    function assumeExists(value: string): MessageKey;
    function getValue(key: MessageKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a message subscription.
 */
type MessageSubscriptionKey = CamundaKey<'MessageSubscriptionKey'>;
declare namespace MessageSubscriptionKey {
    function assumeExists(value: string): MessageSubscriptionKey;
    function getValue(key: MessageSubscriptionKey): string;
    function isValid(value: string): boolean;
}
/**
 * Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
 */
type ProcessDefinitionId = CamundaKey<'ProcessDefinitionId'>;
declare namespace ProcessDefinitionId {
    function assumeExists(value: string): ProcessDefinitionId;
    function getValue(key: ProcessDefinitionId): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a deployed process definition.
 */
type ProcessDefinitionKey = CamundaKey<'ProcessDefinitionKey'>;
declare namespace ProcessDefinitionKey {
    function assumeExists(value: string): ProcessDefinitionKey;
    function getValue(key: ProcessDefinitionKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a process instance.
 */
type ProcessInstanceKey = CamundaKey<'ProcessInstanceKey'>;
declare namespace ProcessInstanceKey {
    function assumeExists(value: string): ProcessInstanceKey;
    function getValue(key: ProcessInstanceKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a scope.
 */
type ScopeKey = CamundaKey<'ScopeKey'>;
declare namespace ScopeKey {
    function assumeExists(value: string): ScopeKey;
    function getValue(key: ScopeKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for an signal.
 */
type SignalKey = CamundaKey<'SignalKey'>;
declare namespace SignalKey {
    function assumeExists(value: string): SignalKey;
    function getValue(key: SignalKey): string;
    function isValid(value: string): boolean;
}
/**
 * The start cursor in a search query result set.
 */
type StartCursor = CamundaKey<'StartCursor'>;
declare namespace StartCursor {
    function assumeExists(value: string): StartCursor;
    function getValue(key: StartCursor): string;
    function isValid(value: string): boolean;
}
/**
 * A tag. Needs to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length  100.
 */
type Tag = CamundaKey<'Tag'>;
declare namespace Tag {
    function fromString(value: string): Tag;
    function getValue(key: Tag): string;
    function isValid(value: string): boolean;
}
/**
 * The unique identifier of the tenant.
 */
type TenantId = CamundaKey<'TenantId'>;
declare namespace TenantId {
    function assumeExists(value: string): TenantId;
    function getValue(key: TenantId): string;
    function isValid(value: string): boolean;
}
/**
 * The unique name of a user.
 */
type Username = CamundaKey<'Username'>;
declare namespace Username {
    function assumeExists(value: string): Username;
    function getValue(key: Username): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a user task.
 */
type UserTaskKey = CamundaKey<'UserTaskKey'>;
declare namespace UserTaskKey {
    function assumeExists(value: string): UserTaskKey;
    function getValue(key: UserTaskKey): string;
    function isValid(value: string): boolean;
}
/**
 * System-generated key for a variable.
 */
type VariableKey = CamundaKey<'VariableKey'>;
declare namespace VariableKey {
    function assumeExists(value: string): VariableKey;
    function getValue(key: VariableKey): string;
    function isValid(value: string): boolean;
}

type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options$1<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};
/**
 * Get cluster topology
 * Obtains the current topology of the cluster the gateway is part of.
 */
declare const getTopology: <ThrowOnError extends boolean = true>(options?: Options<GetTopologyData, ThrowOnError>) => RequestResult<GetTopologyResponses, GetTopologyErrors, ThrowOnError, "fields">;
/**
 * Get cluster status
 * Checks the health status of the cluster by verifying if there's at least one partition with a healthy leader.
 */
declare const getStatus: <ThrowOnError extends boolean = true>(options?: Options<GetStatusData, ThrowOnError>) => RequestResult<GetStatusResponses, GetStatusErrors, ThrowOnError, "fields">;
/**
 * Get license status
 * Obtains the status of the current Camunda license.
 */
declare const getLicense: <ThrowOnError extends boolean = true>(options?: Options<GetLicenseData, ThrowOnError>) => RequestResult<GetLicenseResponses, GetLicenseErrors, ThrowOnError, "fields">;
/**
 * Get current user
 * Retrieves the current authenticated user.
 */
declare const getAuthentication: <ThrowOnError extends boolean = true>(options?: Options<GetAuthenticationData, ThrowOnError>) => RequestResult<GetAuthenticationResponses, GetAuthenticationErrors, ThrowOnError, "fields">;
/**
 * Activate jobs
 * Iterate through all known partitions and activate jobs up to the requested maximum.
 *
 */
declare const activateJobs: <ThrowOnError extends boolean = true>(options: Options<ActivateJobsData, ThrowOnError>) => RequestResult<ActivateJobsResponses, ActivateJobsErrors, ThrowOnError, "fields">;
/**
 * Search jobs
 * Search for jobs based on given criteria.
 */
declare const searchJobs: <ThrowOnError extends boolean = true>(options?: Options<SearchJobsData, ThrowOnError>) => RequestResult<SearchJobsResponses, SearchJobsErrors, ThrowOnError, "fields">;
/**
 * Fail job
 * Mark the job as failed
 *
 */
declare const failJob: <ThrowOnError extends boolean = true>(options: Options<FailJobData, ThrowOnError>) => RequestResult<FailJobResponses, FailJobErrors, ThrowOnError, "fields">;
/**
 * Throw error for job
 * Reports a business error (i.e. non-technical) that occurs while processing a job.
 *
 */
declare const throwJobError: <ThrowOnError extends boolean = true>(options: Options<ThrowJobErrorData, ThrowOnError>) => RequestResult<ThrowJobErrorResponses, ThrowJobErrorErrors, ThrowOnError, "fields">;
/**
 * Complete job
 * Complete a job with the given payload, which allows completing the associated service task.
 *
 */
declare const completeJob: <ThrowOnError extends boolean = true>(options: Options<CompleteJobData, ThrowOnError>) => RequestResult<CompleteJobResponses, CompleteJobErrors, ThrowOnError, "fields">;
/**
 * Update job
 * Update a job with the given key.
 */
declare const updateJob: <ThrowOnError extends boolean = true>(options: Options<UpdateJobData, ThrowOnError>) => RequestResult<UpdateJobResponses, UpdateJobErrors, ThrowOnError, "fields">;
/**
 * Resolve incident
 * Marks the incident as resolved; most likely a call to Update job will be necessary to reset the jobs retries, followed by this call.
 *
 */
declare const resolveIncident: <ThrowOnError extends boolean = true>(options: Options<ResolveIncidentData, ThrowOnError>) => RequestResult<ResolveIncidentResponses, ResolveIncidentErrors, ThrowOnError, "fields">;
/**
 * Create tenant
 * Creates a new tenant.
 */
declare const createTenant: <ThrowOnError extends boolean = true>(options: Options<CreateTenantData, ThrowOnError>) => RequestResult<CreateTenantResponses, CreateTenantErrors, ThrowOnError, "fields">;
/**
 * Delete tenant
 * Deletes an existing tenant.
 */
declare const deleteTenant: <ThrowOnError extends boolean = true>(options: Options<DeleteTenantData, ThrowOnError>) => RequestResult<DeleteTenantResponses, DeleteTenantErrors, ThrowOnError, "fields">;
/**
 * Get tenant
 * Retrieves a single tenant by tenant ID.
 */
declare const getTenant: <ThrowOnError extends boolean = true>(options: Options<GetTenantData, ThrowOnError>) => RequestResult<GetTenantResponses, GetTenantErrors, ThrowOnError, "fields">;
/**
 * Update tenant
 * Updates an existing tenant.
 */
declare const updateTenant: <ThrowOnError extends boolean = true>(options: Options<UpdateTenantData, ThrowOnError>) => RequestResult<UpdateTenantResponses, UpdateTenantErrors, ThrowOnError, "fields">;
/**
 * Unassign a user from a tenant
 * Unassigns the user from the specified tenant.
 * The user can no longer access tenant data.
 *
 */
declare const unassignUserFromTenant: <ThrowOnError extends boolean = true>(options: Options<UnassignUserFromTenantData, ThrowOnError>) => RequestResult<UnassignUserFromTenantResponses, UnassignUserFromTenantErrors, ThrowOnError, "fields">;
/**
 * Assign a user to a tenant
 * Assign a single user to a specified tenant. The user can then access tenant data and perform authorized actions.
 */
declare const assignUserToTenant: <ThrowOnError extends boolean = true>(options: Options<AssignUserToTenantData, ThrowOnError>) => RequestResult<AssignUserToTenantResponses, AssignUserToTenantErrors, ThrowOnError, "fields">;
/**
 * Search users for tenant
 * Retrieves a filtered and sorted list of users for a specified tenant.
 */
declare const searchUsersForTenant: <ThrowOnError extends boolean = true>(options: Options<SearchUsersForTenantData, ThrowOnError>) => RequestResult<SearchUsersForTenantResponses, unknown, ThrowOnError, "fields">;
/**
 * Search clients for tenant
 * Retrieves a filtered and sorted list of clients for a specified tenant.
 */
declare const searchClientsForTenant: <ThrowOnError extends boolean = true>(options: Options<SearchClientsForTenantData, ThrowOnError>) => RequestResult<SearchClientsForTenantResponses, unknown, ThrowOnError, "fields">;
/**
 * Search groups for tenant
 * Retrieves a filtered and sorted list of groups for a specified tenant.
 */
declare const searchGroupIdsForTenant: <ThrowOnError extends boolean = true>(options: Options<SearchGroupIdsForTenantData, ThrowOnError>) => RequestResult<SearchGroupIdsForTenantResponses, unknown, ThrowOnError, "fields">;
/**
 * Search roles for tenant
 * Retrieves a filtered and sorted list of roles for a specified tenant.
 */
declare const searchRolesForTenant: <ThrowOnError extends boolean = true>(options: Options<SearchRolesForTenantData, ThrowOnError>) => RequestResult<SearchRolesForTenantResponses, unknown, ThrowOnError, "fields">;
/**
 * Unassign a client from a tenant
 * Unassigns the client from the specified tenant.
 * The client can no longer access tenant data.
 *
 */
declare const unassignClientFromTenant: <ThrowOnError extends boolean = true>(options: Options<UnassignClientFromTenantData, ThrowOnError>) => RequestResult<UnassignClientFromTenantResponses, UnassignClientFromTenantErrors, ThrowOnError, "fields">;
/**
 * Assign a client to a tenant
 * Assign the client to the specified tenant.
 * The client can then access tenant data and perform authorized actions.
 *
 */
declare const assignClientToTenant: <ThrowOnError extends boolean = true>(options: Options<AssignClientToTenantData, ThrowOnError>) => RequestResult<AssignClientToTenantResponses, AssignClientToTenantErrors, ThrowOnError, "fields">;
/**
 * Unassign a mapping rule from a tenant
 * Unassigns a single mapping rule from a specified tenant without deleting the rule.
 */
declare const unassignMappingRuleFromTenant: <ThrowOnError extends boolean = true>(options: Options<UnassignMappingRuleFromTenantData, ThrowOnError>) => RequestResult<UnassignMappingRuleFromTenantResponses, UnassignMappingRuleFromTenantErrors, ThrowOnError, "fields">;
/**
 * Assign a mapping rule to a tenant
 * Assign a single mapping rule to a specified tenant.
 */
declare const assignMappingRuleToTenant: <ThrowOnError extends boolean = true>(options: Options<AssignMappingRuleToTenantData, ThrowOnError>) => RequestResult<AssignMappingRuleToTenantResponses, AssignMappingRuleToTenantErrors, ThrowOnError, "fields">;
/**
 * Search mapping rules for tenant
 * Retrieves a filtered and sorted list of MappingRules for a specified tenant.
 */
declare const searchMappingRulesForTenant: <ThrowOnError extends boolean = true>(options: Options<SearchMappingRulesForTenantData, ThrowOnError>) => RequestResult<SearchMappingRulesForTenantResponses, unknown, ThrowOnError, "fields">;
/**
 * Unassign a group from a tenant
 * Unassigns a group from a specified tenant.
 * Members of the group (users, clients) will no longer have access to the tenant's data - except they are assigned directly to the tenant.
 *
 */
declare const unassignGroupFromTenant: <ThrowOnError extends boolean = true>(options: Options<UnassignGroupFromTenantData, ThrowOnError>) => RequestResult<UnassignGroupFromTenantResponses, UnassignGroupFromTenantErrors, ThrowOnError, "fields">;
/**
 * Assign a group to a tenant
 * Assigns a group to a specified tenant.
 * Group members (users, clients) can then access tenant data and perform authorized actions.
 *
 */
declare const assignGroupToTenant: <ThrowOnError extends boolean = true>(options: Options<AssignGroupToTenantData, ThrowOnError>) => RequestResult<AssignGroupToTenantResponses, AssignGroupToTenantErrors, ThrowOnError, "fields">;
/**
 * Unassign a role from a tenant
 * Unassigns a role from a specified tenant.
 * Users, Clients or Groups, that have the role assigned, will no longer have access to the
 * tenant's data - unless they are assigned directly to the tenant.
 *
 */
declare const unassignRoleFromTenant: <ThrowOnError extends boolean = true>(options: Options<UnassignRoleFromTenantData, ThrowOnError>) => RequestResult<UnassignRoleFromTenantResponses, UnassignRoleFromTenantErrors, ThrowOnError, "fields">;
/**
 * Assign a role to a tenant
 * Assigns a role to a specified tenant.
 * Users, Clients or Groups, that have the role assigned, will get access to the tenant's data and can perform actions according to their authorizations.
 *
 */
declare const assignRoleToTenant: <ThrowOnError extends boolean = true>(options: Options<AssignRoleToTenantData, ThrowOnError>) => RequestResult<AssignRoleToTenantResponses, AssignRoleToTenantErrors, ThrowOnError, "fields">;
/**
 * Search tenants
 * Retrieves a filtered and sorted list of tenants.
 */
declare const searchTenants: <ThrowOnError extends boolean = true>(options?: Options<SearchTenantsData, ThrowOnError>) => RequestResult<SearchTenantsResponses, SearchTenantsErrors, ThrowOnError, "fields">;
/**
 * Complete user task
 * Completes a user task with the given key.
 */
declare const completeUserTask: <ThrowOnError extends boolean = true>(options: Options<CompleteUserTaskData, ThrowOnError>) => RequestResult<CompleteUserTaskResponses, CompleteUserTaskErrors, ThrowOnError, "fields">;
/**
 * Assign user task
 * Assigns a user task with the given key to the given assignee.
 */
declare const assignUserTask: <ThrowOnError extends boolean = true>(options: Options<AssignUserTaskData, ThrowOnError>) => RequestResult<AssignUserTaskResponses, AssignUserTaskErrors, ThrowOnError, "fields">;
/**
 * Get user task
 * Get the user task by the user task key.
 *
 */
declare const getUserTask: <ThrowOnError extends boolean = true>(options: Options<GetUserTaskData, ThrowOnError>) => RequestResult<GetUserTaskResponses, GetUserTaskErrors, ThrowOnError, "fields">;
/**
 * Update user task
 * Update a user task with the given key.
 */
declare const updateUserTask: <ThrowOnError extends boolean = true>(options: Options<UpdateUserTaskData, ThrowOnError>) => RequestResult<UpdateUserTaskResponses, UpdateUserTaskErrors, ThrowOnError, "fields">;
/**
 * Get user task form
 * Get the form of a user task.
 *
 * Note that this endpoint will only return linked forms. This endpoint does not support embedded forms.
 *
 */
declare const getUserTaskForm: <ThrowOnError extends boolean = true>(options: Options<GetUserTaskFormData, ThrowOnError>) => RequestResult<GetUserTaskFormResponses, GetUserTaskFormErrors, ThrowOnError, "fields">;
/**
 * Unassign user task
 * Removes the assignee of a task with the given key.
 */
declare const unassignUserTask: <ThrowOnError extends boolean = true>(options: Options<UnassignUserTaskData, ThrowOnError>) => RequestResult<UnassignUserTaskResponses, UnassignUserTaskErrors, ThrowOnError, "fields">;
/**
 * Search user tasks
 * Search for user tasks based on given criteria.
 *
 */
declare const searchUserTasks: <ThrowOnError extends boolean = true>(options?: Options<SearchUserTasksData, ThrowOnError>) => RequestResult<SearchUserTasksResponses, SearchUserTasksErrors, ThrowOnError, "fields">;
/**
 * Search user task variables
 * Search for user task variables based on given criteria.
 *
 */
declare const searchUserTaskVariables: <ThrowOnError extends boolean = true>(options: Options<SearchUserTaskVariablesData, ThrowOnError>) => RequestResult<SearchUserTaskVariablesResponses, SearchUserTaskVariablesErrors, ThrowOnError, "fields">;
/**
 * Search variables
 * Search for process and local variables based on given criteria.
 *
 */
declare const searchVariables: <ThrowOnError extends boolean = true>(options?: Options<SearchVariablesData, ThrowOnError>) => RequestResult<SearchVariablesResponses, SearchVariablesErrors, ThrowOnError, "fields">;
/**
 * Get variable
 * Get the variable by the variable key.
 *
 */
declare const getVariable: <ThrowOnError extends boolean = true>(options: Options<GetVariableData, ThrowOnError>) => RequestResult<GetVariableResponses, GetVariableErrors, ThrowOnError, "fields">;
/**
 * Pin internal clock (alpha)
 * Set a precise, static time for the Zeebe engines internal clock.
 * When the clock is pinned, it remains at the specified time and does not advance.
 * To change the time, the clock must be pinned again with a new timestamp.
 *
 * This endpoint is an alpha feature and may be subject to change
 * in future releases.
 *
 */
declare const pinClock: <ThrowOnError extends boolean = true>(options: Options<PinClockData, ThrowOnError>) => RequestResult<PinClockResponses, PinClockErrors, ThrowOnError, "fields">;
/**
 * Reset internal clock (alpha)
 * Resets the Zeebe engines internal clock to the current system time, enabling it to tick in real-time.
 * This operation is useful for returning the clock to
 * normal behavior after it has been pinned to a specific time.
 *
 * This endpoint is an alpha feature and may be subject to change
 * in future releases.
 *
 */
declare const resetClock: <ThrowOnError extends boolean = true>(options?: Options<ResetClockData, ThrowOnError>) => RequestResult<ResetClockResponses, ResetClockErrors, ThrowOnError, "fields">;
/**
 * Search process definitions
 * Search for process definitions based on given criteria.
 *
 */
declare const searchProcessDefinitions: <ThrowOnError extends boolean = true>(options?: Options<SearchProcessDefinitionsData, ThrowOnError>) => RequestResult<SearchProcessDefinitionsResponses, SearchProcessDefinitionsErrors, ThrowOnError, "fields">;
/**
 * Get process definition
 * Returns process definition as JSON.
 *
 */
declare const getProcessDefinition: <ThrowOnError extends boolean = true>(options: Options<GetProcessDefinitionData, ThrowOnError>) => RequestResult<GetProcessDefinitionResponses, GetProcessDefinitionErrors, ThrowOnError, "fields">;
/**
 * Get process definition XML
 * Returns process definition as XML.
 *
 */
declare const getProcessDefinitionXml: <ThrowOnError extends boolean = true>(options: Options<GetProcessDefinitionXmlData, ThrowOnError>) => RequestResult<GetProcessDefinitionXmlResponses, GetProcessDefinitionXmlErrors, ThrowOnError, "fields">;
/**
 * Get process start form
 * Get the start form of a process.
 *
 * Note that this endpoint will only return linked forms. This endpoint does not support embedded forms.
 *
 */
declare const getStartProcessForm: <ThrowOnError extends boolean = true>(options: Options<GetStartProcessFormData, ThrowOnError>) => RequestResult<GetStartProcessFormResponses, GetStartProcessFormErrors, ThrowOnError, "fields">;
/**
 * Get process definition statistics
 * Get statistics about elements in currently running process instances by process definition key and search filter.
 *
 */
declare const getProcessDefinitionStatistics: <ThrowOnError extends boolean = true>(options: Options<GetProcessDefinitionStatisticsData, ThrowOnError>) => RequestResult<GetProcessDefinitionStatisticsResponses, GetProcessDefinitionStatisticsErrors, ThrowOnError, "fields">;
/**
 * Create process instance
 * Creates and starts an instance of the specified process.
 * The process definition to use to create the instance can be specified either using its unique key
 * (as returned by Deploy resources), or using the BPMN process ID and a version.
 *
 * Waits for the completion of the process instance before returning a result
 * when awaitCompletion is enabled.
 *
 */
declare const createProcessInstance: <ThrowOnError extends boolean = true>(options: Options<CreateProcessInstanceData, ThrowOnError>) => RequestResult<CreateProcessInstanceResponses, CreateProcessInstanceErrors, ThrowOnError, "fields">;
/**
 * Get process instance
 * Get the process instance by the process instance key.
 *
 */
declare const getProcessInstance: <ThrowOnError extends boolean = true>(options: Options<GetProcessInstanceData, ThrowOnError>) => RequestResult<GetProcessInstanceResponses, GetProcessInstanceErrors, ThrowOnError, "fields">;
/**
 * Get process instance sequence flows
 * Get sequence flows taken by the process instance.
 *
 */
declare const getProcessInstanceSequenceFlows: <ThrowOnError extends boolean = true>(options: Options<GetProcessInstanceSequenceFlowsData, ThrowOnError>) => RequestResult<GetProcessInstanceSequenceFlowsResponses, GetProcessInstanceSequenceFlowsErrors, ThrowOnError, "fields">;
/**
 * Get process instance statistics
 * Get statistics about elements by the process instance key.
 *
 */
declare const getProcessInstanceStatistics: <ThrowOnError extends boolean = true>(options: Options<GetProcessInstanceStatisticsData, ThrowOnError>) => RequestResult<GetProcessInstanceStatisticsResponses, GetProcessInstanceStatisticsErrors, ThrowOnError, "fields">;
/**
 * Search process instances
 * Search for process instances based on given criteria.
 *
 */
declare const searchProcessInstances: <ThrowOnError extends boolean = true>(options?: Options<SearchProcessInstancesData, ThrowOnError>) => RequestResult<SearchProcessInstancesResponses, SearchProcessInstancesErrors, ThrowOnError, "fields">;
/**
 * Search for incidents associated with a process instance
 * Search for incidents caused by the process instance or any of its called process or decision instances.
 *
 */
declare const searchProcessInstanceIncidents: <ThrowOnError extends boolean = true>(options: Options<SearchProcessInstanceIncidentsData, ThrowOnError>) => RequestResult<SearchProcessInstanceIncidentsResponses, SearchProcessInstanceIncidentsErrors, ThrowOnError, "fields">;
/**
 * Cancel process instance
 * Cancels a running process instance. As a cancelation includes more than just the removal of the process instance resource, the cancelation resource must be posted.
 */
declare const cancelProcessInstance: <ThrowOnError extends boolean = true>(options: Options<CancelProcessInstanceData, ThrowOnError>) => RequestResult<CancelProcessInstanceResponses, CancelProcessInstanceErrors, ThrowOnError, "fields">;
/**
 * Create a batch operation to cancel process instances
 * Cancels multiple running process instances.
 * Since only ACTIVE root instances can be cancelled, any given filters for state and
 * parentProcessInstanceKey are ignored and overridden during this batch operation.
 * This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
declare const cancelProcessInstancesBatchOperation: <ThrowOnError extends boolean = true>(options: Options<CancelProcessInstancesBatchOperationData, ThrowOnError>) => RequestResult<CancelProcessInstancesBatchOperationResponses, CancelProcessInstancesBatchOperationErrors, ThrowOnError, "fields">;
/**
 * Create a batch operation to resolve incidents of process instances
 * Resolves multiple instances of process instances.
 * Since only process instances with ACTIVE state can have unresolved incidents, any given
 * filters for state are ignored and overridden during this batch operation.
 * This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
declare const resolveIncidentsBatchOperation: <ThrowOnError extends boolean = true>(options?: Options<ResolveIncidentsBatchOperationData, ThrowOnError>) => RequestResult<ResolveIncidentsBatchOperationResponses, ResolveIncidentsBatchOperationErrors, ThrowOnError, "fields">;
/**
 * Create a batch operation to migrate process instances
 * Migrate multiple instances of process instances.
 * Since only process instances with ACTIVE state can be migrated, any given
 * filters for state are ignored and overridden during this batch operation.
 * This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
declare const migrateProcessInstancesBatchOperation: <ThrowOnError extends boolean = true>(options: Options<MigrateProcessInstancesBatchOperationData, ThrowOnError>) => RequestResult<MigrateProcessInstancesBatchOperationResponses, MigrateProcessInstancesBatchOperationErrors, ThrowOnError, "fields">;
/**
 * Create a batch operation to modify process instances
 * Modify multiple process instances.
 * Since only process instances with ACTIVE state can be modified, any given
 * filters for state are ignored and overridden during this batch operation.
 * In contrast to single modification operation, it is not possible to add variable instructions or modify by element key.
 * It is only possible to use the element id of the source and target.
 * This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
declare const modifyProcessInstancesBatchOperation: <ThrowOnError extends boolean = true>(options: Options<ModifyProcessInstancesBatchOperationData, ThrowOnError>) => RequestResult<ModifyProcessInstancesBatchOperationResponses, ModifyProcessInstancesBatchOperationErrors, ThrowOnError, "fields">;
/**
 * Migrate process instance
 * Migrates a process instance to a new process definition.
 * This request can contain multiple mapping instructions to define mapping between the active
 * process instance's elements and target process definition elements.
 *
 * Use this to upgrade a process instance to a new version of a process or to
 * a different process definition, e.g. to keep your running instances up-to-date with the
 * latest process improvements.
 *
 */
declare const migrateProcessInstance: <ThrowOnError extends boolean = true>(options: Options<MigrateProcessInstanceData, ThrowOnError>) => RequestResult<MigrateProcessInstanceResponses, MigrateProcessInstanceErrors, ThrowOnError, "fields">;
/**
 * Modify process instance
 * Modifies a running process instance.
 * This request can contain multiple instructions to activate an element of the process or
 * to terminate an active instance of an element.
 *
 * Use this to repair a process instance that is stuck on an element or took an unintended path.
 * For example, because an external system is not available or doesn't respond as expected.
 *
 */
declare const modifyProcessInstance: <ThrowOnError extends boolean = true>(options: Options<ModifyProcessInstanceData, ThrowOnError>) => RequestResult<ModifyProcessInstanceResponses, ModifyProcessInstanceErrors, ThrowOnError, "fields">;
/**
 * Get call hierarchy for process instance
 * Returns the call hierarchy for a given process instance, showing its ancestry up to the root instance.
 *
 */
declare const getProcessInstanceCallHierarchy: <ThrowOnError extends boolean = true>(options: Options<GetProcessInstanceCallHierarchyData, ThrowOnError>) => RequestResult<GetProcessInstanceCallHierarchyResponses, GetProcessInstanceCallHierarchyErrors, ThrowOnError, "fields">;
/**
 * Search element instances
 * Search for element instances based on given criteria.
 *
 */
declare const searchElementInstances: <ThrowOnError extends boolean = true>(options?: Options<SearchElementInstancesData, ThrowOnError>) => RequestResult<SearchElementInstancesResponses, SearchElementInstancesErrors, ThrowOnError, "fields">;
/**
 * Get element instance
 * Returns element instance as JSON.
 *
 */
declare const getElementInstance: <ThrowOnError extends boolean = true>(options: Options<GetElementInstanceData, ThrowOnError>) => RequestResult<GetElementInstanceResponses, GetElementInstanceErrors, ThrowOnError, "fields">;
/**
 * Search decision definitions
 * Search for decision definitions based on given criteria.
 *
 */
declare const searchDecisionDefinitions: <ThrowOnError extends boolean = true>(options?: Options<SearchDecisionDefinitionsData, ThrowOnError>) => RequestResult<SearchDecisionDefinitionsResponses, SearchDecisionDefinitionsErrors, ThrowOnError, "fields">;
/**
 * Get decision definition
 * Returns a decision definition by key.
 *
 */
declare const getDecisionDefinition: <ThrowOnError extends boolean = true>(options: Options<GetDecisionDefinitionData, ThrowOnError>) => RequestResult<GetDecisionDefinitionResponses, GetDecisionDefinitionErrors, ThrowOnError, "fields">;
/**
 * Get decision definition XML
 * Returns decision definition as XML.
 *
 */
declare const getDecisionDefinitionXml: <ThrowOnError extends boolean = true>(options: Options<GetDecisionDefinitionXmlData, ThrowOnError>) => RequestResult<GetDecisionDefinitionXmlResponses, GetDecisionDefinitionXmlErrors, ThrowOnError, "fields">;
/**
 * Search decision requirements
 * Search for decision requirements based on given criteria.
 *
 */
declare const searchDecisionRequirements: <ThrowOnError extends boolean = true>(options?: Options<SearchDecisionRequirementsData, ThrowOnError>) => RequestResult<SearchDecisionRequirementsResponses, SearchDecisionRequirementsErrors, ThrowOnError, "fields">;
/**
 * Get decision requirements
 * Returns Decision Requirements as JSON.
 *
 */
declare const getDecisionRequirements: <ThrowOnError extends boolean = true>(options: Options<GetDecisionRequirementsData, ThrowOnError>) => RequestResult<GetDecisionRequirementsResponses, GetDecisionRequirementsErrors, ThrowOnError, "fields">;
/**
 * Get decision requirements XML
 * Returns decision requirements as XML.
 *
 */
declare const getDecisionRequirementsXml: <ThrowOnError extends boolean = true>(options: Options<GetDecisionRequirementsXmlData, ThrowOnError>) => RequestResult<GetDecisionRequirementsXmlResponses, GetDecisionRequirementsXmlErrors, ThrowOnError, "fields">;
/**
 * Search decision instances
 * Search for decision instances based on given criteria.
 *
 */
declare const searchDecisionInstances: <ThrowOnError extends boolean = true>(options?: Options<SearchDecisionInstancesData, ThrowOnError>) => RequestResult<SearchDecisionInstancesResponses, SearchDecisionInstancesErrors, ThrowOnError, "fields">;
/**
 * Get decision instance
 * Returns a decision instance.
 *
 */
declare const getDecisionInstance: <ThrowOnError extends boolean = true>(options: Options<GetDecisionInstanceData, ThrowOnError>) => RequestResult<GetDecisionInstanceResponses, GetDecisionInstanceErrors, ThrowOnError, "fields">;
/**
 * Evaluate decision
 * Evaluates a decision.
 * You specify the decision to evaluate either by using its unique key (as returned by
 * DeployResource), or using the decision ID. When using the decision ID, the latest deployed
 * version of the decision is used.
 *
 */
declare const evaluateDecision: <ThrowOnError extends boolean = true>(options: Options<EvaluateDecisionData, ThrowOnError>) => RequestResult<EvaluateDecisionResponses, EvaluateDecisionErrors, ThrowOnError, "fields">;
/**
 * Create authorization
 * Create the authorization.
 */
declare const createAuthorization: <ThrowOnError extends boolean = true>(options: Options<CreateAuthorizationData, ThrowOnError>) => RequestResult<CreateAuthorizationResponses, CreateAuthorizationErrors, ThrowOnError, "fields">;
/**
 * Delete authorization
 * Deletes the authorization with the given key.
 */
declare const deleteAuthorization: <ThrowOnError extends boolean = true>(options: Options<DeleteAuthorizationData, ThrowOnError>) => RequestResult<DeleteAuthorizationResponses, DeleteAuthorizationErrors, ThrowOnError, "fields">;
/**
 * Get authorization
 * Get authorization by the given key.
 */
declare const getAuthorization: <ThrowOnError extends boolean = true>(options: Options<GetAuthorizationData, ThrowOnError>) => RequestResult<GetAuthorizationResponses, GetAuthorizationErrors, ThrowOnError, "fields">;
/**
 * Update authorization
 * Update the authorization with the given key.
 */
declare const updateAuthorization: <ThrowOnError extends boolean = true>(options: Options<UpdateAuthorizationData, ThrowOnError>) => RequestResult<UpdateAuthorizationResponses, UpdateAuthorizationErrors, ThrowOnError, "fields">;
/**
 * Search authorizations
 * Search for authorizations based on given criteria.
 *
 */
declare const searchAuthorizations: <ThrowOnError extends boolean = true>(options?: Options<SearchAuthorizationsData, ThrowOnError>) => RequestResult<SearchAuthorizationsResponses, SearchAuthorizationsErrors, ThrowOnError, "fields">;
/**
 * Create role
 * Create a new role.
 *
 */
declare const createRole: <ThrowOnError extends boolean = true>(options?: Options<CreateRoleData, ThrowOnError>) => RequestResult<CreateRoleResponses, CreateRoleErrors, ThrowOnError, "fields">;
/**
 * Delete role
 * Deletes the role with the given ID.
 *
 */
declare const deleteRole: <ThrowOnError extends boolean = true>(options: Options<DeleteRoleData, ThrowOnError>) => RequestResult<DeleteRoleResponses, DeleteRoleErrors, ThrowOnError, "fields">;
/**
 * Get role
 * Get a role by its ID.
 *
 */
declare const getRole: <ThrowOnError extends boolean = true>(options: Options<GetRoleData, ThrowOnError>) => RequestResult<GetRoleResponses, GetRoleErrors, ThrowOnError, "fields">;
/**
 * Update role
 * Update a role with the given ID.
 *
 */
declare const updateRole: <ThrowOnError extends boolean = true>(options: Options<UpdateRoleData, ThrowOnError>) => RequestResult<UpdateRoleResponses, UpdateRoleErrors, ThrowOnError, "fields">;
/**
 * Search role users
 * Search users with assigned role.
 *
 */
declare const searchUsersForRole: <ThrowOnError extends boolean = true>(options: Options<SearchUsersForRoleData, ThrowOnError>) => RequestResult<SearchUsersForRoleResponses, SearchUsersForRoleErrors, ThrowOnError, "fields">;
/**
 * Search role clients
 * Search clients with assigned role.
 *
 */
declare const searchClientsForRole: <ThrowOnError extends boolean = true>(options: Options<SearchClientsForRoleData, ThrowOnError>) => RequestResult<SearchClientsForRoleResponses, SearchClientsForRoleErrors, ThrowOnError, "fields">;
/**
 * Unassign a role from a user
 * Unassigns a role from a user.
 * The user will no longer inherit the authorizations associated with this role.
 *
 */
declare const unassignRoleFromUser: <ThrowOnError extends boolean = true>(options: Options<UnassignRoleFromUserData, ThrowOnError>) => RequestResult<UnassignRoleFromUserResponses, UnassignRoleFromUserErrors, ThrowOnError, "fields">;
/**
 * Assign a role to a user
 * Assigns the specified role to the user.
 * The user will inherit the authorizations associated with this role.
 *
 */
declare const assignRoleToUser: <ThrowOnError extends boolean = true>(options: Options<AssignRoleToUserData, ThrowOnError>) => RequestResult<AssignRoleToUserResponses, AssignRoleToUserErrors, ThrowOnError, "fields">;
/**
 * Unassign a role from a client
 * Unassigns the specified role from the client.
 * The client will no longer inherit the authorizations associated with this role.
 *
 */
declare const unassignRoleFromClient: <ThrowOnError extends boolean = true>(options: Options<UnassignRoleFromClientData, ThrowOnError>) => RequestResult<UnassignRoleFromClientResponses, UnassignRoleFromClientErrors, ThrowOnError, "fields">;
/**
 * Assign a role to a client
 * Assigns the specified role to the client.
 * The client will inherit the authorizations associated with this role.
 *
 */
declare const assignRoleToClient: <ThrowOnError extends boolean = true>(options: Options<AssignRoleToClientData, ThrowOnError>) => RequestResult<AssignRoleToClientResponses, AssignRoleToClientErrors, ThrowOnError, "fields">;
/**
 * Search roles
 * Search for roles based on given criteria.
 *
 */
declare const searchRoles: <ThrowOnError extends boolean = true>(options?: Options<SearchRolesData, ThrowOnError>) => RequestResult<SearchRolesResponses, SearchRolesErrors, ThrowOnError, "fields">;
/**
 * Unassign a role from a group
 * Unassigns the specified role from the group.
 * All group members (user or client) no longer inherit the authorizations associated with this role.
 *
 */
declare const unassignRoleFromGroup: <ThrowOnError extends boolean = true>(options: Options<UnassignRoleFromGroupData, ThrowOnError>) => RequestResult<UnassignRoleFromGroupResponses, UnassignRoleFromGroupErrors, ThrowOnError, "fields">;
/**
 * Assign a role to a group
 * Assigns the specified role to the group.
 * Every member of the group (user or client) will inherit the authorizations associated with this role.
 *
 */
declare const assignRoleToGroup: <ThrowOnError extends boolean = true>(options: Options<AssignRoleToGroupData, ThrowOnError>) => RequestResult<AssignRoleToGroupResponses, AssignRoleToGroupErrors, ThrowOnError, "fields">;
/**
 * Search role groups
 * Search groups with assigned role.
 *
 */
declare const searchGroupsForRole: <ThrowOnError extends boolean = true>(options: Options<SearchGroupsForRoleData, ThrowOnError>) => RequestResult<SearchGroupsForRoleResponses, SearchGroupsForRoleErrors, ThrowOnError, "fields">;
/**
 * Unassign a role from a mapping rule
 * Unassigns a role from a mapping rule.
 *
 */
declare const unassignRoleFromMappingRule: <ThrowOnError extends boolean = true>(options: Options<UnassignRoleFromMappingRuleData, ThrowOnError>) => RequestResult<UnassignRoleFromMappingRuleResponses, UnassignRoleFromMappingRuleErrors, ThrowOnError, "fields">;
/**
 * Assign a role to a mapping rule
 * Assigns a role to a mapping rule.
 *
 */
declare const assignRoleToMappingRule: <ThrowOnError extends boolean = true>(options: Options<AssignRoleToMappingRuleData, ThrowOnError>) => RequestResult<AssignRoleToMappingRuleResponses, AssignRoleToMappingRuleErrors, ThrowOnError, "fields">;
/**
 * Search role mapping rules
 * Search mapping rules with assigned role.
 *
 */
declare const searchMappingRulesForRole: <ThrowOnError extends boolean = true>(options: Options<SearchMappingRulesForRoleData, ThrowOnError>) => RequestResult<SearchMappingRulesForRoleResponses, SearchMappingRulesForRoleErrors, ThrowOnError, "fields">;
/**
 * Create group
 * Create a new group.
 *
 */
declare const createGroup: <ThrowOnError extends boolean = true>(options?: Options<CreateGroupData, ThrowOnError>) => RequestResult<CreateGroupResponses, CreateGroupErrors, ThrowOnError, "fields">;
/**
 * Delete group
 * Deletes the group with the given ID.
 *
 */
declare const deleteGroup: <ThrowOnError extends boolean = true>(options: Options<DeleteGroupData, ThrowOnError>) => RequestResult<DeleteGroupResponses, DeleteGroupErrors, ThrowOnError, "fields">;
/**
 * Get group
 * Get a group by its ID.
 *
 */
declare const getGroup: <ThrowOnError extends boolean = true>(options: Options<GetGroupData, ThrowOnError>) => RequestResult<GetGroupResponses, GetGroupErrors, ThrowOnError, "fields">;
/**
 * Update group
 * Update a group with the given ID.
 *
 */
declare const updateGroup: <ThrowOnError extends boolean = true>(options: Options<UpdateGroupData, ThrowOnError>) => RequestResult<UpdateGroupResponses, UpdateGroupErrors, ThrowOnError, "fields">;
/**
 * Search group users
 * Search users assigned to a group.
 *
 */
declare const searchUsersForGroup: <ThrowOnError extends boolean = true>(options: Options<SearchUsersForGroupData, ThrowOnError>) => RequestResult<SearchUsersForGroupResponses, SearchUsersForGroupErrors, ThrowOnError, "fields">;
/**
 * Search group mapping rules
 * Search mapping rules assigned to a group.
 *
 */
declare const searchMappingRulesForGroup: <ThrowOnError extends boolean = true>(options: Options<SearchMappingRulesForGroupData, ThrowOnError>) => RequestResult<SearchMappingRulesForGroupResponses, SearchMappingRulesForGroupErrors, ThrowOnError, "fields">;
/**
 * Search group roles
 * Search roles assigned to a group.
 *
 */
declare const searchRolesForGroup: <ThrowOnError extends boolean = true>(options: Options<SearchRolesForGroupData, ThrowOnError>) => RequestResult<SearchRolesForGroupResponses, SearchRolesForGroupErrors, ThrowOnError, "fields">;
/**
 * Search group clients
 * Search clients assigned to a group.
 *
 */
declare const searchClientsForGroup: <ThrowOnError extends boolean = true>(options: Options<SearchClientsForGroupData, ThrowOnError>) => RequestResult<SearchClientsForGroupResponses, SearchClientsForGroupErrors, ThrowOnError, "fields">;
/**
 * Unassign a user from a group
 * Unassigns a user from a group.
 * The user is removed as a group member, with associated authorizations, roles, and tenant assignments no longer applied.
 *
 */
declare const unassignUserFromGroup: <ThrowOnError extends boolean = true>(options: Options<UnassignUserFromGroupData, ThrowOnError>) => RequestResult<UnassignUserFromGroupResponses, UnassignUserFromGroupErrors, ThrowOnError, "fields">;
/**
 * Assign a user to a group
 * Assigns a user to a group, making the user a member of the group.
 * Group members inherit the group authorizations, roles, and tenant assignments.
 *
 */
declare const assignUserToGroup: <ThrowOnError extends boolean = true>(options: Options<AssignUserToGroupData, ThrowOnError>) => RequestResult<AssignUserToGroupResponses, AssignUserToGroupErrors, ThrowOnError, "fields">;
/**
 * Unassign a client from a group
 * Unassigns a client from a group.
 * The client is removed as a group member, with associated authorizations, roles, and tenant assignments no longer applied.
 *
 */
declare const unassignClientFromGroup: <ThrowOnError extends boolean = true>(options: Options<UnassignClientFromGroupData, ThrowOnError>) => RequestResult<UnassignClientFromGroupResponses, UnassignClientFromGroupErrors, ThrowOnError, "fields">;
/**
 * Assign a client to a group
 * Assigns a client to a group, making it a member of the group.
 * Members of the group inherit the group authorizations, roles, and tenant assignments.
 *
 */
declare const assignClientToGroup: <ThrowOnError extends boolean = true>(options: Options<AssignClientToGroupData, ThrowOnError>) => RequestResult<AssignClientToGroupResponses, AssignClientToGroupErrors, ThrowOnError, "fields">;
/**
 * Unassign a mapping rule from a group
 * Unassigns a mapping rule from a group.
 *
 */
declare const unassignMappingRuleFromGroup: <ThrowOnError extends boolean = true>(options: Options<UnassignMappingRuleFromGroupData, ThrowOnError>) => RequestResult<UnassignMappingRuleFromGroupResponses, UnassignMappingRuleFromGroupErrors, ThrowOnError, "fields">;
/**
 * Assign a mapping rule to a group
 * Assigns a mapping rule to a group.
 *
 */
declare const assignMappingRuleToGroup: <ThrowOnError extends boolean = true>(options: Options<AssignMappingRuleToGroupData, ThrowOnError>) => RequestResult<AssignMappingRuleToGroupResponses, AssignMappingRuleToGroupErrors, ThrowOnError, "fields">;
/**
 * Search groups
 * Search for groups based on given criteria.
 *
 */
declare const searchGroups: <ThrowOnError extends boolean = true>(options?: Options<SearchGroupsData, ThrowOnError>) => RequestResult<SearchGroupsResponses, SearchGroupsErrors, ThrowOnError, "fields">;
/**
 * Create mapping rule
 * Create a new mapping rule
 *
 */
declare const createMappingRule: <ThrowOnError extends boolean = true>(options?: Options<CreateMappingRuleData, ThrowOnError>) => RequestResult<CreateMappingRuleResponses, CreateMappingRuleErrors, ThrowOnError, "fields">;
/**
 * Delete a mapping rule
 * Deletes the mapping rule with the given ID.
 *
 */
declare const deleteMappingRule: <ThrowOnError extends boolean = true>(options: Options<DeleteMappingRuleData, ThrowOnError>) => RequestResult<DeleteMappingRuleResponses, DeleteMappingRuleErrors, ThrowOnError, "fields">;
/**
 * Get a mapping rule
 * Gets the mapping rule with the given ID.
 *
 */
declare const getMappingRule: <ThrowOnError extends boolean = true>(options: Options<GetMappingRuleData, ThrowOnError>) => RequestResult<GetMappingRuleResponses, GetMappingRuleErrors, ThrowOnError, "fields">;
/**
 * Update mapping rule
 * Update a mapping rule.
 *
 */
declare const updateMappingRule: <ThrowOnError extends boolean = true>(options: Options<UpdateMappingRuleData, ThrowOnError>) => RequestResult<UpdateMappingRuleResponses, UpdateMappingRuleErrors, ThrowOnError, "fields">;
/**
 * Search mapping rules
 * Search for mapping rules based on given criteria.
 *
 */
declare const searchMappingRule: <ThrowOnError extends boolean = true>(options?: Options<SearchMappingRuleData, ThrowOnError>) => RequestResult<SearchMappingRuleResponses, SearchMappingRuleErrors, ThrowOnError, "fields">;
/**
 * Publish message
 * Publishes a single message.
 * Messages are published to specific partitions computed from their correlation keys.
 * Messages can be buffered.
 * The endpoint does not wait for a correlation result.
 * Use the message correlation endpoint for such use cases.
 *
 */
declare const publishMessage: <ThrowOnError extends boolean = true>(options: Options<PublishMessageData, ThrowOnError>) => RequestResult<PublishMessageResponses, PublishMessageErrors, ThrowOnError, "fields">;
/**
 * Correlate message
 * Publishes a message and correlates it to a subscription.
 * If correlation is successful it will return the first process instance key the message correlated with.
 * The message is not buffered.
 * Use the publish message endpoint to send messages that can be buffered.
 *
 */
declare const correlateMessage: <ThrowOnError extends boolean = true>(options: Options<CorrelateMessageData, ThrowOnError>) => RequestResult<CorrelateMessageResponses, CorrelateMessageErrors, ThrowOnError, "fields">;
/**
 * Search correlated message subscriptions
 * Search correlated message subscriptions based on given criteria.
 */
declare const searchCorrelatedMessageSubscriptions: <ThrowOnError extends boolean = true>(options?: Options<SearchCorrelatedMessageSubscriptionsData, ThrowOnError>) => RequestResult<SearchCorrelatedMessageSubscriptionsResponses, SearchCorrelatedMessageSubscriptionsErrors, ThrowOnError, "fields">;
/**
 * Search message subscriptions
 * Search for message subscriptions based on given criteria.
 *
 */
declare const searchMessageSubscriptions: <ThrowOnError extends boolean = true>(options?: Options<SearchMessageSubscriptionsData, ThrowOnError>) => RequestResult<SearchMessageSubscriptionsResponses, SearchMessageSubscriptionsErrors, ThrowOnError, "fields">;
/**
 * Upload document
 * Upload a document to the Camunda 8 cluster.
 *
 * Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
 *
 */
declare const createDocument: <ThrowOnError extends boolean = true>(options: Options<CreateDocumentData, ThrowOnError>) => RequestResult<CreateDocumentResponses, CreateDocumentErrors, ThrowOnError, "fields">;
/**
 * Upload multiple documents
 * Upload multiple documents to the Camunda 8 cluster.
 *
 * The caller must provide a file name for each document, which will be used in case of a multi-status response
 * to identify which documents failed to upload. The file name can be provided in the `Content-Disposition` header
 * of the file part or in the `fileName` field of the metadata. You can add a parallel array of metadata objects. These
 * are matched with the files based on index, and must have the same length as the files array.
 * To pass homogenous metadata for all files, spread the metadata over the metadata array.
 * A filename value provided explicitly via the metadata array in the request overrides the `Content-Disposition` header
 * of the file part.
 *
 * In case of a multi-status response, the response body will contain a list of `DocumentBatchProblemDetail` objects,
 * each of which contains the file name of the document that failed to upload and the reason for the failure.
 * The client can choose to retry the whole batch or individual documents based on the response.
 *
 * Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
 *
 */
declare const createDocuments: <ThrowOnError extends boolean = true>(options: Options<CreateDocumentsData, ThrowOnError>) => RequestResult<CreateDocumentsResponses, CreateDocumentsErrors, ThrowOnError, "fields">;
/**
 * Delete document
 * Delete a document from the Camunda 8 cluster.
 *
 * Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
 *
 */
declare const deleteDocument: <ThrowOnError extends boolean = true>(options: Options<DeleteDocumentData, ThrowOnError>) => RequestResult<DeleteDocumentResponses, DeleteDocumentErrors, ThrowOnError, "fields">;
/**
 * Download document
 * Download a document from the Camunda 8 cluster.
 *
 * Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
 *
 */
declare const getDocument: <ThrowOnError extends boolean = true>(options: Options<GetDocumentData, ThrowOnError>) => RequestResult<GetDocumentResponses, GetDocumentErrors, ThrowOnError, "fields">;
/**
 * Create document link
 * Create a link to a document in the Camunda 8 cluster.
 *
 * Note that this is currently supported for document stores of type: AWS, GCP
 *
 */
declare const createDocumentLink: <ThrowOnError extends boolean = true>(options: Options<CreateDocumentLinkData, ThrowOnError>) => RequestResult<CreateDocumentLinkResponses, CreateDocumentLinkErrors, ThrowOnError, "fields">;
/**
 * Create user
 * Create a new user.
 */
declare const createUser: <ThrowOnError extends boolean = true>(options: Options<CreateUserData, ThrowOnError>) => RequestResult<CreateUserResponses, CreateUserErrors, ThrowOnError, "fields">;
/**
 * Search users
 * Search for users based on given criteria.
 *
 */
declare const searchUsers: <ThrowOnError extends boolean = true>(options?: Options<SearchUsersData, ThrowOnError>) => RequestResult<SearchUsersResponses, SearchUsersErrors, ThrowOnError, "fields">;
/**
 * Delete user
 * Deletes a user.
 *
 */
declare const deleteUser: <ThrowOnError extends boolean = true>(options: Options<DeleteUserData, ThrowOnError>) => RequestResult<DeleteUserResponses, DeleteUserErrors, ThrowOnError, "fields">;
/**
 * Get user
 * Get a user by its username.
 *
 */
declare const getUser: <ThrowOnError extends boolean = true>(options: Options<GetUserData, ThrowOnError>) => RequestResult<GetUserResponses, GetUserErrors, ThrowOnError, "fields">;
/**
 * Update user
 * Updates a user.
 *
 */
declare const updateUser: <ThrowOnError extends boolean = true>(options: Options<UpdateUserData, ThrowOnError>) => RequestResult<UpdateUserResponses, UpdateUserErrors, ThrowOnError, "fields">;
/**
 * Create admin user
 * Creates a new user and assigns the admin role to it. This endpoint is only usable when users are managed in the Orchestration Cluster and while no user is assigned to the admin role.
 */
declare const createAdminUser: <ThrowOnError extends boolean = true>(options: Options<CreateAdminUserData, ThrowOnError>) => RequestResult<CreateAdminUserResponses, CreateAdminUserErrors, ThrowOnError, "fields">;
/**
 * Search incidents
 * Search for incidents based on given criteria.
 *
 */
declare const searchIncidents: <ThrowOnError extends boolean = true>(options?: Options<SearchIncidentsData, ThrowOnError>) => RequestResult<SearchIncidentsResponses, SearchIncidentsErrors, ThrowOnError, "fields">;
/**
 * Get incident
 * Returns incident as JSON.
 *
 */
declare const getIncident: <ThrowOnError extends boolean = true>(options: Options<GetIncidentData, ThrowOnError>) => RequestResult<GetIncidentResponses, GetIncidentErrors, ThrowOnError, "fields">;
/**
 * Get usage metrics
 * Retrieve the usage metrics based on given criteria.
 */
declare const getUsageMetrics: <ThrowOnError extends boolean = true>(options: Options<GetUsageMetricsData, ThrowOnError>) => RequestResult<GetUsageMetricsResponses, GetUsageMetricsErrors, ThrowOnError, "fields">;
/**
 * Deploy resources
 * Deploys one or more resources (e.g. processes, decision models, or forms).
 * This is an atomic call, i.e. either all resources are deployed or none of them are.
 *
 */
declare const createDeployment: <ThrowOnError extends boolean = true>(options: Options<CreateDeploymentData, ThrowOnError>) => RequestResult<CreateDeploymentResponses, CreateDeploymentErrors, ThrowOnError, "fields">;
/**
 * Delete resource
 * Deletes a deployed resource.
 * This can be a process definition, decision requirements definition, or form definition
 * deployed using the deploy resources endpoint. Specify the resource you want to delete in the `resourceKey` parameter.
 *
 */
declare const deleteResource: <ThrowOnError extends boolean = true>(options: Options<DeleteResourceData, ThrowOnError>) => RequestResult<DeleteResourceResponses, DeleteResourceErrors, ThrowOnError, "fields">;
/**
 * Get resource
 * Returns a deployed resource.
 * :::info
 * Currently, this endpoint only supports RPA resources.
 * :::
 *
 */
declare const getResource: <ThrowOnError extends boolean = true>(options: Options<GetResourceData, ThrowOnError>) => RequestResult<GetResourceResponses, GetResourceErrors, ThrowOnError, "fields">;
/**
 * Get resource content
 * Returns the content of a deployed resource.
 * :::info
 * Currently, this endpoint only supports RPA resources.
 * :::
 *
 */
declare const getResourceContent: <ThrowOnError extends boolean = true>(options: Options<GetResourceContentData, ThrowOnError>) => RequestResult<GetResourceContentResponses, GetResourceContentErrors, ThrowOnError, "fields">;
/**
 * Update element instance variables
 * Updates all the variables of a particular scope (for example, process instance, element instance) with the given variable data.
 * Specify the element instance in the `elementInstanceKey` parameter.
 *
 */
declare const createElementInstanceVariables: <ThrowOnError extends boolean = true>(options: Options<CreateElementInstanceVariablesData, ThrowOnError>) => RequestResult<CreateElementInstanceVariablesResponses, CreateElementInstanceVariablesErrors, ThrowOnError, "fields">;
/**
 * Activate activities within an ad-hoc sub-process
 * Activates selected activities within an ad-hoc sub-process identified by element ID.
 * The provided element IDs must exist within the ad-hoc sub-process instance identified by the
 * provided adHocSubProcessInstanceKey.
 *
 */
declare const activateAdHocSubProcessActivities: <ThrowOnError extends boolean = true>(options: Options<ActivateAdHocSubProcessActivitiesData, ThrowOnError>) => RequestResult<ActivateAdHocSubProcessActivitiesResponses, ActivateAdHocSubProcessActivitiesErrors, ThrowOnError, "fields">;
/**
 * Broadcast signal
 * Broadcasts a signal.
 */
declare const broadcastSignal: <ThrowOnError extends boolean = true>(options: Options<BroadcastSignalData, ThrowOnError>) => RequestResult<BroadcastSignalResponses, BroadcastSignalErrors, ThrowOnError, "fields">;
/**
 * Get batch operation
 * Get batch operation by key.
 */
declare const getBatchOperation: <ThrowOnError extends boolean = true>(options: Options<GetBatchOperationData, ThrowOnError>) => RequestResult<GetBatchOperationResponses, GetBatchOperationErrors, ThrowOnError, "fields">;
/**
 * Search batch operations
 * Search for batch operations based on given criteria.
 */
declare const searchBatchOperations: <ThrowOnError extends boolean = true>(options?: Options<SearchBatchOperationsData, ThrowOnError>) => RequestResult<SearchBatchOperationsResponses, SearchBatchOperationsErrors, ThrowOnError, "fields">;
/**
 * Cancel Batch operation
 * Cancels a running batch operation.
 * This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
declare const cancelBatchOperation: <ThrowOnError extends boolean = true>(options: Options<CancelBatchOperationData, ThrowOnError>) => RequestResult<CancelBatchOperationResponses, CancelBatchOperationErrors, ThrowOnError, "fields">;
/**
 * Suspend Batch operation
 * Suspends a running batch operation.
 * This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
declare const suspendBatchOperation: <ThrowOnError extends boolean = true>(options: Options<SuspendBatchOperationData, ThrowOnError>) => RequestResult<SuspendBatchOperationResponses, SuspendBatchOperationErrors, ThrowOnError, "fields">;
/**
 * Resume Batch operation
 * Resumes a suspended batch operation.
 * This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
 *
 */
declare const resumeBatchOperation: <ThrowOnError extends boolean = true>(options: Options<ResumeBatchOperationData, ThrowOnError>) => RequestResult<ResumeBatchOperationResponses, ResumeBatchOperationErrors, ThrowOnError, "fields">;
/**
 * Search batch operation items
 * Search for batch operation items based on given criteria.
 */
declare const searchBatchOperationItems: <ThrowOnError extends boolean = true>(options?: Options<SearchBatchOperationItemsData, ThrowOnError>) => RequestResult<SearchBatchOperationItemsResponses, SearchBatchOperationItemsErrors, ThrowOnError, "fields">;

/** Manages eventual consistency for a given operation */
interface ConsistencyOptions<T> {
    waitUpToMs: number;
    pollIntervalMs?: number;
    predicate?: (result: T) => boolean | Promise<boolean>;
    onAttempt?: (info: {
        attempt: number;
        elapsedMs: number;
        remainingMs: number;
        status?: number;
        predicateResult?: boolean;
        nextDelayMs?: number;
    }) => void;
    onComplete?: (info: {
        attempts: number;
        elapsedMs: number;
    }) => void;
    abortSignal?: AbortSignal;
    /** When true, log every 200 attempt result body (raw response) before predicate evaluation */
    trace?: boolean;
}

/** Enriched job type with convenience methods. */
interface EnrichedActivatedJob extends ActivatedJobResult {
    complete(variables?: {
        [k: string]: any;
    }): Promise<JobActionReceipt>;
    fail(body: any): Promise<JobActionReceipt>;
    cancelWorkflow(): Promise<JobActionReceipt>;
    ignore(): Promise<JobActionReceipt>;
    /**
     * Extend the timeout for the job by setting a new timeout
     */
    modifyJobTimeout: ({ newTimeoutMs }: {
        newTimeoutMs: number;
    }) => Promise<void>;
    modifyRetries: ({ retries }: {
        retries: number;
    }) => Promise<void>;
    log: ReturnType<CamundaClient['logger']>;
    /** Set true once any acknowledgement method is invoked. */
    acknowledged?: boolean;
}

/** Unique receipt symbol returned by job action methods. */
declare const JobActionReceipt: "JOB_ACTION_RECEIPT";
type JobActionReceipt = typeof JobActionReceipt;
interface JobWorkerConfig<In extends z.ZodTypeAny = any, Out extends z.ZodTypeAny = any, Headers extends z.ZodTypeAny = any> {
    /** Zod schema for variables in the activated job */
    inputSchema?: In;
    /** Zod schema for variables in the complete command */
    outputSchema?: Out;
    /** Zod schema for custom headers in the activated job */
    customHeadersSchema?: Headers;
    /** Backoff between polls - default 1ms */
    pollIntervalMs?: number;
    jobHandler: (job: Job<In, Headers>) => Promise<JobActionReceipt> | JobActionReceipt;
    /** Immediately start polling for work - default `true` */
    autoStart?: boolean;
    /** concurrency limit */
    maxParallelJobs: number;
    /** requestTimeout for activation long poll - default 55_000 */
    pollTimeoutMs?: number;
    /** Job activation timeout */
    jobTimeoutMs: number;
    /** Zeebe job type */
    jobType: string;
    /** @deprecated Not used; pacing handled by long polling + client backpressure. Present only for migration compatibility. */
    maxBackoffTimeMs?: number;
    /** Optional explicit name */
    workerName?: string;
    /**
     * Validate any provided input, output, customheader schema
     * default: false
     **/
    validateSchemas?: boolean;
}
type InferOrUnknown<T extends z.ZodTypeAny | undefined> = T extends z.ZodTypeAny ? z.infer<T> : Record<string, unknown>;
type Job<In extends z.ZodTypeAny | undefined, Headers extends z.ZodTypeAny | undefined> = EnrichedActivatedJob & {
    variables: InferOrUnknown<In>;
    customHeaders: InferOrUnknown<Headers>;
};
declare class JobWorker {
    private _client;
    private _cfg;
    private _name;
    private _activeJobs;
    private _stopped;
    private _pollTimer;
    private _inFlightActivation;
    private _log;
    constructor(client: CamundaClient, cfg: JobWorkerConfig);
    get name(): string;
    get activeJobs(): number;
    get stopped(): boolean;
    start(): void;
    stop(): void;
    /**
     * Gracefully stop the worker: prevent new polls, allow any in-flight activation to finish
     * without cancellation, and wait for currently active jobs to drain (be acknowledged) up to waitUpToMs.
     * If timeout is reached, falls back to hard stop logic (cancels activation if still pending).
     */
    stopGracefully(opts?: {
        waitUpToMs?: number;
        checkIntervalMs?: number;
    }): Promise<{
        remainingJobs: number;
        timedOut: boolean;
    }>;
    private _scheduleNext;
    private _poll;
    private _handleJob;
    private _failValidation;
    private _decrementOnce;
}

type _RawReturn<F> = F extends (...a: any) => Promise<infer R> ? R : never;
type _DataOf<F> = Exclude<_RawReturn<F> extends {
    data: infer D;
} ? D : _RawReturn<F>, undefined>;
type activateAdHocSubProcessActivitiesOptions = Parameters<typeof activateAdHocSubProcessActivities>[0];
type activateAdHocSubProcessActivitiesBody = (NonNullable<activateAdHocSubProcessActivitiesOptions> extends {
    body?: infer B;
} ? B : never);
type activateAdHocSubProcessActivitiesPathParam_adHocSubProcessInstanceKey = (NonNullable<activateAdHocSubProcessActivitiesOptions> extends {
    path: {
        adHocSubProcessInstanceKey: infer P;
    };
} ? P : any);
type activateAdHocSubProcessActivitiesInput = activateAdHocSubProcessActivitiesBody & {
    adHocSubProcessInstanceKey: activateAdHocSubProcessActivitiesPathParam_adHocSubProcessInstanceKey;
};
type activateJobsOptions = Parameters<typeof activateJobs>[0];
type activateJobsBody = (NonNullable<activateJobsOptions> extends {
    body?: infer B;
} ? B : never);
type activateJobsInput = activateJobsBody;
type assignClientToGroupOptions = Parameters<typeof assignClientToGroup>[0];
type assignClientToGroupPathParam_groupId = (NonNullable<assignClientToGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type assignClientToGroupPathParam_clientId = (NonNullable<assignClientToGroupOptions> extends {
    path: {
        clientId: infer P;
    };
} ? P : any);
type assignClientToGroupInput = {
    groupId: assignClientToGroupPathParam_groupId;
    clientId: assignClientToGroupPathParam_clientId;
};
type assignClientToTenantOptions = Parameters<typeof assignClientToTenant>[0];
type assignClientToTenantPathParam_tenantId = (NonNullable<assignClientToTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type assignClientToTenantPathParam_clientId = (NonNullable<assignClientToTenantOptions> extends {
    path: {
        clientId: infer P;
    };
} ? P : any);
type assignClientToTenantInput = {
    tenantId: assignClientToTenantPathParam_tenantId;
    clientId: assignClientToTenantPathParam_clientId;
};
type assignGroupToTenantOptions = Parameters<typeof assignGroupToTenant>[0];
type assignGroupToTenantPathParam_tenantId = (NonNullable<assignGroupToTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type assignGroupToTenantPathParam_groupId = (NonNullable<assignGroupToTenantOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type assignGroupToTenantInput = {
    tenantId: assignGroupToTenantPathParam_tenantId;
    groupId: assignGroupToTenantPathParam_groupId;
};
type assignMappingRuleToGroupOptions = Parameters<typeof assignMappingRuleToGroup>[0];
type assignMappingRuleToGroupPathParam_groupId = (NonNullable<assignMappingRuleToGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type assignMappingRuleToGroupPathParam_mappingRuleId = (NonNullable<assignMappingRuleToGroupOptions> extends {
    path: {
        mappingRuleId: infer P;
    };
} ? P : any);
type assignMappingRuleToGroupInput = {
    groupId: assignMappingRuleToGroupPathParam_groupId;
    mappingRuleId: assignMappingRuleToGroupPathParam_mappingRuleId;
};
type assignMappingRuleToTenantOptions = Parameters<typeof assignMappingRuleToTenant>[0];
type assignMappingRuleToTenantPathParam_tenantId = (NonNullable<assignMappingRuleToTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type assignMappingRuleToTenantPathParam_mappingRuleId = (NonNullable<assignMappingRuleToTenantOptions> extends {
    path: {
        mappingRuleId: infer P;
    };
} ? P : any);
type assignMappingRuleToTenantInput = {
    tenantId: assignMappingRuleToTenantPathParam_tenantId;
    mappingRuleId: assignMappingRuleToTenantPathParam_mappingRuleId;
};
type assignRoleToClientOptions = Parameters<typeof assignRoleToClient>[0];
type assignRoleToClientPathParam_roleId = (NonNullable<assignRoleToClientOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type assignRoleToClientPathParam_clientId = (NonNullable<assignRoleToClientOptions> extends {
    path: {
        clientId: infer P;
    };
} ? P : any);
type assignRoleToClientInput = {
    roleId: assignRoleToClientPathParam_roleId;
    clientId: assignRoleToClientPathParam_clientId;
};
type assignRoleToGroupOptions = Parameters<typeof assignRoleToGroup>[0];
type assignRoleToGroupPathParam_roleId = (NonNullable<assignRoleToGroupOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type assignRoleToGroupPathParam_groupId = (NonNullable<assignRoleToGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type assignRoleToGroupInput = {
    roleId: assignRoleToGroupPathParam_roleId;
    groupId: assignRoleToGroupPathParam_groupId;
};
type assignRoleToMappingRuleOptions = Parameters<typeof assignRoleToMappingRule>[0];
type assignRoleToMappingRulePathParam_roleId = (NonNullable<assignRoleToMappingRuleOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type assignRoleToMappingRulePathParam_mappingRuleId = (NonNullable<assignRoleToMappingRuleOptions> extends {
    path: {
        mappingRuleId: infer P;
    };
} ? P : any);
type assignRoleToMappingRuleInput = {
    roleId: assignRoleToMappingRulePathParam_roleId;
    mappingRuleId: assignRoleToMappingRulePathParam_mappingRuleId;
};
type assignRoleToTenantOptions = Parameters<typeof assignRoleToTenant>[0];
type assignRoleToTenantPathParam_tenantId = (NonNullable<assignRoleToTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type assignRoleToTenantPathParam_roleId = (NonNullable<assignRoleToTenantOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type assignRoleToTenantInput = {
    tenantId: assignRoleToTenantPathParam_tenantId;
    roleId: assignRoleToTenantPathParam_roleId;
};
type assignRoleToUserOptions = Parameters<typeof assignRoleToUser>[0];
type assignRoleToUserPathParam_roleId = (NonNullable<assignRoleToUserOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type assignRoleToUserPathParam_username = (NonNullable<assignRoleToUserOptions> extends {
    path: {
        username: infer P;
    };
} ? P : any);
type assignRoleToUserInput = {
    roleId: assignRoleToUserPathParam_roleId;
    username: assignRoleToUserPathParam_username;
};
type assignUserTaskOptions = Parameters<typeof assignUserTask>[0];
type assignUserTaskBody = (NonNullable<assignUserTaskOptions> extends {
    body?: infer B;
} ? B : never);
type assignUserTaskPathParam_userTaskKey = (NonNullable<assignUserTaskOptions> extends {
    path: {
        userTaskKey: infer P;
    };
} ? P : any);
type assignUserTaskInput = assignUserTaskBody & {
    userTaskKey: assignUserTaskPathParam_userTaskKey;
};
type assignUserToGroupOptions = Parameters<typeof assignUserToGroup>[0];
type assignUserToGroupPathParam_groupId = (NonNullable<assignUserToGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type assignUserToGroupPathParam_username = (NonNullable<assignUserToGroupOptions> extends {
    path: {
        username: infer P;
    };
} ? P : any);
type assignUserToGroupInput = {
    groupId: assignUserToGroupPathParam_groupId;
    username: assignUserToGroupPathParam_username;
};
type assignUserToTenantOptions = Parameters<typeof assignUserToTenant>[0];
type assignUserToTenantPathParam_tenantId = (NonNullable<assignUserToTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type assignUserToTenantPathParam_username = (NonNullable<assignUserToTenantOptions> extends {
    path: {
        username: infer P;
    };
} ? P : any);
type assignUserToTenantInput = {
    tenantId: assignUserToTenantPathParam_tenantId;
    username: assignUserToTenantPathParam_username;
};
type broadcastSignalOptions = Parameters<typeof broadcastSignal>[0];
type broadcastSignalBody = (NonNullable<broadcastSignalOptions> extends {
    body?: infer B;
} ? B : never);
type broadcastSignalInput = broadcastSignalBody;
type cancelBatchOperationOptions = Parameters<typeof cancelBatchOperation>[0];
type cancelBatchOperationBody = (NonNullable<cancelBatchOperationOptions> extends {
    body?: infer B;
} ? B : never);
type cancelBatchOperationPathParam_batchOperationKey = (NonNullable<cancelBatchOperationOptions> extends {
    path: {
        batchOperationKey: infer P;
    };
} ? P : any);
type cancelBatchOperationInput = cancelBatchOperationBody & {
    batchOperationKey: cancelBatchOperationPathParam_batchOperationKey;
};
/** Management of eventual consistency **/
type cancelBatchOperationConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof cancelBatchOperation>>;
};
type cancelProcessInstanceOptions = Parameters<typeof cancelProcessInstance>[0];
type cancelProcessInstanceBody = (NonNullable<cancelProcessInstanceOptions> extends {
    body?: infer B;
} ? B : never);
type cancelProcessInstancePathParam_processInstanceKey = (NonNullable<cancelProcessInstanceOptions> extends {
    path: {
        processInstanceKey: infer P;
    };
} ? P : any);
type cancelProcessInstanceInput = cancelProcessInstanceBody & {
    processInstanceKey: cancelProcessInstancePathParam_processInstanceKey;
};
type cancelProcessInstancesBatchOperationOptions = Parameters<typeof cancelProcessInstancesBatchOperation>[0];
type cancelProcessInstancesBatchOperationBody = (NonNullable<cancelProcessInstancesBatchOperationOptions> extends {
    body?: infer B;
} ? B : never);
type cancelProcessInstancesBatchOperationInput = cancelProcessInstancesBatchOperationBody;
/** Management of eventual consistency **/
type cancelProcessInstancesBatchOperationConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof cancelProcessInstancesBatchOperation>>;
};
type completeJobOptions = Parameters<typeof completeJob>[0];
type completeJobBody = (NonNullable<completeJobOptions> extends {
    body?: infer B;
} ? B : never);
type completeJobPathParam_jobKey = (NonNullable<completeJobOptions> extends {
    path: {
        jobKey: infer P;
    };
} ? P : any);
type completeJobInput = completeJobBody & {
    jobKey: completeJobPathParam_jobKey;
};
type completeUserTaskOptions = Parameters<typeof completeUserTask>[0];
type completeUserTaskBody = (NonNullable<completeUserTaskOptions> extends {
    body?: infer B;
} ? B : never);
type completeUserTaskPathParam_userTaskKey = (NonNullable<completeUserTaskOptions> extends {
    path: {
        userTaskKey: infer P;
    };
} ? P : any);
type completeUserTaskInput = completeUserTaskBody & {
    userTaskKey: completeUserTaskPathParam_userTaskKey;
};
type correlateMessageOptions = Parameters<typeof correlateMessage>[0];
type correlateMessageBody = (NonNullable<correlateMessageOptions> extends {
    body?: infer B;
} ? B : never);
type correlateMessageInput = correlateMessageBody;
type createAdminUserOptions = Parameters<typeof createAdminUser>[0];
type createAdminUserBody = (NonNullable<createAdminUserOptions> extends {
    body?: infer B;
} ? B : never);
type createAdminUserInput = createAdminUserBody;
/** Management of eventual consistency **/
type createAdminUserConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof createAdminUser>>;
};
type createAuthorizationOptions = Parameters<typeof createAuthorization>[0];
type createAuthorizationBody = (NonNullable<createAuthorizationOptions> extends {
    body?: infer B;
} ? B : never);
type createAuthorizationInput = createAuthorizationBody;
type createDeploymentOptions = Parameters<typeof createDeployment>[0];
type createDeploymentBody = (NonNullable<createDeploymentOptions> extends {
    body?: infer B;
} ? B : never);
type createDeploymentInput = Omit<createDeploymentBody, 'resources'> & {
    resources: File[];
};
type createDocumentOptions = Parameters<typeof createDocument>[0];
type createDocumentBody = (NonNullable<createDocumentOptions> extends {
    body?: infer B;
} ? B : never);
type createDocumentQueryParam_storeId = (NonNullable<createDocumentOptions> extends {
    query: {
        storeId: infer Q;
    };
} ? Q : any);
type createDocumentQueryParam_documentId = (NonNullable<createDocumentOptions> extends {
    query: {
        documentId: infer Q;
    };
} ? Q : any);
type createDocumentInput = createDocumentBody & {
    storeId: createDocumentQueryParam_storeId;
    documentId: createDocumentQueryParam_documentId;
};
type createDocumentLinkOptions = Parameters<typeof createDocumentLink>[0];
type createDocumentLinkBody = (NonNullable<createDocumentLinkOptions> extends {
    body?: infer B;
} ? B : never);
type createDocumentLinkPathParam_documentId = (NonNullable<createDocumentLinkOptions> extends {
    path: {
        documentId: infer P;
    };
} ? P : any);
type createDocumentLinkQueryParam_storeId = (NonNullable<createDocumentLinkOptions> extends {
    query: {
        storeId: infer Q;
    };
} ? Q : any);
type createDocumentLinkQueryParam_contentHash = (NonNullable<createDocumentLinkOptions> extends {
    query: {
        contentHash: infer Q;
    };
} ? Q : any);
type createDocumentLinkInput = createDocumentLinkBody & {
    documentId: createDocumentLinkPathParam_documentId;
    storeId: createDocumentLinkQueryParam_storeId;
    contentHash: createDocumentLinkQueryParam_contentHash;
};
type createDocumentsOptions = Parameters<typeof createDocuments>[0];
type createDocumentsBody = (NonNullable<createDocumentsOptions> extends {
    body?: infer B;
} ? B : never);
type createDocumentsQueryParam_storeId = (NonNullable<createDocumentsOptions> extends {
    query: {
        storeId: infer Q;
    };
} ? Q : any);
type createDocumentsInput = createDocumentsBody & {
    storeId: createDocumentsQueryParam_storeId;
};
type createElementInstanceVariablesOptions = Parameters<typeof createElementInstanceVariables>[0];
type createElementInstanceVariablesBody = (NonNullable<createElementInstanceVariablesOptions> extends {
    body?: infer B;
} ? B : never);
type createElementInstanceVariablesPathParam_elementInstanceKey = (NonNullable<createElementInstanceVariablesOptions> extends {
    path: {
        elementInstanceKey: infer P;
    };
} ? P : any);
type createElementInstanceVariablesInput = createElementInstanceVariablesBody & {
    elementInstanceKey: createElementInstanceVariablesPathParam_elementInstanceKey;
};
type createGroupOptions = Parameters<typeof createGroup>[0];
type createGroupBody = (NonNullable<createGroupOptions> extends {
    body?: infer B;
} ? B : never);
type createGroupInput = createGroupBody;
type createMappingRuleOptions = Parameters<typeof createMappingRule>[0];
type createMappingRuleBody = (NonNullable<createMappingRuleOptions> extends {
    body?: infer B;
} ? B : never);
type createMappingRuleInput = createMappingRuleBody;
type createProcessInstanceOptions = Parameters<typeof createProcessInstance>[0];
type createProcessInstanceBody = (NonNullable<createProcessInstanceOptions> extends {
    body?: infer B;
} ? B : never);
type createProcessInstanceInput = createProcessInstanceBody;
type createRoleOptions = Parameters<typeof createRole>[0];
type createRoleBody = (NonNullable<createRoleOptions> extends {
    body?: infer B;
} ? B : never);
type createRoleInput = createRoleBody;
type createTenantOptions = Parameters<typeof createTenant>[0];
type createTenantBody = (NonNullable<createTenantOptions> extends {
    body?: infer B;
} ? B : never);
type createTenantInput = createTenantBody;
type createUserOptions = Parameters<typeof createUser>[0];
type createUserBody = (NonNullable<createUserOptions> extends {
    body?: infer B;
} ? B : never);
type createUserInput = createUserBody;
/** Management of eventual consistency **/
type createUserConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof createUser>>;
};
type deleteAuthorizationOptions = Parameters<typeof deleteAuthorization>[0];
type deleteAuthorizationPathParam_authorizationKey = (NonNullable<deleteAuthorizationOptions> extends {
    path: {
        authorizationKey: infer P;
    };
} ? P : any);
type deleteAuthorizationInput = {
    authorizationKey: deleteAuthorizationPathParam_authorizationKey;
};
type deleteDocumentOptions = Parameters<typeof deleteDocument>[0];
type deleteDocumentPathParam_documentId = (NonNullable<deleteDocumentOptions> extends {
    path: {
        documentId: infer P;
    };
} ? P : any);
type deleteDocumentQueryParam_storeId = (NonNullable<deleteDocumentOptions> extends {
    query: {
        storeId: infer Q;
    };
} ? Q : any);
type deleteDocumentInput = {
    documentId: deleteDocumentPathParam_documentId;
    storeId: deleteDocumentQueryParam_storeId;
};
type deleteGroupOptions = Parameters<typeof deleteGroup>[0];
type deleteGroupPathParam_groupId = (NonNullable<deleteGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type deleteGroupInput = {
    groupId: deleteGroupPathParam_groupId;
};
type deleteMappingRuleOptions = Parameters<typeof deleteMappingRule>[0];
type deleteMappingRulePathParam_mappingRuleId = (NonNullable<deleteMappingRuleOptions> extends {
    path: {
        mappingRuleId: infer P;
    };
} ? P : any);
type deleteMappingRuleInput = {
    mappingRuleId: deleteMappingRulePathParam_mappingRuleId;
};
type deleteResourceOptions = Parameters<typeof deleteResource>[0];
type deleteResourceBody = (NonNullable<deleteResourceOptions> extends {
    body?: infer B;
} ? B : never);
type deleteResourcePathParam_resourceKey = (NonNullable<deleteResourceOptions> extends {
    path: {
        resourceKey: infer P;
    };
} ? P : any);
type deleteResourceInput = deleteResourceBody & {
    resourceKey: deleteResourcePathParam_resourceKey;
};
type deleteRoleOptions = Parameters<typeof deleteRole>[0];
type deleteRolePathParam_roleId = (NonNullable<deleteRoleOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type deleteRoleInput = {
    roleId: deleteRolePathParam_roleId;
};
type deleteTenantOptions = Parameters<typeof deleteTenant>[0];
type deleteTenantPathParam_tenantId = (NonNullable<deleteTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type deleteTenantInput = {
    tenantId: deleteTenantPathParam_tenantId;
};
type deleteUserOptions = Parameters<typeof deleteUser>[0];
type deleteUserPathParam_username = (NonNullable<deleteUserOptions> extends {
    path: {
        username: infer P;
    };
} ? P : any);
type deleteUserInput = {
    username: deleteUserPathParam_username;
};
/** Management of eventual consistency **/
type deleteUserConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof deleteUser>>;
};
type evaluateDecisionOptions = Parameters<typeof evaluateDecision>[0];
type evaluateDecisionBody = (NonNullable<evaluateDecisionOptions> extends {
    body?: infer B;
} ? B : never);
type evaluateDecisionInput = evaluateDecisionBody;
type failJobOptions = Parameters<typeof failJob>[0];
type failJobBody = (NonNullable<failJobOptions> extends {
    body?: infer B;
} ? B : never);
type failJobPathParam_jobKey = (NonNullable<failJobOptions> extends {
    path: {
        jobKey: infer P;
    };
} ? P : any);
type failJobInput = failJobBody & {
    jobKey: failJobPathParam_jobKey;
};
type getAuthorizationOptions = Parameters<typeof getAuthorization>[0];
type getAuthorizationPathParam_authorizationKey = (NonNullable<getAuthorizationOptions> extends {
    path: {
        authorizationKey: infer P;
    };
} ? P : any);
type getAuthorizationInput = {
    authorizationKey: getAuthorizationPathParam_authorizationKey;
};
/** Management of eventual consistency **/
type getAuthorizationConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getAuthorization>>;
};
type getBatchOperationOptions = Parameters<typeof getBatchOperation>[0];
type getBatchOperationPathParam_batchOperationKey = (NonNullable<getBatchOperationOptions> extends {
    path: {
        batchOperationKey: infer P;
    };
} ? P : any);
type getBatchOperationInput = {
    batchOperationKey: getBatchOperationPathParam_batchOperationKey;
};
/** Management of eventual consistency **/
type getBatchOperationConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getBatchOperation>>;
};
type getDecisionDefinitionOptions = Parameters<typeof getDecisionDefinition>[0];
type getDecisionDefinitionPathParam_decisionDefinitionKey = (NonNullable<getDecisionDefinitionOptions> extends {
    path: {
        decisionDefinitionKey: infer P;
    };
} ? P : any);
type getDecisionDefinitionInput = {
    decisionDefinitionKey: getDecisionDefinitionPathParam_decisionDefinitionKey;
};
/** Management of eventual consistency **/
type getDecisionDefinitionConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getDecisionDefinition>>;
};
type getDecisionDefinitionXmlOptions = Parameters<typeof getDecisionDefinitionXml>[0];
type getDecisionDefinitionXmlPathParam_decisionDefinitionKey = (NonNullable<getDecisionDefinitionXmlOptions> extends {
    path: {
        decisionDefinitionKey: infer P;
    };
} ? P : any);
type getDecisionDefinitionXmlInput = {
    decisionDefinitionKey: getDecisionDefinitionXmlPathParam_decisionDefinitionKey;
};
/** Management of eventual consistency **/
type getDecisionDefinitionXmlConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getDecisionDefinitionXml>>;
};
type getDecisionInstanceOptions = Parameters<typeof getDecisionInstance>[0];
type getDecisionInstancePathParam_decisionEvaluationInstanceKey = (NonNullable<getDecisionInstanceOptions> extends {
    path: {
        decisionEvaluationInstanceKey: infer P;
    };
} ? P : any);
type getDecisionInstanceInput = {
    decisionEvaluationInstanceKey: getDecisionInstancePathParam_decisionEvaluationInstanceKey;
};
/** Management of eventual consistency **/
type getDecisionInstanceConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getDecisionInstance>>;
};
type getDecisionRequirementsOptions = Parameters<typeof getDecisionRequirements>[0];
type getDecisionRequirementsPathParam_decisionRequirementsKey = (NonNullable<getDecisionRequirementsOptions> extends {
    path: {
        decisionRequirementsKey: infer P;
    };
} ? P : any);
type getDecisionRequirementsInput = {
    decisionRequirementsKey: getDecisionRequirementsPathParam_decisionRequirementsKey;
};
/** Management of eventual consistency **/
type getDecisionRequirementsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getDecisionRequirements>>;
};
type getDecisionRequirementsXmlOptions = Parameters<typeof getDecisionRequirementsXml>[0];
type getDecisionRequirementsXmlPathParam_decisionRequirementsKey = (NonNullable<getDecisionRequirementsXmlOptions> extends {
    path: {
        decisionRequirementsKey: infer P;
    };
} ? P : any);
type getDecisionRequirementsXmlInput = {
    decisionRequirementsKey: getDecisionRequirementsXmlPathParam_decisionRequirementsKey;
};
/** Management of eventual consistency **/
type getDecisionRequirementsXmlConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getDecisionRequirementsXml>>;
};
type getDocumentOptions = Parameters<typeof getDocument>[0];
type getDocumentPathParam_documentId = (NonNullable<getDocumentOptions> extends {
    path: {
        documentId: infer P;
    };
} ? P : any);
type getDocumentQueryParam_storeId = (NonNullable<getDocumentOptions> extends {
    query: {
        storeId: infer Q;
    };
} ? Q : any);
type getDocumentQueryParam_contentHash = (NonNullable<getDocumentOptions> extends {
    query: {
        contentHash: infer Q;
    };
} ? Q : any);
type getDocumentInput = {
    documentId: getDocumentPathParam_documentId;
    storeId: getDocumentQueryParam_storeId;
    contentHash: getDocumentQueryParam_contentHash;
};
type getElementInstanceOptions = Parameters<typeof getElementInstance>[0];
type getElementInstancePathParam_elementInstanceKey = (NonNullable<getElementInstanceOptions> extends {
    path: {
        elementInstanceKey: infer P;
    };
} ? P : any);
type getElementInstanceInput = {
    elementInstanceKey: getElementInstancePathParam_elementInstanceKey;
};
/** Management of eventual consistency **/
type getElementInstanceConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getElementInstance>>;
};
type getGroupOptions = Parameters<typeof getGroup>[0];
type getGroupPathParam_groupId = (NonNullable<getGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type getGroupInput = {
    groupId: getGroupPathParam_groupId;
};
/** Management of eventual consistency **/
type getGroupConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getGroup>>;
};
type getIncidentOptions = Parameters<typeof getIncident>[0];
type getIncidentPathParam_incidentKey = (NonNullable<getIncidentOptions> extends {
    path: {
        incidentKey: infer P;
    };
} ? P : any);
type getIncidentInput = {
    incidentKey: getIncidentPathParam_incidentKey;
};
/** Management of eventual consistency **/
type getIncidentConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getIncident>>;
};
type getMappingRuleOptions = Parameters<typeof getMappingRule>[0];
type getMappingRulePathParam_mappingRuleId = (NonNullable<getMappingRuleOptions> extends {
    path: {
        mappingRuleId: infer P;
    };
} ? P : any);
type getMappingRuleInput = {
    mappingRuleId: getMappingRulePathParam_mappingRuleId;
};
/** Management of eventual consistency **/
type getMappingRuleConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getMappingRule>>;
};
type getProcessDefinitionOptions = Parameters<typeof getProcessDefinition>[0];
type getProcessDefinitionPathParam_processDefinitionKey = (NonNullable<getProcessDefinitionOptions> extends {
    path: {
        processDefinitionKey: infer P;
    };
} ? P : any);
type getProcessDefinitionInput = {
    processDefinitionKey: getProcessDefinitionPathParam_processDefinitionKey;
};
/** Management of eventual consistency **/
type getProcessDefinitionConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getProcessDefinition>>;
};
type getProcessDefinitionStatisticsOptions = Parameters<typeof getProcessDefinitionStatistics>[0];
type getProcessDefinitionStatisticsBody = (NonNullable<getProcessDefinitionStatisticsOptions> extends {
    body?: infer B;
} ? B : never);
type getProcessDefinitionStatisticsPathParam_processDefinitionKey = (NonNullable<getProcessDefinitionStatisticsOptions> extends {
    path: {
        processDefinitionKey: infer P;
    };
} ? P : any);
type getProcessDefinitionStatisticsInput = getProcessDefinitionStatisticsBody & {
    processDefinitionKey: getProcessDefinitionStatisticsPathParam_processDefinitionKey;
};
/** Management of eventual consistency **/
type getProcessDefinitionStatisticsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getProcessDefinitionStatistics>>;
};
type getProcessDefinitionXmlOptions = Parameters<typeof getProcessDefinitionXml>[0];
type getProcessDefinitionXmlPathParam_processDefinitionKey = (NonNullable<getProcessDefinitionXmlOptions> extends {
    path: {
        processDefinitionKey: infer P;
    };
} ? P : any);
type getProcessDefinitionXmlInput = {
    processDefinitionKey: getProcessDefinitionXmlPathParam_processDefinitionKey;
};
/** Management of eventual consistency **/
type getProcessDefinitionXmlConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getProcessDefinitionXml>>;
};
type getProcessInstanceOptions = Parameters<typeof getProcessInstance>[0];
type getProcessInstancePathParam_processInstanceKey = (NonNullable<getProcessInstanceOptions> extends {
    path: {
        processInstanceKey: infer P;
    };
} ? P : any);
type getProcessInstanceInput = {
    processInstanceKey: getProcessInstancePathParam_processInstanceKey;
};
/** Management of eventual consistency **/
type getProcessInstanceConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getProcessInstance>>;
};
type getProcessInstanceCallHierarchyOptions = Parameters<typeof getProcessInstanceCallHierarchy>[0];
type getProcessInstanceCallHierarchyPathParam_processInstanceKey = (NonNullable<getProcessInstanceCallHierarchyOptions> extends {
    path: {
        processInstanceKey: infer P;
    };
} ? P : any);
type getProcessInstanceCallHierarchyInput = {
    processInstanceKey: getProcessInstanceCallHierarchyPathParam_processInstanceKey;
};
/** Management of eventual consistency **/
type getProcessInstanceCallHierarchyConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getProcessInstanceCallHierarchy>>;
};
type getProcessInstanceSequenceFlowsOptions = Parameters<typeof getProcessInstanceSequenceFlows>[0];
type getProcessInstanceSequenceFlowsPathParam_processInstanceKey = (NonNullable<getProcessInstanceSequenceFlowsOptions> extends {
    path: {
        processInstanceKey: infer P;
    };
} ? P : any);
type getProcessInstanceSequenceFlowsInput = {
    processInstanceKey: getProcessInstanceSequenceFlowsPathParam_processInstanceKey;
};
/** Management of eventual consistency **/
type getProcessInstanceSequenceFlowsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getProcessInstanceSequenceFlows>>;
};
type getProcessInstanceStatisticsOptions = Parameters<typeof getProcessInstanceStatistics>[0];
type getProcessInstanceStatisticsPathParam_processInstanceKey = (NonNullable<getProcessInstanceStatisticsOptions> extends {
    path: {
        processInstanceKey: infer P;
    };
} ? P : any);
type getProcessInstanceStatisticsInput = {
    processInstanceKey: getProcessInstanceStatisticsPathParam_processInstanceKey;
};
/** Management of eventual consistency **/
type getProcessInstanceStatisticsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getProcessInstanceStatistics>>;
};
type getResourceOptions = Parameters<typeof getResource>[0];
type getResourcePathParam_resourceKey = (NonNullable<getResourceOptions> extends {
    path: {
        resourceKey: infer P;
    };
} ? P : any);
type getResourceInput = {
    resourceKey: getResourcePathParam_resourceKey;
};
type getResourceContentOptions = Parameters<typeof getResourceContent>[0];
type getResourceContentPathParam_resourceKey = (NonNullable<getResourceContentOptions> extends {
    path: {
        resourceKey: infer P;
    };
} ? P : any);
type getResourceContentInput = {
    resourceKey: getResourceContentPathParam_resourceKey;
};
type getRoleOptions = Parameters<typeof getRole>[0];
type getRolePathParam_roleId = (NonNullable<getRoleOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type getRoleInput = {
    roleId: getRolePathParam_roleId;
};
/** Management of eventual consistency **/
type getRoleConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getRole>>;
};
type getStartProcessFormOptions = Parameters<typeof getStartProcessForm>[0];
type getStartProcessFormPathParam_processDefinitionKey = (NonNullable<getStartProcessFormOptions> extends {
    path: {
        processDefinitionKey: infer P;
    };
} ? P : any);
type getStartProcessFormInput = {
    processDefinitionKey: getStartProcessFormPathParam_processDefinitionKey;
};
/** Management of eventual consistency **/
type getStartProcessFormConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getStartProcessForm>>;
};
type getTenantOptions = Parameters<typeof getTenant>[0];
type getTenantPathParam_tenantId = (NonNullable<getTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type getTenantInput = {
    tenantId: getTenantPathParam_tenantId;
};
/** Management of eventual consistency **/
type getTenantConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getTenant>>;
};
type getUsageMetricsOptions = Parameters<typeof getUsageMetrics>[0];
type getUsageMetricsQueryParam_startTime = (NonNullable<getUsageMetricsOptions> extends {
    query: {
        startTime: infer Q;
    };
} ? Q : any);
type getUsageMetricsQueryParam_endTime = (NonNullable<getUsageMetricsOptions> extends {
    query: {
        endTime: infer Q;
    };
} ? Q : any);
type getUsageMetricsQueryParam_tenantId = (NonNullable<getUsageMetricsOptions> extends {
    query: {
        tenantId: infer Q;
    };
} ? Q : any);
type getUsageMetricsQueryParam_withTenants = (NonNullable<getUsageMetricsOptions> extends {
    query: {
        withTenants: infer Q;
    };
} ? Q : any);
type getUsageMetricsInput = {
    startTime: getUsageMetricsQueryParam_startTime;
    endTime: getUsageMetricsQueryParam_endTime;
    tenantId: getUsageMetricsQueryParam_tenantId;
    withTenants: getUsageMetricsQueryParam_withTenants;
};
/** Management of eventual consistency **/
type getUsageMetricsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getUsageMetrics>>;
};
type getUserOptions = Parameters<typeof getUser>[0];
type getUserPathParam_username = (NonNullable<getUserOptions> extends {
    path: {
        username: infer P;
    };
} ? P : any);
type getUserInput = {
    username: getUserPathParam_username;
};
/** Management of eventual consistency **/
type getUserConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getUser>>;
};
type getUserTaskOptions = Parameters<typeof getUserTask>[0];
type getUserTaskPathParam_userTaskKey = (NonNullable<getUserTaskOptions> extends {
    path: {
        userTaskKey: infer P;
    };
} ? P : any);
type getUserTaskInput = {
    userTaskKey: getUserTaskPathParam_userTaskKey;
};
/** Management of eventual consistency **/
type getUserTaskConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getUserTask>>;
};
type getUserTaskFormOptions = Parameters<typeof getUserTaskForm>[0];
type getUserTaskFormPathParam_userTaskKey = (NonNullable<getUserTaskFormOptions> extends {
    path: {
        userTaskKey: infer P;
    };
} ? P : any);
type getUserTaskFormInput = {
    userTaskKey: getUserTaskFormPathParam_userTaskKey;
};
/** Management of eventual consistency **/
type getUserTaskFormConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getUserTaskForm>>;
};
type getVariableOptions = Parameters<typeof getVariable>[0];
type getVariablePathParam_variableKey = (NonNullable<getVariableOptions> extends {
    path: {
        variableKey: infer P;
    };
} ? P : any);
type getVariableInput = {
    variableKey: getVariablePathParam_variableKey;
};
/** Management of eventual consistency **/
type getVariableConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof getVariable>>;
};
type migrateProcessInstanceOptions = Parameters<typeof migrateProcessInstance>[0];
type migrateProcessInstanceBody = (NonNullable<migrateProcessInstanceOptions> extends {
    body?: infer B;
} ? B : never);
type migrateProcessInstancePathParam_processInstanceKey = (NonNullable<migrateProcessInstanceOptions> extends {
    path: {
        processInstanceKey: infer P;
    };
} ? P : any);
type migrateProcessInstanceInput = migrateProcessInstanceBody & {
    processInstanceKey: migrateProcessInstancePathParam_processInstanceKey;
};
type migrateProcessInstancesBatchOperationOptions = Parameters<typeof migrateProcessInstancesBatchOperation>[0];
type migrateProcessInstancesBatchOperationBody = (NonNullable<migrateProcessInstancesBatchOperationOptions> extends {
    body?: infer B;
} ? B : never);
type migrateProcessInstancesBatchOperationInput = migrateProcessInstancesBatchOperationBody;
/** Management of eventual consistency **/
type migrateProcessInstancesBatchOperationConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof migrateProcessInstancesBatchOperation>>;
};
type modifyProcessInstanceOptions = Parameters<typeof modifyProcessInstance>[0];
type modifyProcessInstanceBody = (NonNullable<modifyProcessInstanceOptions> extends {
    body?: infer B;
} ? B : never);
type modifyProcessInstancePathParam_processInstanceKey = (NonNullable<modifyProcessInstanceOptions> extends {
    path: {
        processInstanceKey: infer P;
    };
} ? P : any);
type modifyProcessInstanceInput = modifyProcessInstanceBody & {
    processInstanceKey: modifyProcessInstancePathParam_processInstanceKey;
};
type modifyProcessInstancesBatchOperationOptions = Parameters<typeof modifyProcessInstancesBatchOperation>[0];
type modifyProcessInstancesBatchOperationBody = (NonNullable<modifyProcessInstancesBatchOperationOptions> extends {
    body?: infer B;
} ? B : never);
type modifyProcessInstancesBatchOperationInput = modifyProcessInstancesBatchOperationBody;
/** Management of eventual consistency **/
type modifyProcessInstancesBatchOperationConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof modifyProcessInstancesBatchOperation>>;
};
type pinClockOptions = Parameters<typeof pinClock>[0];
type pinClockBody = (NonNullable<pinClockOptions> extends {
    body?: infer B;
} ? B : never);
type pinClockInput = pinClockBody;
type publishMessageOptions = Parameters<typeof publishMessage>[0];
type publishMessageBody = (NonNullable<publishMessageOptions> extends {
    body?: infer B;
} ? B : never);
type publishMessageInput = publishMessageBody;
type resolveIncidentOptions = Parameters<typeof resolveIncident>[0];
type resolveIncidentBody = (NonNullable<resolveIncidentOptions> extends {
    body?: infer B;
} ? B : never);
type resolveIncidentPathParam_incidentKey = (NonNullable<resolveIncidentOptions> extends {
    path: {
        incidentKey: infer P;
    };
} ? P : any);
type resolveIncidentInput = resolveIncidentBody & {
    incidentKey: resolveIncidentPathParam_incidentKey;
};
type resolveIncidentsBatchOperationOptions = Parameters<typeof resolveIncidentsBatchOperation>[0];
type resolveIncidentsBatchOperationBody = (NonNullable<resolveIncidentsBatchOperationOptions> extends {
    body?: infer B;
} ? B : never);
type resolveIncidentsBatchOperationInput = resolveIncidentsBatchOperationBody;
/** Management of eventual consistency **/
type resolveIncidentsBatchOperationConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof resolveIncidentsBatchOperation>>;
};
type resumeBatchOperationOptions = Parameters<typeof resumeBatchOperation>[0];
type resumeBatchOperationBody = (NonNullable<resumeBatchOperationOptions> extends {
    body?: infer B;
} ? B : never);
type resumeBatchOperationPathParam_batchOperationKey = (NonNullable<resumeBatchOperationOptions> extends {
    path: {
        batchOperationKey: infer P;
    };
} ? P : any);
type resumeBatchOperationInput = resumeBatchOperationBody & {
    batchOperationKey: resumeBatchOperationPathParam_batchOperationKey;
};
/** Management of eventual consistency **/
type resumeBatchOperationConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof resumeBatchOperation>>;
};
type searchAuthorizationsOptions = Parameters<typeof searchAuthorizations>[0];
type searchAuthorizationsBody = (NonNullable<searchAuthorizationsOptions> extends {
    body?: infer B;
} ? B : never);
type searchAuthorizationsInput = searchAuthorizationsBody;
/** Management of eventual consistency **/
type searchAuthorizationsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchAuthorizations>>;
};
type searchBatchOperationItemsOptions = Parameters<typeof searchBatchOperationItems>[0];
type searchBatchOperationItemsBody = (NonNullable<searchBatchOperationItemsOptions> extends {
    body?: infer B;
} ? B : never);
type searchBatchOperationItemsInput = searchBatchOperationItemsBody;
/** Management of eventual consistency **/
type searchBatchOperationItemsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchBatchOperationItems>>;
};
type searchBatchOperationsOptions = Parameters<typeof searchBatchOperations>[0];
type searchBatchOperationsBody = (NonNullable<searchBatchOperationsOptions> extends {
    body?: infer B;
} ? B : never);
type searchBatchOperationsInput = searchBatchOperationsBody;
/** Management of eventual consistency **/
type searchBatchOperationsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchBatchOperations>>;
};
type searchClientsForGroupOptions = Parameters<typeof searchClientsForGroup>[0];
type searchClientsForGroupBody = (NonNullable<searchClientsForGroupOptions> extends {
    body?: infer B;
} ? B : never);
type searchClientsForGroupPathParam_groupId = (NonNullable<searchClientsForGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type searchClientsForGroupInput = searchClientsForGroupBody & {
    groupId: searchClientsForGroupPathParam_groupId;
};
/** Management of eventual consistency **/
type searchClientsForGroupConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchClientsForGroup>>;
};
type searchClientsForRoleOptions = Parameters<typeof searchClientsForRole>[0];
type searchClientsForRoleBody = (NonNullable<searchClientsForRoleOptions> extends {
    body?: infer B;
} ? B : never);
type searchClientsForRolePathParam_roleId = (NonNullable<searchClientsForRoleOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type searchClientsForRoleInput = searchClientsForRoleBody & {
    roleId: searchClientsForRolePathParam_roleId;
};
/** Management of eventual consistency **/
type searchClientsForRoleConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchClientsForRole>>;
};
type searchClientsForTenantOptions = Parameters<typeof searchClientsForTenant>[0];
type searchClientsForTenantBody = (NonNullable<searchClientsForTenantOptions> extends {
    body?: infer B;
} ? B : never);
type searchClientsForTenantPathParam_tenantId = (NonNullable<searchClientsForTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type searchClientsForTenantInput = searchClientsForTenantBody & {
    tenantId: searchClientsForTenantPathParam_tenantId;
};
/** Management of eventual consistency **/
type searchClientsForTenantConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchClientsForTenant>>;
};
type searchCorrelatedMessageSubscriptionsOptions = Parameters<typeof searchCorrelatedMessageSubscriptions>[0];
type searchCorrelatedMessageSubscriptionsBody = (NonNullable<searchCorrelatedMessageSubscriptionsOptions> extends {
    body?: infer B;
} ? B : never);
type searchCorrelatedMessageSubscriptionsInput = searchCorrelatedMessageSubscriptionsBody;
/** Management of eventual consistency **/
type searchCorrelatedMessageSubscriptionsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchCorrelatedMessageSubscriptions>>;
};
type searchDecisionDefinitionsOptions = Parameters<typeof searchDecisionDefinitions>[0];
type searchDecisionDefinitionsBody = (NonNullable<searchDecisionDefinitionsOptions> extends {
    body?: infer B;
} ? B : never);
type searchDecisionDefinitionsInput = searchDecisionDefinitionsBody;
/** Management of eventual consistency **/
type searchDecisionDefinitionsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchDecisionDefinitions>>;
};
type searchDecisionInstancesOptions = Parameters<typeof searchDecisionInstances>[0];
type searchDecisionInstancesBody = (NonNullable<searchDecisionInstancesOptions> extends {
    body?: infer B;
} ? B : never);
type searchDecisionInstancesInput = searchDecisionInstancesBody;
/** Management of eventual consistency **/
type searchDecisionInstancesConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchDecisionInstances>>;
};
type searchDecisionRequirementsOptions = Parameters<typeof searchDecisionRequirements>[0];
type searchDecisionRequirementsBody = (NonNullable<searchDecisionRequirementsOptions> extends {
    body?: infer B;
} ? B : never);
type searchDecisionRequirementsInput = searchDecisionRequirementsBody;
/** Management of eventual consistency **/
type searchDecisionRequirementsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchDecisionRequirements>>;
};
type searchElementInstancesOptions = Parameters<typeof searchElementInstances>[0];
type searchElementInstancesBody = (NonNullable<searchElementInstancesOptions> extends {
    body?: infer B;
} ? B : never);
type searchElementInstancesInput = searchElementInstancesBody;
/** Management of eventual consistency **/
type searchElementInstancesConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchElementInstances>>;
};
type searchGroupIdsForTenantOptions = Parameters<typeof searchGroupIdsForTenant>[0];
type searchGroupIdsForTenantBody = (NonNullable<searchGroupIdsForTenantOptions> extends {
    body?: infer B;
} ? B : never);
type searchGroupIdsForTenantPathParam_tenantId = (NonNullable<searchGroupIdsForTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type searchGroupIdsForTenantInput = searchGroupIdsForTenantBody & {
    tenantId: searchGroupIdsForTenantPathParam_tenantId;
};
/** Management of eventual consistency **/
type searchGroupIdsForTenantConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchGroupIdsForTenant>>;
};
type searchGroupsOptions = Parameters<typeof searchGroups>[0];
type searchGroupsBody = (NonNullable<searchGroupsOptions> extends {
    body?: infer B;
} ? B : never);
type searchGroupsInput = searchGroupsBody;
/** Management of eventual consistency **/
type searchGroupsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchGroups>>;
};
type searchGroupsForRoleOptions = Parameters<typeof searchGroupsForRole>[0];
type searchGroupsForRoleBody = (NonNullable<searchGroupsForRoleOptions> extends {
    body?: infer B;
} ? B : never);
type searchGroupsForRolePathParam_roleId = (NonNullable<searchGroupsForRoleOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type searchGroupsForRoleInput = searchGroupsForRoleBody & {
    roleId: searchGroupsForRolePathParam_roleId;
};
/** Management of eventual consistency **/
type searchGroupsForRoleConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchGroupsForRole>>;
};
type searchIncidentsOptions = Parameters<typeof searchIncidents>[0];
type searchIncidentsBody = (NonNullable<searchIncidentsOptions> extends {
    body?: infer B;
} ? B : never);
type searchIncidentsInput = searchIncidentsBody;
/** Management of eventual consistency **/
type searchIncidentsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchIncidents>>;
};
type searchJobsOptions = Parameters<typeof searchJobs>[0];
type searchJobsBody = (NonNullable<searchJobsOptions> extends {
    body?: infer B;
} ? B : never);
type searchJobsInput = searchJobsBody;
/** Management of eventual consistency **/
type searchJobsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchJobs>>;
};
type searchMappingRuleOptions = Parameters<typeof searchMappingRule>[0];
type searchMappingRuleBody = (NonNullable<searchMappingRuleOptions> extends {
    body?: infer B;
} ? B : never);
type searchMappingRuleInput = searchMappingRuleBody;
/** Management of eventual consistency **/
type searchMappingRuleConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchMappingRule>>;
};
type searchMappingRulesForGroupOptions = Parameters<typeof searchMappingRulesForGroup>[0];
type searchMappingRulesForGroupBody = (NonNullable<searchMappingRulesForGroupOptions> extends {
    body?: infer B;
} ? B : never);
type searchMappingRulesForGroupPathParam_groupId = (NonNullable<searchMappingRulesForGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type searchMappingRulesForGroupInput = searchMappingRulesForGroupBody & {
    groupId: searchMappingRulesForGroupPathParam_groupId;
};
/** Management of eventual consistency **/
type searchMappingRulesForGroupConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchMappingRulesForGroup>>;
};
type searchMappingRulesForRoleOptions = Parameters<typeof searchMappingRulesForRole>[0];
type searchMappingRulesForRoleBody = (NonNullable<searchMappingRulesForRoleOptions> extends {
    body?: infer B;
} ? B : never);
type searchMappingRulesForRolePathParam_roleId = (NonNullable<searchMappingRulesForRoleOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type searchMappingRulesForRoleInput = searchMappingRulesForRoleBody & {
    roleId: searchMappingRulesForRolePathParam_roleId;
};
/** Management of eventual consistency **/
type searchMappingRulesForRoleConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchMappingRulesForRole>>;
};
type searchMappingRulesForTenantOptions = Parameters<typeof searchMappingRulesForTenant>[0];
type searchMappingRulesForTenantBody = (NonNullable<searchMappingRulesForTenantOptions> extends {
    body?: infer B;
} ? B : never);
type searchMappingRulesForTenantPathParam_tenantId = (NonNullable<searchMappingRulesForTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type searchMappingRulesForTenantInput = searchMappingRulesForTenantBody & {
    tenantId: searchMappingRulesForTenantPathParam_tenantId;
};
/** Management of eventual consistency **/
type searchMappingRulesForTenantConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchMappingRulesForTenant>>;
};
type searchMessageSubscriptionsOptions = Parameters<typeof searchMessageSubscriptions>[0];
type searchMessageSubscriptionsBody = (NonNullable<searchMessageSubscriptionsOptions> extends {
    body?: infer B;
} ? B : never);
type searchMessageSubscriptionsInput = searchMessageSubscriptionsBody;
/** Management of eventual consistency **/
type searchMessageSubscriptionsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchMessageSubscriptions>>;
};
type searchProcessDefinitionsOptions = Parameters<typeof searchProcessDefinitions>[0];
type searchProcessDefinitionsBody = (NonNullable<searchProcessDefinitionsOptions> extends {
    body?: infer B;
} ? B : never);
type searchProcessDefinitionsInput = searchProcessDefinitionsBody;
/** Management of eventual consistency **/
type searchProcessDefinitionsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchProcessDefinitions>>;
};
type searchProcessInstanceIncidentsOptions = Parameters<typeof searchProcessInstanceIncidents>[0];
type searchProcessInstanceIncidentsBody = (NonNullable<searchProcessInstanceIncidentsOptions> extends {
    body?: infer B;
} ? B : never);
type searchProcessInstanceIncidentsPathParam_processInstanceKey = (NonNullable<searchProcessInstanceIncidentsOptions> extends {
    path: {
        processInstanceKey: infer P;
    };
} ? P : any);
type searchProcessInstanceIncidentsInput = searchProcessInstanceIncidentsBody & {
    processInstanceKey: searchProcessInstanceIncidentsPathParam_processInstanceKey;
};
/** Management of eventual consistency **/
type searchProcessInstanceIncidentsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchProcessInstanceIncidents>>;
};
type searchProcessInstancesOptions = Parameters<typeof searchProcessInstances>[0];
type searchProcessInstancesBody = (NonNullable<searchProcessInstancesOptions> extends {
    body?: infer B;
} ? B : never);
type searchProcessInstancesInput = searchProcessInstancesBody;
/** Management of eventual consistency **/
type searchProcessInstancesConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchProcessInstances>>;
};
type searchRolesOptions = Parameters<typeof searchRoles>[0];
type searchRolesBody = (NonNullable<searchRolesOptions> extends {
    body?: infer B;
} ? B : never);
type searchRolesInput = searchRolesBody;
/** Management of eventual consistency **/
type searchRolesConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchRoles>>;
};
type searchRolesForGroupOptions = Parameters<typeof searchRolesForGroup>[0];
type searchRolesForGroupBody = (NonNullable<searchRolesForGroupOptions> extends {
    body?: infer B;
} ? B : never);
type searchRolesForGroupPathParam_groupId = (NonNullable<searchRolesForGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type searchRolesForGroupInput = searchRolesForGroupBody & {
    groupId: searchRolesForGroupPathParam_groupId;
};
/** Management of eventual consistency **/
type searchRolesForGroupConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchRolesForGroup>>;
};
type searchRolesForTenantOptions = Parameters<typeof searchRolesForTenant>[0];
type searchRolesForTenantBody = (NonNullable<searchRolesForTenantOptions> extends {
    body?: infer B;
} ? B : never);
type searchRolesForTenantPathParam_tenantId = (NonNullable<searchRolesForTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type searchRolesForTenantInput = searchRolesForTenantBody & {
    tenantId: searchRolesForTenantPathParam_tenantId;
};
/** Management of eventual consistency **/
type searchRolesForTenantConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchRolesForTenant>>;
};
type searchTenantsOptions = Parameters<typeof searchTenants>[0];
type searchTenantsBody = (NonNullable<searchTenantsOptions> extends {
    body?: infer B;
} ? B : never);
type searchTenantsInput = searchTenantsBody;
/** Management of eventual consistency **/
type searchTenantsConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchTenants>>;
};
type searchUsersOptions = Parameters<typeof searchUsers>[0];
type searchUsersBody = (NonNullable<searchUsersOptions> extends {
    body?: infer B;
} ? B : never);
type searchUsersInput = searchUsersBody;
/** Management of eventual consistency **/
type searchUsersConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchUsers>>;
};
type searchUsersForGroupOptions = Parameters<typeof searchUsersForGroup>[0];
type searchUsersForGroupBody = (NonNullable<searchUsersForGroupOptions> extends {
    body?: infer B;
} ? B : never);
type searchUsersForGroupPathParam_groupId = (NonNullable<searchUsersForGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type searchUsersForGroupInput = searchUsersForGroupBody & {
    groupId: searchUsersForGroupPathParam_groupId;
};
/** Management of eventual consistency **/
type searchUsersForGroupConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchUsersForGroup>>;
};
type searchUsersForRoleOptions = Parameters<typeof searchUsersForRole>[0];
type searchUsersForRoleBody = (NonNullable<searchUsersForRoleOptions> extends {
    body?: infer B;
} ? B : never);
type searchUsersForRolePathParam_roleId = (NonNullable<searchUsersForRoleOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type searchUsersForRoleInput = searchUsersForRoleBody & {
    roleId: searchUsersForRolePathParam_roleId;
};
/** Management of eventual consistency **/
type searchUsersForRoleConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchUsersForRole>>;
};
type searchUsersForTenantOptions = Parameters<typeof searchUsersForTenant>[0];
type searchUsersForTenantBody = (NonNullable<searchUsersForTenantOptions> extends {
    body?: infer B;
} ? B : never);
type searchUsersForTenantPathParam_tenantId = (NonNullable<searchUsersForTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type searchUsersForTenantInput = searchUsersForTenantBody & {
    tenantId: searchUsersForTenantPathParam_tenantId;
};
/** Management of eventual consistency **/
type searchUsersForTenantConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchUsersForTenant>>;
};
type searchUserTasksOptions = Parameters<typeof searchUserTasks>[0];
type searchUserTasksBody = (NonNullable<searchUserTasksOptions> extends {
    body?: infer B;
} ? B : never);
type searchUserTasksInput = searchUserTasksBody;
/** Management of eventual consistency **/
type searchUserTasksConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchUserTasks>>;
};
type searchUserTaskVariablesOptions = Parameters<typeof searchUserTaskVariables>[0];
type searchUserTaskVariablesBody = (NonNullable<searchUserTaskVariablesOptions> extends {
    body?: infer B;
} ? B : never);
type searchUserTaskVariablesPathParam_userTaskKey = (NonNullable<searchUserTaskVariablesOptions> extends {
    path: {
        userTaskKey: infer P;
    };
} ? P : any);
type searchUserTaskVariablesInput = searchUserTaskVariablesBody & {
    userTaskKey: searchUserTaskVariablesPathParam_userTaskKey;
};
/** Management of eventual consistency **/
type searchUserTaskVariablesConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchUserTaskVariables>>;
};
type searchVariablesOptions = Parameters<typeof searchVariables>[0];
type searchVariablesBody = (NonNullable<searchVariablesOptions> extends {
    body?: infer B;
} ? B : never);
type searchVariablesInput = searchVariablesBody;
/** Management of eventual consistency **/
type searchVariablesConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof searchVariables>>;
};
type suspendBatchOperationOptions = Parameters<typeof suspendBatchOperation>[0];
type suspendBatchOperationBody = (NonNullable<suspendBatchOperationOptions> extends {
    body?: infer B;
} ? B : never);
type suspendBatchOperationPathParam_batchOperationKey = (NonNullable<suspendBatchOperationOptions> extends {
    path: {
        batchOperationKey: infer P;
    };
} ? P : any);
type suspendBatchOperationInput = suspendBatchOperationBody & {
    batchOperationKey: suspendBatchOperationPathParam_batchOperationKey;
};
/** Management of eventual consistency **/
type suspendBatchOperationConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof suspendBatchOperation>>;
};
type throwJobErrorOptions = Parameters<typeof throwJobError>[0];
type throwJobErrorBody = (NonNullable<throwJobErrorOptions> extends {
    body?: infer B;
} ? B : never);
type throwJobErrorPathParam_jobKey = (NonNullable<throwJobErrorOptions> extends {
    path: {
        jobKey: infer P;
    };
} ? P : any);
type throwJobErrorInput = throwJobErrorBody & {
    jobKey: throwJobErrorPathParam_jobKey;
};
type unassignClientFromGroupOptions = Parameters<typeof unassignClientFromGroup>[0];
type unassignClientFromGroupPathParam_groupId = (NonNullable<unassignClientFromGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type unassignClientFromGroupPathParam_clientId = (NonNullable<unassignClientFromGroupOptions> extends {
    path: {
        clientId: infer P;
    };
} ? P : any);
type unassignClientFromGroupInput = {
    groupId: unassignClientFromGroupPathParam_groupId;
    clientId: unassignClientFromGroupPathParam_clientId;
};
type unassignClientFromTenantOptions = Parameters<typeof unassignClientFromTenant>[0];
type unassignClientFromTenantPathParam_tenantId = (NonNullable<unassignClientFromTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type unassignClientFromTenantPathParam_clientId = (NonNullable<unassignClientFromTenantOptions> extends {
    path: {
        clientId: infer P;
    };
} ? P : any);
type unassignClientFromTenantInput = {
    tenantId: unassignClientFromTenantPathParam_tenantId;
    clientId: unassignClientFromTenantPathParam_clientId;
};
type unassignGroupFromTenantOptions = Parameters<typeof unassignGroupFromTenant>[0];
type unassignGroupFromTenantPathParam_tenantId = (NonNullable<unassignGroupFromTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type unassignGroupFromTenantPathParam_groupId = (NonNullable<unassignGroupFromTenantOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type unassignGroupFromTenantInput = {
    tenantId: unassignGroupFromTenantPathParam_tenantId;
    groupId: unassignGroupFromTenantPathParam_groupId;
};
type unassignMappingRuleFromGroupOptions = Parameters<typeof unassignMappingRuleFromGroup>[0];
type unassignMappingRuleFromGroupPathParam_groupId = (NonNullable<unassignMappingRuleFromGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type unassignMappingRuleFromGroupPathParam_mappingRuleId = (NonNullable<unassignMappingRuleFromGroupOptions> extends {
    path: {
        mappingRuleId: infer P;
    };
} ? P : any);
type unassignMappingRuleFromGroupInput = {
    groupId: unassignMappingRuleFromGroupPathParam_groupId;
    mappingRuleId: unassignMappingRuleFromGroupPathParam_mappingRuleId;
};
type unassignMappingRuleFromTenantOptions = Parameters<typeof unassignMappingRuleFromTenant>[0];
type unassignMappingRuleFromTenantPathParam_tenantId = (NonNullable<unassignMappingRuleFromTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type unassignMappingRuleFromTenantPathParam_mappingRuleId = (NonNullable<unassignMappingRuleFromTenantOptions> extends {
    path: {
        mappingRuleId: infer P;
    };
} ? P : any);
type unassignMappingRuleFromTenantInput = {
    tenantId: unassignMappingRuleFromTenantPathParam_tenantId;
    mappingRuleId: unassignMappingRuleFromTenantPathParam_mappingRuleId;
};
type unassignRoleFromClientOptions = Parameters<typeof unassignRoleFromClient>[0];
type unassignRoleFromClientPathParam_roleId = (NonNullable<unassignRoleFromClientOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type unassignRoleFromClientPathParam_clientId = (NonNullable<unassignRoleFromClientOptions> extends {
    path: {
        clientId: infer P;
    };
} ? P : any);
type unassignRoleFromClientInput = {
    roleId: unassignRoleFromClientPathParam_roleId;
    clientId: unassignRoleFromClientPathParam_clientId;
};
type unassignRoleFromGroupOptions = Parameters<typeof unassignRoleFromGroup>[0];
type unassignRoleFromGroupPathParam_roleId = (NonNullable<unassignRoleFromGroupOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type unassignRoleFromGroupPathParam_groupId = (NonNullable<unassignRoleFromGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type unassignRoleFromGroupInput = {
    roleId: unassignRoleFromGroupPathParam_roleId;
    groupId: unassignRoleFromGroupPathParam_groupId;
};
type unassignRoleFromMappingRuleOptions = Parameters<typeof unassignRoleFromMappingRule>[0];
type unassignRoleFromMappingRulePathParam_roleId = (NonNullable<unassignRoleFromMappingRuleOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type unassignRoleFromMappingRulePathParam_mappingRuleId = (NonNullable<unassignRoleFromMappingRuleOptions> extends {
    path: {
        mappingRuleId: infer P;
    };
} ? P : any);
type unassignRoleFromMappingRuleInput = {
    roleId: unassignRoleFromMappingRulePathParam_roleId;
    mappingRuleId: unassignRoleFromMappingRulePathParam_mappingRuleId;
};
type unassignRoleFromTenantOptions = Parameters<typeof unassignRoleFromTenant>[0];
type unassignRoleFromTenantPathParam_tenantId = (NonNullable<unassignRoleFromTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type unassignRoleFromTenantPathParam_roleId = (NonNullable<unassignRoleFromTenantOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type unassignRoleFromTenantInput = {
    tenantId: unassignRoleFromTenantPathParam_tenantId;
    roleId: unassignRoleFromTenantPathParam_roleId;
};
type unassignRoleFromUserOptions = Parameters<typeof unassignRoleFromUser>[0];
type unassignRoleFromUserPathParam_roleId = (NonNullable<unassignRoleFromUserOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type unassignRoleFromUserPathParam_username = (NonNullable<unassignRoleFromUserOptions> extends {
    path: {
        username: infer P;
    };
} ? P : any);
type unassignRoleFromUserInput = {
    roleId: unassignRoleFromUserPathParam_roleId;
    username: unassignRoleFromUserPathParam_username;
};
type unassignUserFromGroupOptions = Parameters<typeof unassignUserFromGroup>[0];
type unassignUserFromGroupPathParam_groupId = (NonNullable<unassignUserFromGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type unassignUserFromGroupPathParam_username = (NonNullable<unassignUserFromGroupOptions> extends {
    path: {
        username: infer P;
    };
} ? P : any);
type unassignUserFromGroupInput = {
    groupId: unassignUserFromGroupPathParam_groupId;
    username: unassignUserFromGroupPathParam_username;
};
type unassignUserFromTenantOptions = Parameters<typeof unassignUserFromTenant>[0];
type unassignUserFromTenantPathParam_tenantId = (NonNullable<unassignUserFromTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type unassignUserFromTenantPathParam_username = (NonNullable<unassignUserFromTenantOptions> extends {
    path: {
        username: infer P;
    };
} ? P : any);
type unassignUserFromTenantInput = {
    tenantId: unassignUserFromTenantPathParam_tenantId;
    username: unassignUserFromTenantPathParam_username;
};
type unassignUserTaskOptions = Parameters<typeof unassignUserTask>[0];
type unassignUserTaskPathParam_userTaskKey = (NonNullable<unassignUserTaskOptions> extends {
    path: {
        userTaskKey: infer P;
    };
} ? P : any);
type unassignUserTaskInput = {
    userTaskKey: unassignUserTaskPathParam_userTaskKey;
};
type updateAuthorizationOptions = Parameters<typeof updateAuthorization>[0];
type updateAuthorizationBody = (NonNullable<updateAuthorizationOptions> extends {
    body?: infer B;
} ? B : never);
type updateAuthorizationPathParam_authorizationKey = (NonNullable<updateAuthorizationOptions> extends {
    path: {
        authorizationKey: infer P;
    };
} ? P : any);
type updateAuthorizationInput = updateAuthorizationBody & {
    authorizationKey: updateAuthorizationPathParam_authorizationKey;
};
type updateGroupOptions = Parameters<typeof updateGroup>[0];
type updateGroupBody = (NonNullable<updateGroupOptions> extends {
    body?: infer B;
} ? B : never);
type updateGroupPathParam_groupId = (NonNullable<updateGroupOptions> extends {
    path: {
        groupId: infer P;
    };
} ? P : any);
type updateGroupInput = updateGroupBody & {
    groupId: updateGroupPathParam_groupId;
};
type updateJobOptions = Parameters<typeof updateJob>[0];
type updateJobBody = (NonNullable<updateJobOptions> extends {
    body?: infer B;
} ? B : never);
type updateJobPathParam_jobKey = (NonNullable<updateJobOptions> extends {
    path: {
        jobKey: infer P;
    };
} ? P : any);
type updateJobInput = updateJobBody & {
    jobKey: updateJobPathParam_jobKey;
};
type updateMappingRuleOptions = Parameters<typeof updateMappingRule>[0];
type updateMappingRuleBody = (NonNullable<updateMappingRuleOptions> extends {
    body?: infer B;
} ? B : never);
type updateMappingRulePathParam_mappingRuleId = (NonNullable<updateMappingRuleOptions> extends {
    path: {
        mappingRuleId: infer P;
    };
} ? P : any);
type updateMappingRuleInput = updateMappingRuleBody & {
    mappingRuleId: updateMappingRulePathParam_mappingRuleId;
};
type updateRoleOptions = Parameters<typeof updateRole>[0];
type updateRoleBody = (NonNullable<updateRoleOptions> extends {
    body?: infer B;
} ? B : never);
type updateRolePathParam_roleId = (NonNullable<updateRoleOptions> extends {
    path: {
        roleId: infer P;
    };
} ? P : any);
type updateRoleInput = updateRoleBody & {
    roleId: updateRolePathParam_roleId;
};
type updateTenantOptions = Parameters<typeof updateTenant>[0];
type updateTenantBody = (NonNullable<updateTenantOptions> extends {
    body?: infer B;
} ? B : never);
type updateTenantPathParam_tenantId = (NonNullable<updateTenantOptions> extends {
    path: {
        tenantId: infer P;
    };
} ? P : any);
type updateTenantInput = updateTenantBody & {
    tenantId: updateTenantPathParam_tenantId;
};
type updateUserOptions = Parameters<typeof updateUser>[0];
type updateUserBody = (NonNullable<updateUserOptions> extends {
    body?: infer B;
} ? B : never);
type updateUserPathParam_username = (NonNullable<updateUserOptions> extends {
    path: {
        username: infer P;
    };
} ? P : any);
type updateUserInput = updateUserBody & {
    username: updateUserPathParam_username;
};
/** Management of eventual consistency **/
type updateUserConsistency = {
    /** Management of eventual consistency tolerance. Set waitUpToMs to 0 to ignore eventual consistency. pollInterval is 500ms by default. */
    consistency: ConsistencyOptions<_DataOf<typeof updateUser>>;
};
type updateUserTaskOptions = Parameters<typeof updateUserTask>[0];
type updateUserTaskBody = (NonNullable<updateUserTaskOptions> extends {
    body?: infer B;
} ? B : never);
type updateUserTaskPathParam_userTaskKey = (NonNullable<updateUserTaskOptions> extends {
    path: {
        userTaskKey: infer P;
    };
} ? P : any);
type updateUserTaskInput = updateUserTaskBody & {
    userTaskKey: updateUserTaskPathParam_userTaskKey;
};
/** Extended deployment result with typed buckets for direct access to deployed artifacts. */
interface ExtendedDeploymentResult extends _DataOf<typeof createDeployment> {
    processes: Array<NonNullable<_DataOf<typeof createDeployment>["deployments"][number]["processDefinition"]>>;
    decisions: Array<NonNullable<_DataOf<typeof createDeployment>["deployments"][number]["decisionDefinition"]>>;
    decisionRequirements: Array<NonNullable<_DataOf<typeof createDeployment>["deployments"][number]["decisionRequirements"]>>;
    forms: Array<NonNullable<_DataOf<typeof createDeployment>["deployments"][number]["form"]>>;
    resources: Array<NonNullable<_DataOf<typeof createDeployment>["deployments"][number]["resource"]>>;
}
interface CancelablePromise<T> extends Promise<T> {
    cancel(): void;
}
interface CamundaOptions {
    config?: EnvOverrides;
    fetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
    env?: Record<string, string | undefined>;
    log?: {
        level?: LogLevel;
        transport?: LogTransport;
    };
    telemetry?: {
        hooks?: TelemetryHooks;
        correlation?: boolean;
        mirrorToLog?: boolean;
    };
    throwOnError?: boolean;
    supportLogger?: SupportLogger;
}
declare function createCamundaClient(options?: CamundaOptions): CamundaClient;
declare class CamundaClient {
    private _client;
    private _config;
    private _auth;
    private _fetch?;
    private _validation;
    private _log;
    private _bp;
    /** Registered job workers created via createJobWorker (lifecycle managed by user). */
    private _workers;
    /** Support logger (Node-only; no-op in browser). */
    private _supportLogger;
    private readonly _errorMode;
    private _overrides;
    constructor(opts?: CamundaOptions);
    get config(): Readonly<CamundaConfig>;
    /**
     * Read-only snapshot of current hydrated configuration (do not mutate directly).
     * Use configure(...) to apply changes.
     */
    getConfig(): Readonly<CamundaConfig>;
    configure(next: CamundaOptions): void;
    getAuthHeaders(): Promise<Record<string, string>>;
    forceAuthRefresh(): Promise<string | undefined>;
    clearAuthCache(opts?: {
        disk?: boolean;
        memory?: boolean;
    }): void;
    onAuthHeaders(h: (headers: Record<string, string>) => Record<string, string> | Promise<Record<string, string>>): void;
    /** @internal ValidationManager is internal; tests may reach via (client as any)._validation */
    /** Access a scoped logger (internal & future user emission). */
    logger(scope?: string): Logger;
    /** Internal accessor (read-only) for eventual consistency error mode. */
    getErrorMode(): 'throw' | 'result';
    /** Internal accessor for support logger (no public API commitment yet). */
    _getSupportLogger(): SupportLogger;
    /**
     * Emit the standard support log preamble & redacted configuration to the current support logger.
     * Safe to call multiple times; subsequent calls are ignored (idempotent).
     * Useful when a custom supportLogger was injected and you still want the canonical header & config dump.
     */
    emitSupportLogPreamble(): void;
    withCorrelation<T>(id: string, fn: () => Promise<T> | T): Promise<T>;
    private _isVoidResponse;
    /** Internal invocation helper to apply global backpressure gating + retry + normalization */
    _invokeWithRetry<T>(op: () => Promise<T>, opts: {
        opId: string;
        exempt?: boolean;
        classify?: (e: any) => {
            retryable: boolean;
            reason: string;
        };
    }): Promise<T>;
    /** Shared evaluation for raw transport responses (throwOnError:false) */
    private _evaluateResponse;
    /** Public accessor for current backpressure adaptive limiter state (stable) */
    getBackpressureState(): {
        severity: BackpressureSeverity;
        consecutive: number;
        permitsMax: number | null;
        permitsCurrent: number;
        waiters: number;
    } | {
        severity: string;
        permitsMax: null;
        permitsCurrent: number;
        consecutive: number;
        waiters: number;
    };
    /** Return a read-only snapshot of currently registered job workers. */
    getWorkers(): any[];
    /** Stop all registered job workers (best-effort). */
    stopAllWorkers(): void;
    /**
     * Activate activities within an ad-hoc sub-process
     * Activates selected activities within an ad-hoc sub-process identified by element ID.
     * The provided element IDs must exist within the ad-hoc sub-process instance identified by the
     * provided adHocSubProcessInstanceKey.
     *
      *
     * @operationId activateAdHocSubProcessActivities
     * @tags Ad-hoc sub-process
     */
    activateAdHocSubProcessActivities(input: activateAdHocSubProcessActivitiesInput): CancelablePromise<_DataOf<typeof activateAdHocSubProcessActivities>>;
    /**
     * Activate jobs
     * Iterate through all known partitions and activate jobs up to the requested maximum.
     *
      *
     * @operationId activateJobs
     * @tags Job
     */
    activateJobs(input: activateJobsInput): CancelablePromise<{
        jobs: EnrichedActivatedJob[];
    }>;
    /**
     * Assign a client to a group
     * Assigns a client to a group, making it a member of the group.
     * Members of the group inherit the group authorizations, roles, and tenant assignments.
     *
      *
     * @operationId assignClientToGroup
     * @tags Group
     */
    assignClientToGroup(input: assignClientToGroupInput): CancelablePromise<_DataOf<typeof assignClientToGroup>>;
    /**
     * Assign a client to a tenant
     * Assign the client to the specified tenant.
     * The client can then access tenant data and perform authorized actions.
     *
      *
     * @operationId assignClientToTenant
     * @tags Tenant
     */
    assignClientToTenant(input: assignClientToTenantInput): CancelablePromise<_DataOf<typeof assignClientToTenant>>;
    /**
     * Assign a group to a tenant
     * Assigns a group to a specified tenant.
     * Group members (users, clients) can then access tenant data and perform authorized actions.
     *
      *
     * @operationId assignGroupToTenant
     * @tags Tenant
     */
    assignGroupToTenant(input: assignGroupToTenantInput): CancelablePromise<_DataOf<typeof assignGroupToTenant>>;
    /**
     * Assign a mapping rule to a group
     * Assigns a mapping rule to a group.
     *
      *
     * @operationId assignMappingRuleToGroup
     * @tags Group
     */
    assignMappingRuleToGroup(input: assignMappingRuleToGroupInput): CancelablePromise<_DataOf<typeof assignMappingRuleToGroup>>;
    /**
     * Assign a mapping rule to a tenant
     * Assign a single mapping rule to a specified tenant.
      *
     * @operationId assignMappingRuleToTenant
     * @tags Tenant
     */
    assignMappingRuleToTenant(input: assignMappingRuleToTenantInput): CancelablePromise<_DataOf<typeof assignMappingRuleToTenant>>;
    /**
     * Assign a role to a client
     * Assigns the specified role to the client.
     * The client will inherit the authorizations associated with this role.
     *
      *
     * @operationId assignRoleToClient
     * @tags Role
     */
    assignRoleToClient(input: assignRoleToClientInput): CancelablePromise<_DataOf<typeof assignRoleToClient>>;
    /**
     * Assign a role to a group
     * Assigns the specified role to the group.
     * Every member of the group (user or client) will inherit the authorizations associated with this role.
     *
      *
     * @operationId assignRoleToGroup
     * @tags Role
     */
    assignRoleToGroup(input: assignRoleToGroupInput): CancelablePromise<_DataOf<typeof assignRoleToGroup>>;
    /**
     * Assign a role to a mapping rule
     * Assigns a role to a mapping rule.
     *
      *
     * @operationId assignRoleToMappingRule
     * @tags Role
     */
    assignRoleToMappingRule(input: assignRoleToMappingRuleInput): CancelablePromise<_DataOf<typeof assignRoleToMappingRule>>;
    /**
     * Assign a role to a tenant
     * Assigns a role to a specified tenant.
     * Users, Clients or Groups, that have the role assigned, will get access to the tenant's data and can perform actions according to their authorizations.
     *
      *
     * @operationId assignRoleToTenant
     * @tags Tenant
     */
    assignRoleToTenant(input: assignRoleToTenantInput): CancelablePromise<_DataOf<typeof assignRoleToTenant>>;
    /**
     * Assign a role to a user
     * Assigns the specified role to the user.
     * The user will inherit the authorizations associated with this role.
     *
      *
     * @operationId assignRoleToUser
     * @tags Role
     */
    assignRoleToUser(input: assignRoleToUserInput): CancelablePromise<_DataOf<typeof assignRoleToUser>>;
    /**
     * Assign user task
     * Assigns a user task with the given key to the given assignee.
      *
     * @operationId assignUserTask
     * @tags User task
     */
    assignUserTask(input: assignUserTaskInput): CancelablePromise<_DataOf<typeof assignUserTask>>;
    /**
     * Assign a user to a group
     * Assigns a user to a group, making the user a member of the group.
     * Group members inherit the group authorizations, roles, and tenant assignments.
     *
      *
     * @operationId assignUserToGroup
     * @tags Group
     */
    assignUserToGroup(input: assignUserToGroupInput): CancelablePromise<_DataOf<typeof assignUserToGroup>>;
    /**
     * Assign a user to a tenant
     * Assign a single user to a specified tenant. The user can then access tenant data and perform authorized actions.
      *
     * @operationId assignUserToTenant
     * @tags Tenant
     */
    assignUserToTenant(input: assignUserToTenantInput): CancelablePromise<_DataOf<typeof assignUserToTenant>>;
    /**
     * Broadcast signal
     * Broadcasts a signal.
      *
     * @operationId broadcastSignal
     * @tags Signal
     */
    broadcastSignal(input: broadcastSignalInput): CancelablePromise<_DataOf<typeof broadcastSignal>>;
    /**
     * Cancel Batch operation
     * Cancels a running batch operation.
     * This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
     *
      *
     * @operationId cancelBatchOperation
     * @tags Batch operation
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    cancelBatchOperation(input: cancelBatchOperationInput, /** Management of eventual consistency **/ consistencyManagement: cancelBatchOperationConsistency): CancelablePromise<_DataOf<typeof cancelBatchOperation>>;
    /**
     * Cancel process instance
     * Cancels a running process instance. As a cancelation includes more than just the removal of the process instance resource, the cancelation resource must be posted.
      *
     * @operationId cancelProcessInstance
     * @tags Process instance
     */
    cancelProcessInstance(input: cancelProcessInstanceInput): CancelablePromise<_DataOf<typeof cancelProcessInstance>>;
    /**
     * Create a batch operation to cancel process instances
     * Cancels multiple running process instances.
     * Since only ACTIVE root instances can be cancelled, any given filters for state and
     * parentProcessInstanceKey are ignored and overridden during this batch operation.
     * This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
     *
      *
     * @operationId cancelProcessInstancesBatchOperation
     * @tags Process instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    cancelProcessInstancesBatchOperation(input: cancelProcessInstancesBatchOperationInput, /** Management of eventual consistency **/ consistencyManagement: cancelProcessInstancesBatchOperationConsistency): CancelablePromise<_DataOf<typeof cancelProcessInstancesBatchOperation>>;
    /**
     * Complete job
     * Complete a job with the given payload, which allows completing the associated service task.
     *
      *
     * @operationId completeJob
     * @tags Job
     */
    completeJob(input: completeJobInput): CancelablePromise<_DataOf<typeof completeJob>>;
    /**
     * Complete user task
     * Completes a user task with the given key.
      *
     * @operationId completeUserTask
     * @tags User task
     */
    completeUserTask(input: completeUserTaskInput): CancelablePromise<_DataOf<typeof completeUserTask>>;
    /**
     * Correlate message
     * Publishes a message and correlates it to a subscription.
     * If correlation is successful it will return the first process instance key the message correlated with.
     * The message is not buffered.
     * Use the publish message endpoint to send messages that can be buffered.
     *
      *
     * @operationId correlateMessage
     * @tags Message
     */
    correlateMessage(input: correlateMessageInput): CancelablePromise<_DataOf<typeof correlateMessage>>;
    /**
     * Create admin user
     * Creates a new user and assigns the admin role to it. This endpoint is only usable when users are managed in the Orchestration Cluster and while no user is assigned to the admin role.
      *
     * @operationId createAdminUser
     * @tags Setup
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    createAdminUser(input: createAdminUserInput, /** Management of eventual consistency **/ consistencyManagement: createAdminUserConsistency): CancelablePromise<_DataOf<typeof createAdminUser>>;
    /**
     * Create authorization
     * Create the authorization.
      *
     * @operationId createAuthorization
     * @tags Authorization
     */
    createAuthorization(input: createAuthorizationInput): CancelablePromise<_DataOf<typeof createAuthorization>>;
    /**
     * Deploy resources
     * Deploys one or more resources (e.g. processes, decision models, or forms).
     * This is an atomic call, i.e. either all resources are deployed or none of them are.
     *
      *
     * @operationId createDeployment
     * @tags Resource
     * @returns Enriched deployment result with typed arrays (processes, decisions, decisionRequirements, forms, resources).
     */
    createDeployment(input: createDeploymentInput): CancelablePromise<ExtendedDeploymentResult>;
    /**
     * Upload document
     * Upload a document to the Camunda 8 cluster.
     *
     * Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
     *
      *
     * @operationId createDocument
     * @tags Document
     */
    createDocument(input: createDocumentInput): CancelablePromise<_DataOf<typeof createDocument>>;
    /**
     * Create document link
     * Create a link to a document in the Camunda 8 cluster.
     *
     * Note that this is currently supported for document stores of type: AWS, GCP
     *
      *
     * @operationId createDocumentLink
     * @tags Document
     */
    createDocumentLink(input: createDocumentLinkInput): CancelablePromise<_DataOf<typeof createDocumentLink>>;
    /**
     * Upload multiple documents
     * Upload multiple documents to the Camunda 8 cluster.
     *
     * The caller must provide a file name for each document, which will be used in case of a multi-status response
     * to identify which documents failed to upload. The file name can be provided in the `Content-Disposition` header
     * of the file part or in the `fileName` field of the metadata. You can add a parallel array of metadata objects. These
     * are matched with the files based on index, and must have the same length as the files array.
     * To pass homogenous metadata for all files, spread the metadata over the metadata array.
     * A filename value provided explicitly via the metadata array in the request overrides the `Content-Disposition` header
     * of the file part.
     *
     * In case of a multi-status response, the response body will contain a list of `DocumentBatchProblemDetail` objects,
     * each of which contains the file name of the document that failed to upload and the reason for the failure.
     * The client can choose to retry the whole batch or individual documents based on the response.
     *
     * Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
     *
      *
     * @operationId createDocuments
     * @tags Document
     */
    createDocuments(input: createDocumentsInput): CancelablePromise<_DataOf<typeof createDocuments>>;
    /**
     * Update element instance variables
     * Updates all the variables of a particular scope (for example, process instance, element instance) with the given variable data.
     * Specify the element instance in the `elementInstanceKey` parameter.
     *
      *
     * @operationId createElementInstanceVariables
     * @tags Element instance
     */
    createElementInstanceVariables(input: createElementInstanceVariablesInput): CancelablePromise<_DataOf<typeof createElementInstanceVariables>>;
    /**
     * Create group
     * Create a new group.
     *
      *
     * @operationId createGroup
     * @tags Group
     */
    createGroup(input: createGroupInput): CancelablePromise<_DataOf<typeof createGroup>>;
    /**
     * Create mapping rule
     * Create a new mapping rule
     *
      *
     * @operationId createMappingRule
     * @tags Mapping rule
     */
    createMappingRule(input: createMappingRuleInput): CancelablePromise<_DataOf<typeof createMappingRule>>;
    /**
     * Create process instance
     * Creates and starts an instance of the specified process.
     * The process definition to use to create the instance can be specified either using its unique key
     * (as returned by Deploy resources), or using the BPMN process ID and a version.
     *
     * Waits for the completion of the process instance before returning a result
     * when awaitCompletion is enabled.
     *
      *
     * @operationId createProcessInstance
     * @tags Process instance
     */
    createProcessInstance(input: createProcessInstanceInput): CancelablePromise<_DataOf<typeof createProcessInstance>>;
    /**
     * Create role
     * Create a new role.
     *
      *
     * @operationId createRole
     * @tags Role
     */
    createRole(input: createRoleInput): CancelablePromise<_DataOf<typeof createRole>>;
    /**
     * Create tenant
     * Creates a new tenant.
      *
     * @operationId createTenant
     * @tags Tenant
     */
    createTenant(input: createTenantInput): CancelablePromise<_DataOf<typeof createTenant>>;
    /**
     * Create user
     * Create a new user.
      *
     * @operationId createUser
     * @tags User
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    createUser(input: createUserInput, /** Management of eventual consistency **/ consistencyManagement: createUserConsistency): CancelablePromise<_DataOf<typeof createUser>>;
    /**
     * Delete authorization
     * Deletes the authorization with the given key.
      *
     * @operationId deleteAuthorization
     * @tags Authorization
     */
    deleteAuthorization(input: deleteAuthorizationInput): CancelablePromise<_DataOf<typeof deleteAuthorization>>;
    /**
     * Delete document
     * Delete a document from the Camunda 8 cluster.
     *
     * Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
     *
      *
     * @operationId deleteDocument
     * @tags Document
     */
    deleteDocument(input: deleteDocumentInput): CancelablePromise<_DataOf<typeof deleteDocument>>;
    /**
     * Delete group
     * Deletes the group with the given ID.
     *
      *
     * @operationId deleteGroup
     * @tags Group
     */
    deleteGroup(input: deleteGroupInput): CancelablePromise<_DataOf<typeof deleteGroup>>;
    /**
     * Delete a mapping rule
     * Deletes the mapping rule with the given ID.
     *
      *
     * @operationId deleteMappingRule
     * @tags Mapping rule
     */
    deleteMappingRule(input: deleteMappingRuleInput): CancelablePromise<_DataOf<typeof deleteMappingRule>>;
    /**
     * Delete resource
     * Deletes a deployed resource.
     * This can be a process definition, decision requirements definition, or form definition
     * deployed using the deploy resources endpoint. Specify the resource you want to delete in the `resourceKey` parameter.
     *
      *
     * @operationId deleteResource
     * @tags Resource
     */
    deleteResource(input: deleteResourceInput): CancelablePromise<_DataOf<typeof deleteResource>>;
    /**
     * Delete role
     * Deletes the role with the given ID.
     *
      *
     * @operationId deleteRole
     * @tags Role
     */
    deleteRole(input: deleteRoleInput): CancelablePromise<_DataOf<typeof deleteRole>>;
    /**
     * Delete tenant
     * Deletes an existing tenant.
      *
     * @operationId deleteTenant
     * @tags Tenant
     */
    deleteTenant(input: deleteTenantInput): CancelablePromise<_DataOf<typeof deleteTenant>>;
    /**
     * Delete user
     * Deletes a user.
     *
      *
     * @operationId deleteUser
     * @tags User
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    deleteUser(input: deleteUserInput, /** Management of eventual consistency **/ consistencyManagement: deleteUserConsistency): CancelablePromise<_DataOf<typeof deleteUser>>;
    /**
     * Evaluate decision
     * Evaluates a decision.
     * You specify the decision to evaluate either by using its unique key (as returned by
     * DeployResource), or using the decision ID. When using the decision ID, the latest deployed
     * version of the decision is used.
     *
      *
     * @operationId evaluateDecision
     * @tags Decision definition
     */
    evaluateDecision(input: evaluateDecisionInput): CancelablePromise<_DataOf<typeof evaluateDecision>>;
    /**
     * Fail job
     * Mark the job as failed
     *
      *
     * @operationId failJob
     * @tags Job
     */
    failJob(input: failJobInput): CancelablePromise<_DataOf<typeof failJob>>;
    /**
     * Get current user
     * Retrieves the current authenticated user.
      *
     * @operationId getAuthentication
     * @tags Authentication
     */
    getAuthentication(): CancelablePromise<_DataOf<typeof getAuthentication>>;
    /**
     * Get authorization
     * Get authorization by the given key.
      *
     * @operationId getAuthorization
     * @tags Authorization
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getAuthorization(input: getAuthorizationInput, /** Management of eventual consistency **/ consistencyManagement: getAuthorizationConsistency): CancelablePromise<_DataOf<typeof getAuthorization>>;
    /**
     * Get batch operation
     * Get batch operation by key.
      *
     * @operationId getBatchOperation
     * @tags Batch operation
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getBatchOperation(input: getBatchOperationInput, /** Management of eventual consistency **/ consistencyManagement: getBatchOperationConsistency): CancelablePromise<_DataOf<typeof getBatchOperation>>;
    /**
     * Get decision definition
     * Returns a decision definition by key.
     *
      *
     * @operationId getDecisionDefinition
     * @tags Decision definition
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getDecisionDefinition(input: getDecisionDefinitionInput, /** Management of eventual consistency **/ consistencyManagement: getDecisionDefinitionConsistency): CancelablePromise<_DataOf<typeof getDecisionDefinition>>;
    /**
     * Get decision definition XML
     * Returns decision definition as XML.
     *
      *
     * @operationId getDecisionDefinitionXML
     * @tags Decision definition
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getDecisionDefinitionXml(input: getDecisionDefinitionXmlInput, /** Management of eventual consistency **/ consistencyManagement: getDecisionDefinitionXmlConsistency): CancelablePromise<_DataOf<typeof getDecisionDefinitionXml>>;
    /**
     * Get decision instance
     * Returns a decision instance.
     *
      *
     * @operationId getDecisionInstance
     * @tags Decision instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getDecisionInstance(input: getDecisionInstanceInput, /** Management of eventual consistency **/ consistencyManagement: getDecisionInstanceConsistency): CancelablePromise<_DataOf<typeof getDecisionInstance>>;
    /**
     * Get decision requirements
     * Returns Decision Requirements as JSON.
     *
      *
     * @operationId getDecisionRequirements
     * @tags Decision requirements
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getDecisionRequirements(input: getDecisionRequirementsInput, /** Management of eventual consistency **/ consistencyManagement: getDecisionRequirementsConsistency): CancelablePromise<_DataOf<typeof getDecisionRequirements>>;
    /**
     * Get decision requirements XML
     * Returns decision requirements as XML.
     *
      *
     * @operationId getDecisionRequirementsXML
     * @tags Decision requirements
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getDecisionRequirementsXml(input: getDecisionRequirementsXmlInput, /** Management of eventual consistency **/ consistencyManagement: getDecisionRequirementsXmlConsistency): CancelablePromise<_DataOf<typeof getDecisionRequirementsXml>>;
    /**
     * Download document
     * Download a document from the Camunda 8 cluster.
     *
     * Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
     *
      *
     * @operationId getDocument
     * @tags Document
     */
    getDocument(input: getDocumentInput): CancelablePromise<_DataOf<typeof getDocument>>;
    /**
     * Get element instance
     * Returns element instance as JSON.
     *
      *
     * @operationId getElementInstance
     * @tags Element instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getElementInstance(input: getElementInstanceInput, /** Management of eventual consistency **/ consistencyManagement: getElementInstanceConsistency): CancelablePromise<_DataOf<typeof getElementInstance>>;
    /**
     * Get group
     * Get a group by its ID.
     *
      *
     * @operationId getGroup
     * @tags Group
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getGroup(input: getGroupInput, /** Management of eventual consistency **/ consistencyManagement: getGroupConsistency): CancelablePromise<_DataOf<typeof getGroup>>;
    /**
     * Get incident
     * Returns incident as JSON.
     *
      *
     * @operationId getIncident
     * @tags Incident
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getIncident(input: getIncidentInput, /** Management of eventual consistency **/ consistencyManagement: getIncidentConsistency): CancelablePromise<_DataOf<typeof getIncident>>;
    /**
     * Get license status
     * Obtains the status of the current Camunda license.
      *
     * @operationId getLicense
     * @tags License
     */
    getLicense(): CancelablePromise<_DataOf<typeof getLicense>>;
    /**
     * Get a mapping rule
     * Gets the mapping rule with the given ID.
     *
      *
     * @operationId getMappingRule
     * @tags Mapping rule
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getMappingRule(input: getMappingRuleInput, /** Management of eventual consistency **/ consistencyManagement: getMappingRuleConsistency): CancelablePromise<_DataOf<typeof getMappingRule>>;
    /**
     * Get process definition
     * Returns process definition as JSON.
     *
      *
     * @operationId getProcessDefinition
     * @tags Process definition
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getProcessDefinition(input: getProcessDefinitionInput, /** Management of eventual consistency **/ consistencyManagement: getProcessDefinitionConsistency): CancelablePromise<_DataOf<typeof getProcessDefinition>>;
    /**
     * Get process definition statistics
     * Get statistics about elements in currently running process instances by process definition key and search filter.
     *
      *
     * @operationId getProcessDefinitionStatistics
     * @tags Process definition
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getProcessDefinitionStatistics(input: getProcessDefinitionStatisticsInput, /** Management of eventual consistency **/ consistencyManagement: getProcessDefinitionStatisticsConsistency): CancelablePromise<_DataOf<typeof getProcessDefinitionStatistics>>;
    /**
     * Get process definition XML
     * Returns process definition as XML.
     *
      *
     * @operationId getProcessDefinitionXML
     * @tags Process definition
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getProcessDefinitionXml(input: getProcessDefinitionXmlInput, /** Management of eventual consistency **/ consistencyManagement: getProcessDefinitionXmlConsistency): CancelablePromise<_DataOf<typeof getProcessDefinitionXml>>;
    /**
     * Get process instance
     * Get the process instance by the process instance key.
     *
      *
     * @operationId getProcessInstance
     * @tags Process instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getProcessInstance(input: getProcessInstanceInput, /** Management of eventual consistency **/ consistencyManagement: getProcessInstanceConsistency): CancelablePromise<_DataOf<typeof getProcessInstance>>;
    /**
     * Get call hierarchy for process instance
     * Returns the call hierarchy for a given process instance, showing its ancestry up to the root instance.
     *
      *
     * @operationId getProcessInstanceCallHierarchy
     * @tags Process instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getProcessInstanceCallHierarchy(input: getProcessInstanceCallHierarchyInput, /** Management of eventual consistency **/ consistencyManagement: getProcessInstanceCallHierarchyConsistency): CancelablePromise<_DataOf<typeof getProcessInstanceCallHierarchy>>;
    /**
     * Get process instance sequence flows
     * Get sequence flows taken by the process instance.
     *
      *
     * @operationId getProcessInstanceSequenceFlows
     * @tags Process instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getProcessInstanceSequenceFlows(input: getProcessInstanceSequenceFlowsInput, /** Management of eventual consistency **/ consistencyManagement: getProcessInstanceSequenceFlowsConsistency): CancelablePromise<_DataOf<typeof getProcessInstanceSequenceFlows>>;
    /**
     * Get process instance statistics
     * Get statistics about elements by the process instance key.
     *
      *
     * @operationId getProcessInstanceStatistics
     * @tags Process instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getProcessInstanceStatistics(input: getProcessInstanceStatisticsInput, /** Management of eventual consistency **/ consistencyManagement: getProcessInstanceStatisticsConsistency): CancelablePromise<_DataOf<typeof getProcessInstanceStatistics>>;
    /**
     * Get resource
     * Returns a deployed resource.
     * :::info
     * Currently, this endpoint only supports RPA resources.
     * :::
     *
      *
     * @operationId getResource
     * @tags Resource
     */
    getResource(input: getResourceInput): CancelablePromise<_DataOf<typeof getResource>>;
    /**
     * Get resource content
     * Returns the content of a deployed resource.
     * :::info
     * Currently, this endpoint only supports RPA resources.
     * :::
     *
      *
     * @operationId getResourceContent
     * @tags Resource
     */
    getResourceContent(input: getResourceContentInput): CancelablePromise<_DataOf<typeof getResourceContent>>;
    /**
     * Get role
     * Get a role by its ID.
     *
      *
     * @operationId getRole
     * @tags Role
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getRole(input: getRoleInput, /** Management of eventual consistency **/ consistencyManagement: getRoleConsistency): CancelablePromise<_DataOf<typeof getRole>>;
    /**
     * Get process start form
     * Get the start form of a process.
     *
     * Note that this endpoint will only return linked forms. This endpoint does not support embedded forms.
     *
      *
     * @operationId getStartProcessForm
     * @tags Process definition
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getStartProcessForm(input: getStartProcessFormInput, /** Management of eventual consistency **/ consistencyManagement: getStartProcessFormConsistency): CancelablePromise<_DataOf<typeof getStartProcessForm>>;
    /**
     * Get cluster status
     * Checks the health status of the cluster by verifying if there's at least one partition with a healthy leader.
      *
     * @operationId getStatus
     * @tags Cluster
     */
    getStatus(): CancelablePromise<_DataOf<typeof getStatus>>;
    /**
     * Get tenant
     * Retrieves a single tenant by tenant ID.
      *
     * @operationId getTenant
     * @tags Tenant
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getTenant(input: getTenantInput, /** Management of eventual consistency **/ consistencyManagement: getTenantConsistency): CancelablePromise<_DataOf<typeof getTenant>>;
    /**
     * Get cluster topology
     * Obtains the current topology of the cluster the gateway is part of.
      *
     * @operationId getTopology
     * @tags Cluster
     */
    getTopology(): CancelablePromise<_DataOf<typeof getTopology>>;
    /**
     * Get usage metrics
     * Retrieve the usage metrics based on given criteria.
      *
     * @operationId getUsageMetrics
     * @tags System
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getUsageMetrics(input: getUsageMetricsInput, /** Management of eventual consistency **/ consistencyManagement: getUsageMetricsConsistency): CancelablePromise<_DataOf<typeof getUsageMetrics>>;
    /**
     * Get user
     * Get a user by its username.
     *
      *
     * @operationId getUser
     * @tags User
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getUser(input: getUserInput, /** Management of eventual consistency **/ consistencyManagement: getUserConsistency): CancelablePromise<_DataOf<typeof getUser>>;
    /**
     * Get user task
     * Get the user task by the user task key.
     *
      *
     * @operationId getUserTask
     * @tags User task
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getUserTask(input: getUserTaskInput, /** Management of eventual consistency **/ consistencyManagement: getUserTaskConsistency): CancelablePromise<_DataOf<typeof getUserTask>>;
    /**
     * Get user task form
     * Get the form of a user task.
     *
     * Note that this endpoint will only return linked forms. This endpoint does not support embedded forms.
     *
      *
     * @operationId getUserTaskForm
     * @tags User task
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getUserTaskForm(input: getUserTaskFormInput, /** Management of eventual consistency **/ consistencyManagement: getUserTaskFormConsistency): CancelablePromise<_DataOf<typeof getUserTaskForm>>;
    /**
     * Get variable
     * Get the variable by the variable key.
     *
      *
     * @operationId getVariable
     * @tags Variable
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    getVariable(input: getVariableInput, /** Management of eventual consistency **/ consistencyManagement: getVariableConsistency): CancelablePromise<_DataOf<typeof getVariable>>;
    /**
     * Migrate process instance
     * Migrates a process instance to a new process definition.
     * This request can contain multiple mapping instructions to define mapping between the active
     * process instance's elements and target process definition elements.
     *
     * Use this to upgrade a process instance to a new version of a process or to
     * a different process definition, e.g. to keep your running instances up-to-date with the
     * latest process improvements.
     *
      *
     * @operationId migrateProcessInstance
     * @tags Process instance
     */
    migrateProcessInstance(input: migrateProcessInstanceInput): CancelablePromise<_DataOf<typeof migrateProcessInstance>>;
    /**
     * Create a batch operation to migrate process instances
     * Migrate multiple instances of process instances.
     * Since only process instances with ACTIVE state can be migrated, any given
     * filters for state are ignored and overridden during this batch operation.
     * This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
     *
      *
     * @operationId migrateProcessInstancesBatchOperation
     * @tags Process instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    migrateProcessInstancesBatchOperation(input: migrateProcessInstancesBatchOperationInput, /** Management of eventual consistency **/ consistencyManagement: migrateProcessInstancesBatchOperationConsistency): CancelablePromise<_DataOf<typeof migrateProcessInstancesBatchOperation>>;
    /**
     * Modify process instance
     * Modifies a running process instance.
     * This request can contain multiple instructions to activate an element of the process or
     * to terminate an active instance of an element.
     *
     * Use this to repair a process instance that is stuck on an element or took an unintended path.
     * For example, because an external system is not available or doesn't respond as expected.
     *
      *
     * @operationId modifyProcessInstance
     * @tags Process instance
     */
    modifyProcessInstance(input: modifyProcessInstanceInput): CancelablePromise<_DataOf<typeof modifyProcessInstance>>;
    /**
     * Create a batch operation to modify process instances
     * Modify multiple process instances.
     * Since only process instances with ACTIVE state can be modified, any given
     * filters for state are ignored and overridden during this batch operation.
     * In contrast to single modification operation, it is not possible to add variable instructions or modify by element key.
     * It is only possible to use the element id of the source and target.
     * This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
     *
      *
     * @operationId modifyProcessInstancesBatchOperation
     * @tags Process instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    modifyProcessInstancesBatchOperation(input: modifyProcessInstancesBatchOperationInput, /** Management of eventual consistency **/ consistencyManagement: modifyProcessInstancesBatchOperationConsistency): CancelablePromise<_DataOf<typeof modifyProcessInstancesBatchOperation>>;
    /**
     * Pin internal clock (alpha)
     * Set a precise, static time for the Zeebe engines internal clock.
     * When the clock is pinned, it remains at the specified time and does not advance.
     * To change the time, the clock must be pinned again with a new timestamp.
     *
     * This endpoint is an alpha feature and may be subject to change
     * in future releases.
     *
      *
     * @operationId pinClock
     * @tags Clock
     */
    pinClock(input: pinClockInput): CancelablePromise<_DataOf<typeof pinClock>>;
    /**
     * Publish message
     * Publishes a single message.
     * Messages are published to specific partitions computed from their correlation keys.
     * Messages can be buffered.
     * The endpoint does not wait for a correlation result.
     * Use the message correlation endpoint for such use cases.
     *
      *
     * @operationId publishMessage
     * @tags Message
     */
    publishMessage(input: publishMessageInput): CancelablePromise<_DataOf<typeof publishMessage>>;
    /**
     * Reset internal clock (alpha)
     * Resets the Zeebe engines internal clock to the current system time, enabling it to tick in real-time.
     * This operation is useful for returning the clock to
     * normal behavior after it has been pinned to a specific time.
     *
     * This endpoint is an alpha feature and may be subject to change
     * in future releases.
     *
      *
     * @operationId resetClock
     * @tags Clock
     */
    resetClock(): CancelablePromise<_DataOf<typeof resetClock>>;
    /**
     * Resolve incident
     * Marks the incident as resolved; most likely a call to Update job will be necessary to reset the jobs retries, followed by this call.
     *
      *
     * @operationId resolveIncident
     * @tags Incident
     */
    resolveIncident(input: resolveIncidentInput): CancelablePromise<_DataOf<typeof resolveIncident>>;
    /**
     * Create a batch operation to resolve incidents of process instances
     * Resolves multiple instances of process instances.
     * Since only process instances with ACTIVE state can have unresolved incidents, any given
     * filters for state are ignored and overridden during this batch operation.
     * This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
     *
      *
     * @operationId resolveIncidentsBatchOperation
     * @tags Process instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    resolveIncidentsBatchOperation(input: resolveIncidentsBatchOperationInput, /** Management of eventual consistency **/ consistencyManagement: resolveIncidentsBatchOperationConsistency): CancelablePromise<_DataOf<typeof resolveIncidentsBatchOperation>>;
    /**
     * Resume Batch operation
     * Resumes a suspended batch operation.
     * This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
     *
      *
     * @operationId resumeBatchOperation
     * @tags Batch operation
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    resumeBatchOperation(input: resumeBatchOperationInput, /** Management of eventual consistency **/ consistencyManagement: resumeBatchOperationConsistency): CancelablePromise<_DataOf<typeof resumeBatchOperation>>;
    /**
     * Search authorizations
     * Search for authorizations based on given criteria.
     *
      *
     * @operationId searchAuthorizations
     * @tags Authorization
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchAuthorizations(input: searchAuthorizationsInput, /** Management of eventual consistency **/ consistencyManagement: searchAuthorizationsConsistency): CancelablePromise<_DataOf<typeof searchAuthorizations>>;
    /**
     * Search batch operation items
     * Search for batch operation items based on given criteria.
      *
     * @operationId searchBatchOperationItems
     * @tags Batch operation
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchBatchOperationItems(input: searchBatchOperationItemsInput, /** Management of eventual consistency **/ consistencyManagement: searchBatchOperationItemsConsistency): CancelablePromise<_DataOf<typeof searchBatchOperationItems>>;
    /**
     * Search batch operations
     * Search for batch operations based on given criteria.
      *
     * @operationId searchBatchOperations
     * @tags Batch operation
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchBatchOperations(input: searchBatchOperationsInput, /** Management of eventual consistency **/ consistencyManagement: searchBatchOperationsConsistency): CancelablePromise<_DataOf<typeof searchBatchOperations>>;
    /**
     * Search group clients
     * Search clients assigned to a group.
     *
      *
     * @operationId searchClientsForGroup
     * @tags Group
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchClientsForGroup(input: searchClientsForGroupInput, /** Management of eventual consistency **/ consistencyManagement: searchClientsForGroupConsistency): CancelablePromise<_DataOf<typeof searchClientsForGroup>>;
    /**
     * Search role clients
     * Search clients with assigned role.
     *
      *
     * @operationId searchClientsForRole
     * @tags Role
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchClientsForRole(input: searchClientsForRoleInput, /** Management of eventual consistency **/ consistencyManagement: searchClientsForRoleConsistency): CancelablePromise<_DataOf<typeof searchClientsForRole>>;
    /**
     * Search clients for tenant
     * Retrieves a filtered and sorted list of clients for a specified tenant.
      *
     * @operationId searchClientsForTenant
     * @tags Tenant
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchClientsForTenant(input: searchClientsForTenantInput, /** Management of eventual consistency **/ consistencyManagement: searchClientsForTenantConsistency): CancelablePromise<_DataOf<typeof searchClientsForTenant>>;
    /**
     * Search correlated message subscriptions
     * Search correlated message subscriptions based on given criteria.
      *
     * @operationId searchCorrelatedMessageSubscriptions
     * @tags Message subscription
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchCorrelatedMessageSubscriptions(input: searchCorrelatedMessageSubscriptionsInput, /** Management of eventual consistency **/ consistencyManagement: searchCorrelatedMessageSubscriptionsConsistency): CancelablePromise<_DataOf<typeof searchCorrelatedMessageSubscriptions>>;
    /**
     * Search decision definitions
     * Search for decision definitions based on given criteria.
     *
      *
     * @operationId searchDecisionDefinitions
     * @tags Decision definition
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchDecisionDefinitions(input: searchDecisionDefinitionsInput, /** Management of eventual consistency **/ consistencyManagement: searchDecisionDefinitionsConsistency): CancelablePromise<_DataOf<typeof searchDecisionDefinitions>>;
    /**
     * Search decision instances
     * Search for decision instances based on given criteria.
     *
      *
     * @operationId searchDecisionInstances
     * @tags Decision instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchDecisionInstances(input: searchDecisionInstancesInput, /** Management of eventual consistency **/ consistencyManagement: searchDecisionInstancesConsistency): CancelablePromise<_DataOf<typeof searchDecisionInstances>>;
    /**
     * Search decision requirements
     * Search for decision requirements based on given criteria.
     *
      *
     * @operationId searchDecisionRequirements
     * @tags Decision requirements
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchDecisionRequirements(input: searchDecisionRequirementsInput, /** Management of eventual consistency **/ consistencyManagement: searchDecisionRequirementsConsistency): CancelablePromise<_DataOf<typeof searchDecisionRequirements>>;
    /**
     * Search element instances
     * Search for element instances based on given criteria.
     *
      *
     * @operationId searchElementInstances
     * @tags Element instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchElementInstances(input: searchElementInstancesInput, /** Management of eventual consistency **/ consistencyManagement: searchElementInstancesConsistency): CancelablePromise<_DataOf<typeof searchElementInstances>>;
    /**
     * Search groups for tenant
     * Retrieves a filtered and sorted list of groups for a specified tenant.
      *
     * @operationId searchGroupIdsForTenant
     * @tags Tenant
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchGroupIdsForTenant(input: searchGroupIdsForTenantInput, /** Management of eventual consistency **/ consistencyManagement: searchGroupIdsForTenantConsistency): CancelablePromise<_DataOf<typeof searchGroupIdsForTenant>>;
    /**
     * Search groups
     * Search for groups based on given criteria.
     *
      *
     * @operationId searchGroups
     * @tags Group
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchGroups(input: searchGroupsInput, /** Management of eventual consistency **/ consistencyManagement: searchGroupsConsistency): CancelablePromise<_DataOf<typeof searchGroups>>;
    /**
     * Search role groups
     * Search groups with assigned role.
     *
      *
     * @operationId searchGroupsForRole
     * @tags Role
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchGroupsForRole(input: searchGroupsForRoleInput, /** Management of eventual consistency **/ consistencyManagement: searchGroupsForRoleConsistency): CancelablePromise<_DataOf<typeof searchGroupsForRole>>;
    /**
     * Search incidents
     * Search for incidents based on given criteria.
     *
      *
     * @operationId searchIncidents
     * @tags Incident
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchIncidents(input: searchIncidentsInput, /** Management of eventual consistency **/ consistencyManagement: searchIncidentsConsistency): CancelablePromise<_DataOf<typeof searchIncidents>>;
    /**
     * Search jobs
     * Search for jobs based on given criteria.
      *
     * @operationId searchJobs
     * @tags Job
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchJobs(input: searchJobsInput, /** Management of eventual consistency **/ consistencyManagement: searchJobsConsistency): CancelablePromise<_DataOf<typeof searchJobs>>;
    /**
     * Search mapping rules
     * Search for mapping rules based on given criteria.
     *
      *
     * @operationId searchMappingRule
     * @tags Mapping rule
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchMappingRule(input: searchMappingRuleInput, /** Management of eventual consistency **/ consistencyManagement: searchMappingRuleConsistency): CancelablePromise<_DataOf<typeof searchMappingRule>>;
    /**
     * Search group mapping rules
     * Search mapping rules assigned to a group.
     *
      *
     * @operationId searchMappingRulesForGroup
     * @tags Group
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchMappingRulesForGroup(input: searchMappingRulesForGroupInput, /** Management of eventual consistency **/ consistencyManagement: searchMappingRulesForGroupConsistency): CancelablePromise<_DataOf<typeof searchMappingRulesForGroup>>;
    /**
     * Search role mapping rules
     * Search mapping rules with assigned role.
     *
      *
     * @operationId searchMappingRulesForRole
     * @tags Role
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchMappingRulesForRole(input: searchMappingRulesForRoleInput, /** Management of eventual consistency **/ consistencyManagement: searchMappingRulesForRoleConsistency): CancelablePromise<_DataOf<typeof searchMappingRulesForRole>>;
    /**
     * Search mapping rules for tenant
     * Retrieves a filtered and sorted list of MappingRules for a specified tenant.
      *
     * @operationId searchMappingRulesForTenant
     * @tags Tenant
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchMappingRulesForTenant(input: searchMappingRulesForTenantInput, /** Management of eventual consistency **/ consistencyManagement: searchMappingRulesForTenantConsistency): CancelablePromise<_DataOf<typeof searchMappingRulesForTenant>>;
    /**
     * Search message subscriptions
     * Search for message subscriptions based on given criteria.
     *
      *
     * @operationId searchMessageSubscriptions
     * @tags Message subscription
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchMessageSubscriptions(input: searchMessageSubscriptionsInput, /** Management of eventual consistency **/ consistencyManagement: searchMessageSubscriptionsConsistency): CancelablePromise<_DataOf<typeof searchMessageSubscriptions>>;
    /**
     * Search process definitions
     * Search for process definitions based on given criteria.
     *
      *
     * @operationId searchProcessDefinitions
     * @tags Process definition
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchProcessDefinitions(input: searchProcessDefinitionsInput, /** Management of eventual consistency **/ consistencyManagement: searchProcessDefinitionsConsistency): CancelablePromise<_DataOf<typeof searchProcessDefinitions>>;
    /**
     * Search for incidents associated with a process instance
     * Search for incidents caused by the process instance or any of its called process or decision instances.
     *
      *
     * @operationId searchProcessInstanceIncidents
     * @tags Process instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchProcessInstanceIncidents(input: searchProcessInstanceIncidentsInput, /** Management of eventual consistency **/ consistencyManagement: searchProcessInstanceIncidentsConsistency): CancelablePromise<_DataOf<typeof searchProcessInstanceIncidents>>;
    /**
     * Search process instances
     * Search for process instances based on given criteria.
     *
      *
     * @operationId searchProcessInstances
     * @tags Process instance
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchProcessInstances(input: searchProcessInstancesInput, /** Management of eventual consistency **/ consistencyManagement: searchProcessInstancesConsistency): CancelablePromise<_DataOf<typeof searchProcessInstances>>;
    /**
     * Search roles
     * Search for roles based on given criteria.
     *
      *
     * @operationId searchRoles
     * @tags Role
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchRoles(input: searchRolesInput, /** Management of eventual consistency **/ consistencyManagement: searchRolesConsistency): CancelablePromise<_DataOf<typeof searchRoles>>;
    /**
     * Search group roles
     * Search roles assigned to a group.
     *
      *
     * @operationId searchRolesForGroup
     * @tags Group
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchRolesForGroup(input: searchRolesForGroupInput, /** Management of eventual consistency **/ consistencyManagement: searchRolesForGroupConsistency): CancelablePromise<_DataOf<typeof searchRolesForGroup>>;
    /**
     * Search roles for tenant
     * Retrieves a filtered and sorted list of roles for a specified tenant.
      *
     * @operationId searchRolesForTenant
     * @tags Tenant
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchRolesForTenant(input: searchRolesForTenantInput, /** Management of eventual consistency **/ consistencyManagement: searchRolesForTenantConsistency): CancelablePromise<_DataOf<typeof searchRolesForTenant>>;
    /**
     * Search tenants
     * Retrieves a filtered and sorted list of tenants.
      *
     * @operationId searchTenants
     * @tags Tenant
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchTenants(input: searchTenantsInput, /** Management of eventual consistency **/ consistencyManagement: searchTenantsConsistency): CancelablePromise<_DataOf<typeof searchTenants>>;
    /**
     * Search users
     * Search for users based on given criteria.
     *
      *
     * @operationId searchUsers
     * @tags User
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchUsers(input: searchUsersInput, /** Management of eventual consistency **/ consistencyManagement: searchUsersConsistency): CancelablePromise<_DataOf<typeof searchUsers>>;
    /**
     * Search group users
     * Search users assigned to a group.
     *
      *
     * @operationId searchUsersForGroup
     * @tags Group
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchUsersForGroup(input: searchUsersForGroupInput, /** Management of eventual consistency **/ consistencyManagement: searchUsersForGroupConsistency): CancelablePromise<_DataOf<typeof searchUsersForGroup>>;
    /**
     * Search role users
     * Search users with assigned role.
     *
      *
     * @operationId searchUsersForRole
     * @tags Role
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchUsersForRole(input: searchUsersForRoleInput, /** Management of eventual consistency **/ consistencyManagement: searchUsersForRoleConsistency): CancelablePromise<_DataOf<typeof searchUsersForRole>>;
    /**
     * Search users for tenant
     * Retrieves a filtered and sorted list of users for a specified tenant.
      *
     * @operationId searchUsersForTenant
     * @tags Tenant
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchUsersForTenant(input: searchUsersForTenantInput, /** Management of eventual consistency **/ consistencyManagement: searchUsersForTenantConsistency): CancelablePromise<_DataOf<typeof searchUsersForTenant>>;
    /**
     * Search user tasks
     * Search for user tasks based on given criteria.
     *
      *
     * @operationId searchUserTasks
     * @tags User task
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchUserTasks(input: searchUserTasksInput, /** Management of eventual consistency **/ consistencyManagement: searchUserTasksConsistency): CancelablePromise<_DataOf<typeof searchUserTasks>>;
    /**
     * Search user task variables
     * Search for user task variables based on given criteria.
     *
      *
     * @operationId searchUserTaskVariables
     * @tags User task
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchUserTaskVariables(input: searchUserTaskVariablesInput, /** Management of eventual consistency **/ consistencyManagement: searchUserTaskVariablesConsistency): CancelablePromise<_DataOf<typeof searchUserTaskVariables>>;
    /**
     * Search variables
     * Search for process and local variables based on given criteria.
     *
      *
     * @operationId searchVariables
     * @tags Variable
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    searchVariables(input: searchVariablesInput, /** Management of eventual consistency **/ consistencyManagement: searchVariablesConsistency): CancelablePromise<_DataOf<typeof searchVariables>>;
    /**
     * Suspend Batch operation
     * Suspends a running batch operation.
     * This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
     *
      *
     * @operationId suspendBatchOperation
     * @tags Batch operation
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    suspendBatchOperation(input: suspendBatchOperationInput, /** Management of eventual consistency **/ consistencyManagement: suspendBatchOperationConsistency): CancelablePromise<_DataOf<typeof suspendBatchOperation>>;
    /**
     * Throw error for job
     * Reports a business error (i.e. non-technical) that occurs while processing a job.
     *
      *
     * @operationId throwJobError
     * @tags Job
     */
    throwJobError(input: throwJobErrorInput): CancelablePromise<_DataOf<typeof throwJobError>>;
    /**
     * Unassign a client from a group
     * Unassigns a client from a group.
     * The client is removed as a group member, with associated authorizations, roles, and tenant assignments no longer applied.
     *
      *
     * @operationId unassignClientFromGroup
     * @tags Group
     */
    unassignClientFromGroup(input: unassignClientFromGroupInput): CancelablePromise<_DataOf<typeof unassignClientFromGroup>>;
    /**
     * Unassign a client from a tenant
     * Unassigns the client from the specified tenant.
     * The client can no longer access tenant data.
     *
      *
     * @operationId unassignClientFromTenant
     * @tags Tenant
     */
    unassignClientFromTenant(input: unassignClientFromTenantInput): CancelablePromise<_DataOf<typeof unassignClientFromTenant>>;
    /**
     * Unassign a group from a tenant
     * Unassigns a group from a specified tenant.
     * Members of the group (users, clients) will no longer have access to the tenant's data - except they are assigned directly to the tenant.
     *
      *
     * @operationId unassignGroupFromTenant
     * @tags Tenant
     */
    unassignGroupFromTenant(input: unassignGroupFromTenantInput): CancelablePromise<_DataOf<typeof unassignGroupFromTenant>>;
    /**
     * Unassign a mapping rule from a group
     * Unassigns a mapping rule from a group.
     *
      *
     * @operationId unassignMappingRuleFromGroup
     * @tags Group
     */
    unassignMappingRuleFromGroup(input: unassignMappingRuleFromGroupInput): CancelablePromise<_DataOf<typeof unassignMappingRuleFromGroup>>;
    /**
     * Unassign a mapping rule from a tenant
     * Unassigns a single mapping rule from a specified tenant without deleting the rule.
      *
     * @operationId unassignMappingRuleFromTenant
     * @tags Tenant
     */
    unassignMappingRuleFromTenant(input: unassignMappingRuleFromTenantInput): CancelablePromise<_DataOf<typeof unassignMappingRuleFromTenant>>;
    /**
     * Unassign a role from a client
     * Unassigns the specified role from the client.
     * The client will no longer inherit the authorizations associated with this role.
     *
      *
     * @operationId unassignRoleFromClient
     * @tags Role
     */
    unassignRoleFromClient(input: unassignRoleFromClientInput): CancelablePromise<_DataOf<typeof unassignRoleFromClient>>;
    /**
     * Unassign a role from a group
     * Unassigns the specified role from the group.
     * All group members (user or client) no longer inherit the authorizations associated with this role.
     *
      *
     * @operationId unassignRoleFromGroup
     * @tags Role
     */
    unassignRoleFromGroup(input: unassignRoleFromGroupInput): CancelablePromise<_DataOf<typeof unassignRoleFromGroup>>;
    /**
     * Unassign a role from a mapping rule
     * Unassigns a role from a mapping rule.
     *
      *
     * @operationId unassignRoleFromMappingRule
     * @tags Role
     */
    unassignRoleFromMappingRule(input: unassignRoleFromMappingRuleInput): CancelablePromise<_DataOf<typeof unassignRoleFromMappingRule>>;
    /**
     * Unassign a role from a tenant
     * Unassigns a role from a specified tenant.
     * Users, Clients or Groups, that have the role assigned, will no longer have access to the
     * tenant's data - unless they are assigned directly to the tenant.
     *
      *
     * @operationId unassignRoleFromTenant
     * @tags Tenant
     */
    unassignRoleFromTenant(input: unassignRoleFromTenantInput): CancelablePromise<_DataOf<typeof unassignRoleFromTenant>>;
    /**
     * Unassign a role from a user
     * Unassigns a role from a user.
     * The user will no longer inherit the authorizations associated with this role.
     *
      *
     * @operationId unassignRoleFromUser
     * @tags Role
     */
    unassignRoleFromUser(input: unassignRoleFromUserInput): CancelablePromise<_DataOf<typeof unassignRoleFromUser>>;
    /**
     * Unassign a user from a group
     * Unassigns a user from a group.
     * The user is removed as a group member, with associated authorizations, roles, and tenant assignments no longer applied.
     *
      *
     * @operationId unassignUserFromGroup
     * @tags Group
     */
    unassignUserFromGroup(input: unassignUserFromGroupInput): CancelablePromise<_DataOf<typeof unassignUserFromGroup>>;
    /**
     * Unassign a user from a tenant
     * Unassigns the user from the specified tenant.
     * The user can no longer access tenant data.
     *
      *
     * @operationId unassignUserFromTenant
     * @tags Tenant
     */
    unassignUserFromTenant(input: unassignUserFromTenantInput): CancelablePromise<_DataOf<typeof unassignUserFromTenant>>;
    /**
     * Unassign user task
     * Removes the assignee of a task with the given key.
      *
     * @operationId unassignUserTask
     * @tags User task
     */
    unassignUserTask(input: unassignUserTaskInput): CancelablePromise<_DataOf<typeof unassignUserTask>>;
    /**
     * Update authorization
     * Update the authorization with the given key.
      *
     * @operationId updateAuthorization
     * @tags Authorization
     */
    updateAuthorization(input: updateAuthorizationInput): CancelablePromise<_DataOf<typeof updateAuthorization>>;
    /**
     * Update group
     * Update a group with the given ID.
     *
      *
     * @operationId updateGroup
     * @tags Group
     */
    updateGroup(input: updateGroupInput): CancelablePromise<_DataOf<typeof updateGroup>>;
    /**
     * Update job
     * Update a job with the given key.
      *
     * @operationId updateJob
     * @tags Job
     */
    updateJob(input: updateJobInput): CancelablePromise<_DataOf<typeof updateJob>>;
    /**
     * Update mapping rule
     * Update a mapping rule.
     *
      *
     * @operationId updateMappingRule
     * @tags Mapping rule
     */
    updateMappingRule(input: updateMappingRuleInput): CancelablePromise<_DataOf<typeof updateMappingRule>>;
    /**
     * Update role
     * Update a role with the given ID.
     *
      *
     * @operationId updateRole
     * @tags Role
     */
    updateRole(input: updateRoleInput): CancelablePromise<_DataOf<typeof updateRole>>;
    /**
     * Update tenant
     * Updates an existing tenant.
      *
     * @operationId updateTenant
     * @tags Tenant
     */
    updateTenant(input: updateTenantInput): CancelablePromise<_DataOf<typeof updateTenant>>;
    /**
     * Update user
     * Updates a user.
     *
      *
     * @operationId updateUser
     * @tags User
     * @consistency eventual - this endpoint is backed by data that is eventually consistent with the system state.
     */
    updateUser(input: updateUserInput, /** Management of eventual consistency **/ consistencyManagement: updateUserConsistency): CancelablePromise<_DataOf<typeof updateUser>>;
    /**
     * Update user task
     * Update a user task with the given key.
      *
     * @operationId updateUserTask
     * @tags User task
     */
    updateUserTask(input: updateUserTaskInput): CancelablePromise<_DataOf<typeof updateUserTask>>;
    /**
     * Create a job worker that activates and processes jobs of the given type.
     * @param cfg Worker configuration
     */
    createJobWorker<In extends zod.ZodTypeAny = any, Out extends zod.ZodTypeAny = any, Headers extends zod.ZodTypeAny = any>(cfg: JobWorkerConfig<In, Out, Headers>): JobWorker;
    /**
     * Node-only convenience: deploy resources from local filesystem paths.
     * @param resourceFilenames Absolute or relative file paths to BPMN/DMN/form/resource files.
     * @param options Optional: tenantId.
     * @returns ExtendedDeploymentResult
     */
    deployResourcesFromFiles(resourceFilenames: string[], options?: {
        tenantId?: string;
    }): CancelablePromise<ExtendedDeploymentResult>;
}

declare class CamundaValidationError extends Error {
    side: 'request' | 'response';
    operationId?: string;
    summary: string;
    issues: string[];
    constructor(params: {
        side: 'request' | 'response';
        operationId?: string;
        message: string;
        summary: string;
        issues: string[];
    });
}
declare class EventualConsistencyTimeoutError extends Error {
    code: string;
    attempts: number;
    elapsedMs: number;
    lastStatus?: number;
    lastResponseSnippet?: string;
    operationId?: string;
    constructor(params: {
        attempts: number;
        elapsedMs: number;
        lastStatus?: number;
        lastResponse?: any;
        operationId?: string;
        message?: string;
    });
}

type Left<E> = {
    _tag: 'Left';
    left: E;
};
type Right<A> = {
    _tag: 'Right';
    right: A;
};
type Either<E, A> = Left<E> | Right<A>;
type TaskEither<E, A> = () => Promise<Either<E, A>>;
declare const isLeft: <E, A>(e: Either<E, A>) => e is Left<E>;
declare const isRight: <E, A>(e: Either<E, A>) => e is Right<A>;
type HttpError = {
    name?: string;
    status?: number;
    body?: any;
    message?: string;
} & Record<string, any>;
type DomainError = CamundaValidationError | EventualConsistencyTimeoutError | HttpError | Error;
type DomainErrorTag = 'validation' | 'timeout' | 'http' | 'generic';
declare function classifyDomainError(err: DomainError): DomainErrorTag;
declare function foldDomainError<A>(handlers: {
    validation: (e: CamundaValidationError) => A;
    timeout: (e: EventualConsistencyTimeoutError) => A;
    http: (e: HttpError) => A;
    generic: (e: Error) => A;
}): (err: DomainError) => A;
type FnKeys<C> = {
    [K in keyof C]: C[K] extends (...a: any) => any ? K : never;
}[keyof C];
type Fpify<C> = {
    [K in FnKeys<C>]: C[K] extends (...a: infer A) => infer R ? (...a: A) => TaskEither<DomainError, Awaited<R>> : never;
} & {
    inner: C;
} & {
    [K in Exclude<keyof C, FnKeys<C>>]: C[K];
};
type CamundaFpClient = Fpify<CamundaClient>;
/**
 *
 * @experimental This feature under development and is not guaranteed to be fully tested or stable.
 * @description Camunda FP Client - a Task-Either compatible client. See the README and [this test](https://github.com/camunda/orchestration-cluster-api-js/blob/main/tests-integration/fp.test.ts) for example usage.
 */
declare function createCamundaFpClient(options?: CamundaOptions): CamundaFpClient;
declare function retryTE<E, A>(task: TaskEither<E, A>, opts: {
    max: number;
    baseDelayMs?: number;
    shouldRetry?: (e: E, attempt: number) => boolean | Promise<boolean>;
}): TaskEither<E, A>;
declare function withTimeoutTE<E, A>(task: TaskEither<E, A>, ms: number, onTimeout?: () => E): TaskEither<E, A>;
declare function eventuallyTE<E, A>(thunk: () => Promise<A>, predicate: (a: A) => boolean | Promise<boolean>, opts: {
    intervalMs?: number;
    waitUpToMs: number;
}): TaskEither<E, A>;

export { type TenantFilter as $, DecisionEvaluationKey as A, DecisionRequirementsKey as B, type CamundaOptions as C, DeploymentKey as D, type Either as E, FormKey as F, AuthorizationKey as G, MessageKey as H, IncidentKey as I, type JobWorkerConfig as J, DecisionInstanceKey as K, type LongKey as L, MessageSubscriptionKey as M, SignalKey as N, BatchOperationKey as O, ProcessInstanceKey as P, type TenantCreateResult as Q, type ResourceKey as R, StartCursor as S, type TenantCreateRequest as T, UserTaskKey as U, VariableKey as V, type TenantUpdateRequest as W, type TenantUpdateResult as X, type TenantResult as Y, type TenantSearchQuerySortRequest as Z, type TenantSearchQueryRequest as _, CamundaClient as a, type ProcessInstanceStateEnum as a$, type TenantSearchQueryResult as a0, type UserTaskSearchQuerySortRequest as a1, type UserTaskSearchQuery as a2, type UserTaskVariableSearchQuerySortRequest as a3, type UserTaskVariableSearchQueryRequest as a4, type UserTaskSearchQueryResult as a5, type UserTaskFilter as a6, type UserTaskStateFilterProperty as a7, type AdvancedUserTaskStateFilter as a8, type VariableValueFilterProperty as a9, type AdvancedDateTimeFilter as aA, type BasicStringFilterProperty as aB, type StringFilterProperty as aC, type LikeFilter as aD, type ProcessInstanceStateFilterProperty as aE, type ElementInstanceStateFilterProperty as aF, type DateTimeFilterProperty as aG, type AdvancedProcessDefinitionKeyFilter as aH, type ProcessDefinitionKeyFilterProperty as aI, type AdvancedProcessInstanceKeyFilter as aJ, type ProcessInstanceKeyFilterProperty as aK, type AdvancedElementInstanceKeyFilter as aL, type ElementInstanceKeyFilterProperty as aM, type AdvancedVariableKeyFilter as aN, type VariableKeyFilterProperty as aO, type AdvancedScopeKeyFilter as aP, type ScopeKeyFilterProperty as aQ, type AdvancedMessageSubscriptionKeyFilter as aR, type MessageSubscriptionKeyFilterProperty as aS, type AdvancedJobKeyFilter as aT, type JobKeyFilterProperty as aU, type BaseProcessInstanceFilterFields as aV, type ProcessDefinitionStatisticsFilter as aW, type ProcessInstanceFilterFields as aX, type ProcessInstanceFilter as aY, type ProcessInstanceSearchQueryResult as aZ, type ProcessInstanceResult as a_, type UserTaskVariableFilter as aa, type UserTaskResult as ab, type UserTaskStateEnum as ac, type VariableSearchQuerySortRequest as ad, type VariableSearchQuery as ae, type VariableFilter as af, type VariableSearchQueryResult as ag, type VariableSearchResult as ah, type VariableResult as ai, type VariableResultBase as aj, type ProcessDefinitionSearchQuerySortRequest as ak, type ProcessDefinitionSearchQuery as al, type ProcessDefinitionFilter as am, type ProcessDefinitionSearchQueryResult as an, type ProcessDefinitionResult as ao, type ProcessInstanceSearchQuerySortRequest as ap, type ProcessInstanceSearchQuery as aq, type ProcessInstanceIncidentSearchQuery as ar, type AdvancedIntegerFilter as as, type IntegerFilterProperty as at, type BasicStringFilter as au, type AdvancedStringFilter as av, type AdvancedProcessInstanceStateFilter as aw, type AdvancedElementInstanceStateFilter as ax, type AdvancedDecisionDefinitionKeyFilter as ay, type DecisionDefinitionKeyFilterProperty as az, type CancelablePromise as b, type UserUpdateRequest as b$, type ElementInstanceStateEnum as b0, type ProcessInstanceCallHierarchyEntry as b1, type ProcessInstanceSequenceFlowsQueryResult as b2, type ProcessInstanceSequenceFlowResult as b3, type ProcessDefinitionElementStatisticsQuery as b4, type ProcessDefinitionElementStatisticsQueryResult as b5, type ProcessInstanceElementStatisticsQueryResult as b6, type ProcessElementStatisticsResult as b7, type CancelProcessInstanceRequest as b8, type ElementInstanceSearchQuerySortRequest as b9, type IncidentResult as bA, type DecisionDefinitionSearchQueryResult as bB, type DecisionDefinitionResult as bC, type UsageMetricsResponse as bD, type UsageMetricsResponseItem as bE, type PermissionTypeEnum as bF, type ResourceTypeEnum as bG, type OwnerTypeEnum as bH, type AuthorizationRequest as bI, type AuthorizationCreateResult as bJ, type AuthorizationSearchQuerySortRequest as bK, type AuthorizationSearchQuery as bL, type AuthorizationFilter as bM, type AuthorizationResult as bN, type AuthorizationSearchResult as bO, type UserRequest as bP, type UserCreateResult as bQ, type UserUpdateResult as bR, type UserSearchQuerySortRequest as bS, type UserSearchQueryRequest as bT, type MappingRuleSearchQuerySortRequest as bU, type MappingRuleSearchQueryRequest as bV, type UserFilter as bW, type MappingRuleFilter as bX, type CamundaUserResult as bY, type UserResult as bZ, type UserSearchResult as b_, type ElementInstanceSearchQuery as ba, type ElementInstanceFilter as bb, type ElementInstanceSearchQueryResult as bc, type ElementInstanceResult as bd, type AdHocSubProcessActivateActivitiesInstruction as be, type AdHocSubProcessActivateActivityReference as bf, type DecisionDefinitionSearchQuerySortRequest as bg, type DecisionDefinitionSearchQuery as bh, type DecisionDefinitionFilter as bi, type IncidentSearchQuerySortRequest as bj, type IncidentSearchQuery as bk, type IncidentFilter as bl, type IncidentSearchQueryResult as bm, type CorrelatedMessageSubscriptionSearchQueryResult as bn, type CorrelatedMessageSubscriptionResult as bo, type CorrelatedMessageSubscriptionSearchQuery as bp, type CorrelatedMessageSubscriptionSearchQuerySortRequest as bq, type CorrelatedMessageSubscriptionFilter as br, type MessageSubscriptionSearchQueryResult as bs, type MessageSubscriptionResult as bt, type MessageSubscriptionSearchQuerySortRequest as bu, type MessageSubscriptionSearchQuery as bv, type MessageSubscriptionFilter as bw, type MessageSubscriptionStateFilterProperty as bx, type MessageSubscriptionStateEnum as by, type AdvancedMessageSubscriptionStateFilter as bz, createCamundaClient as c, type UserTaskAssignmentRequest as c$, type TenantClientResult as c0, type TenantClientSearchResult as c1, type TenantClientSearchQueryRequest as c2, type TenantClientSearchQuerySortRequest as c3, type TenantUserResult as c4, type TenantUserSearchResult as c5, type TenantUserSearchQueryRequest as c6, type TenantUserSearchQuerySortRequest as c7, type TenantGroupResult as c8, type TenantGroupSearchResult as c9, type GroupUpdateResult as cA, type GroupResult as cB, type GroupSearchQuerySortRequest as cC, type GroupSearchQueryRequest as cD, type GroupFilter as cE, type GroupSearchQueryResult as cF, type GroupUserResult as cG, type GroupUserSearchResult as cH, type GroupUserSearchQueryRequest as cI, type GroupUserSearchQuerySortRequest as cJ, type GroupClientResult as cK, type GroupClientSearchResult as cL, type GroupClientSearchQueryRequest as cM, type GroupClientSearchQuerySortRequest as cN, type MappingRuleCreateUpdateRequest as cO, type MappingRuleCreateRequest as cP, type MappingRuleUpdateRequest as cQ, type MappingRuleCreateUpdateResult as cR, type MappingRuleCreateResult as cS, type MappingRuleUpdateResult as cT, type MappingRuleSearchQueryResult as cU, type MappingRuleResult as cV, type TopologyResponse as cW, type LicenseResponse as cX, type BrokerInfo as cY, type Partition as cZ, type UserTaskCompletionRequest as c_, type TenantGroupSearchQueryRequest as ca, type TenantGroupSearchQuerySortRequest as cb, type RoleCreateRequest as cc, type RoleCreateResult as cd, type RoleUpdateRequest as ce, type RoleUpdateResult as cf, type RoleResult as cg, type RoleSearchQuerySortRequest as ch, type RoleSearchQueryRequest as ci, type RoleFilter as cj, type RoleSearchQueryResult as ck, type RoleUserResult as cl, type RoleUserSearchResult as cm, type RoleUserSearchQueryRequest as cn, type RoleUserSearchQuerySortRequest as co, type RoleClientResult as cp, type RoleClientSearchResult as cq, type RoleClientSearchQueryRequest as cr, type RoleClientSearchQuerySortRequest as cs, type RoleGroupResult as ct, type RoleGroupSearchResult as cu, type RoleGroupSearchQueryRequest as cv, type RoleGroupSearchQuerySortRequest as cw, type GroupCreateRequest as cx, type GroupCreateResult as cy, type GroupUpdateRequest as cz, JobWorker as d, type MessageCorrelationRequest as d$, type UserTaskUpdateRequest as d0, type Changeset as d1, type ClockPinRequest as d2, type JobActivationRequest as d3, type JobActivationResult as d4, type ActivatedJobResult as d5, type UserTaskProperties as d6, type JobFailRequest as d7, type JobErrorRequest as d8, type JobCompletionRequest as d9, type CursorForwardPagination as dA, type CursorBackwardPagination as dB, type SearchQueryResponse as dC, type SearchQueryPageResponse as dD, type DecisionRequirementsSearchQuerySortRequest as dE, type DecisionRequirementsSearchQuery as dF, type DecisionRequirementsFilter as dG, type DecisionRequirementsSearchQueryResult as dH, type DecisionRequirementsResult as dI, type DecisionEvaluationInstruction as dJ, type DecisionEvaluationById as dK, type DecisionEvaluationByKey as dL, type EvaluateDecisionResult as dM, type EvaluatedDecisionResult as dN, type MatchedDecisionRuleItem as dO, type EvaluatedDecisionInputItem as dP, type EvaluatedDecisionOutputItem as dQ, type DecisionInstanceSearchQuerySortRequest as dR, type DecisionInstanceSearchQuery as dS, type DecisionInstanceFilter as dT, type DecisionInstanceSearchQueryResult as dU, type DecisionInstanceResult as dV, type DecisionInstanceGetQueryResult as dW, type DecisionDefinitionTypeEnum as dX, type DecisionInstanceStateEnum as dY, type SortOrderEnum as dZ, type OperationReference as d_, type JobResult as da, type JobResultUserTask as db, type JobResultCorrections as dc, type JobResultAdHocSubProcess as dd, type JobResultActivateElement as de, type JobUpdateRequest as df, type JobChangeset as dg, type JobSearchQuery as dh, type JobSearchQuerySortRequest as di, type JobFilter as dj, type JobSearchQueryResult as dk, type JobSearchResult as dl, type JobStateEnum as dm, type JobKindEnum as dn, type JobListenerEventTypeEnum as dp, type JobStateFilterProperty as dq, type AdvancedJobStateFilter as dr, type JobKindFilterProperty as ds, type AdvancedJobKindFilter as dt, type JobListenerEventTypeFilterProperty as du, type AdvancedJobListenerEventTypeFilter as dv, type ProblemDetail as dw, type SearchQueryRequest as dx, type SearchQueryPageRequest as dy, type OffsetPagination as dz, type Job as e, type ProcessInstanceModificationMoveBatchOperationInstruction as e$, type MessageCorrelationResult as e0, type MessagePublicationRequest as e1, type MessagePublicationResult as e2, type DocumentReference as e3, type DocumentCreationFailureDetail as e4, type DocumentCreationBatchResponse as e5, DocumentId as e6, type DocumentMetadata as e7, type DocumentLinkRequest as e8, type DocumentLink as e9, type SignalBroadcastResult as eA, type FormResult as eB, type ResourceResult as eC, type BatchOperationTypeEnum as eD, type BatchOperationCreatedResult as eE, type BatchOperationSearchQuerySortRequest as eF, type BatchOperationSearchQuery as eG, type BatchOperationFilter as eH, type BatchOperationTypeFilterProperty as eI, type AdvancedBatchOperationTypeFilter as eJ, type BatchOperationStateFilterProperty as eK, type AdvancedBatchOperationStateFilter as eL, type BatchOperationStateEnum as eM, type BatchOperationItemSearchQuerySortRequest as eN, type BatchOperationItemSearchQuery as eO, type BatchOperationItemFilter as eP, type BatchOperationItemStateFilterProperty as eQ, type AdvancedBatchOperationItemStateFilter as eR, type BatchOperationItemStateEnum as eS, type BatchOperationSearchQueryResult as eT, type BatchOperationResponse as eU, type BatchOperationError as eV, type BatchOperationItemSearchQueryResult as eW, type BatchOperationItemResponse as eX, type ProcessInstanceCancellationBatchOperationRequest as eY, type ProcessInstanceIncidentResolutionBatchOperationRequest as eZ, type ProcessInstanceModificationBatchOperationRequest as e_, type DeploymentResult as ea, type DeploymentMetadataResult as eb, type DeploymentProcessResult as ec, type DeploymentDecisionResult as ed, type DeploymentDecisionRequirementsResult as ee, type DeploymentFormResult as ef, type DeploymentResourceResult as eg, type IncidentResolutionRequest as eh, type ProcessInstanceCreationInstruction as ei, type ProcessInstanceCreationInstructionById as ej, type ProcessInstanceCreationInstructionByKey as ek, type ProcessInstanceCreationStartInstruction as el, type ProcessInstanceCreationRuntimeInstruction as em, type ProcessInstanceCreationTerminateInstruction as en, type CreateProcessInstanceResult as eo, type ProcessInstanceMigrationBatchOperationRequest as ep, type ProcessInstanceMigrationBatchOperationPlan as eq, type ProcessInstanceMigrationInstruction as er, type MigrateProcessInstanceMappingInstruction as es, type ProcessInstanceModificationInstruction as et, type ProcessInstanceModificationActivateInstruction as eu, type ModifyProcessInstanceVariableInstruction as ev, type ProcessInstanceModificationTerminateInstruction as ew, type SetVariableRequest as ex, type DeleteResourceRequest as ey, type SignalBroadcastRequest as ez, JobActionReceipt as f, type DeleteTenantData as f$, Tag as f0, type TagSet as f1, TenantId as f2, Username as f3, type GetTopologyData as f4, type GetTopologyErrors as f5, type GetTopologyError as f6, type GetTopologyResponses as f7, type GetTopologyResponse as f8, type GetStatusData as f9, type FailJobResponses as fA, type FailJobResponse as fB, type ThrowJobErrorData as fC, type ThrowJobErrorErrors as fD, type ThrowJobErrorError as fE, type ThrowJobErrorResponses as fF, type ThrowJobErrorResponse as fG, type CompleteJobData as fH, type CompleteJobErrors as fI, type CompleteJobError as fJ, type CompleteJobResponses as fK, type CompleteJobResponse as fL, type UpdateJobData as fM, type UpdateJobErrors as fN, type UpdateJobError as fO, type UpdateJobResponses as fP, type UpdateJobResponse as fQ, type ResolveIncidentData as fR, type ResolveIncidentErrors as fS, type ResolveIncidentError as fT, type ResolveIncidentResponses as fU, type ResolveIncidentResponse as fV, type CreateTenantData as fW, type CreateTenantErrors as fX, type CreateTenantError as fY, type CreateTenantResponses as fZ, type CreateTenantResponse as f_, type GetStatusErrors as fa, type GetStatusResponses as fb, type GetStatusResponse as fc, type GetLicenseData as fd, type GetLicenseErrors as fe, type GetLicenseError as ff, type GetLicenseResponses as fg, type GetLicenseResponse as fh, type GetAuthenticationData as fi, type GetAuthenticationErrors as fj, type GetAuthenticationError as fk, type GetAuthenticationResponses as fl, type GetAuthenticationResponse as fm, type ActivateJobsData as fn, type ActivateJobsErrors as fo, type ActivateJobsError as fp, type ActivateJobsResponses as fq, type ActivateJobsResponse as fr, type SearchJobsData as fs, type SearchJobsErrors as ft, type SearchJobsError as fu, type SearchJobsResponses as fv, type SearchJobsResponse as fw, type FailJobData as fx, type FailJobErrors as fy, type FailJobError as fz, createCamundaFpClient as g, type UnassignGroupFromTenantResponse as g$, type DeleteTenantErrors as g0, type DeleteTenantError as g1, type DeleteTenantResponses as g2, type DeleteTenantResponse as g3, type GetTenantData as g4, type GetTenantErrors as g5, type GetTenantError as g6, type GetTenantResponses as g7, type GetTenantResponse as g8, type UpdateTenantData as g9, type UnassignClientFromTenantData as gA, type UnassignClientFromTenantErrors as gB, type UnassignClientFromTenantError as gC, type UnassignClientFromTenantResponses as gD, type UnassignClientFromTenantResponse as gE, type AssignClientToTenantData as gF, type AssignClientToTenantErrors as gG, type AssignClientToTenantError as gH, type AssignClientToTenantResponses as gI, type AssignClientToTenantResponse as gJ, type UnassignMappingRuleFromTenantData as gK, type UnassignMappingRuleFromTenantErrors as gL, type UnassignMappingRuleFromTenantError as gM, type UnassignMappingRuleFromTenantResponses as gN, type UnassignMappingRuleFromTenantResponse as gO, type AssignMappingRuleToTenantData as gP, type AssignMappingRuleToTenantErrors as gQ, type AssignMappingRuleToTenantError as gR, type AssignMappingRuleToTenantResponses as gS, type AssignMappingRuleToTenantResponse as gT, type SearchMappingRulesForTenantData as gU, type SearchMappingRulesForTenantResponses as gV, type SearchMappingRulesForTenantResponse as gW, type UnassignGroupFromTenantData as gX, type UnassignGroupFromTenantErrors as gY, type UnassignGroupFromTenantError as gZ, type UnassignGroupFromTenantResponses as g_, type UpdateTenantErrors as ga, type UpdateTenantError as gb, type UpdateTenantResponses as gc, type UpdateTenantResponse as gd, type UnassignUserFromTenantData as ge, type UnassignUserFromTenantErrors as gf, type UnassignUserFromTenantError as gg, type UnassignUserFromTenantResponses as gh, type UnassignUserFromTenantResponse as gi, type AssignUserToTenantData as gj, type AssignUserToTenantErrors as gk, type AssignUserToTenantError as gl, type AssignUserToTenantResponses as gm, type AssignUserToTenantResponse as gn, type SearchUsersForTenantData as go, type SearchUsersForTenantResponses as gp, type SearchUsersForTenantResponse as gq, type SearchClientsForTenantData as gr, type SearchClientsForTenantResponses as gs, type SearchClientsForTenantResponse as gt, type SearchGroupIdsForTenantData as gu, type SearchGroupIdsForTenantResponses as gv, type SearchGroupIdsForTenantResponse as gw, type SearchRolesForTenantData as gx, type SearchRolesForTenantResponses as gy, type SearchRolesForTenantResponse as gz, type CamundaFpClient as h, type SearchVariablesResponses as h$, type AssignGroupToTenantData as h0, type AssignGroupToTenantErrors as h1, type AssignGroupToTenantError as h2, type AssignGroupToTenantResponses as h3, type AssignGroupToTenantResponse as h4, type UnassignRoleFromTenantData as h5, type UnassignRoleFromTenantErrors as h6, type UnassignRoleFromTenantError as h7, type UnassignRoleFromTenantResponses as h8, type UnassignRoleFromTenantResponse as h9, type UpdateUserTaskErrors as hA, type UpdateUserTaskError as hB, type UpdateUserTaskResponses as hC, type UpdateUserTaskResponse as hD, type GetUserTaskFormData as hE, type GetUserTaskFormErrors as hF, type GetUserTaskFormError as hG, type GetUserTaskFormResponses as hH, type GetUserTaskFormResponse as hI, type UnassignUserTaskData as hJ, type UnassignUserTaskErrors as hK, type UnassignUserTaskError as hL, type UnassignUserTaskResponses as hM, type UnassignUserTaskResponse as hN, type SearchUserTasksData as hO, type SearchUserTasksErrors as hP, type SearchUserTasksError as hQ, type SearchUserTasksResponses as hR, type SearchUserTasksResponse as hS, type SearchUserTaskVariablesData as hT, type SearchUserTaskVariablesErrors as hU, type SearchUserTaskVariablesError as hV, type SearchUserTaskVariablesResponses as hW, type SearchUserTaskVariablesResponse as hX, type SearchVariablesData as hY, type SearchVariablesErrors as hZ, type SearchVariablesError as h_, type AssignRoleToTenantData as ha, type AssignRoleToTenantErrors as hb, type AssignRoleToTenantError as hc, type AssignRoleToTenantResponses as hd, type AssignRoleToTenantResponse as he, type SearchTenantsData as hf, type SearchTenantsErrors as hg, type SearchTenantsError as hh, type SearchTenantsResponses as hi, type SearchTenantsResponse as hj, type CompleteUserTaskData as hk, type CompleteUserTaskErrors as hl, type CompleteUserTaskError as hm, type CompleteUserTaskResponses as hn, type CompleteUserTaskResponse as ho, type AssignUserTaskData as hp, type AssignUserTaskErrors as hq, type AssignUserTaskError as hr, type AssignUserTaskResponses as hs, type AssignUserTaskResponse as ht, type GetUserTaskData as hu, type GetUserTaskErrors as hv, type GetUserTaskError as hw, type GetUserTaskResponses as hx, type GetUserTaskResponse as hy, type UpdateUserTaskData as hz, isLeft as i, type SearchProcessInstancesData as i$, type SearchVariablesResponse as i0, type GetVariableData as i1, type GetVariableErrors as i2, type GetVariableError as i3, type GetVariableResponses as i4, type GetVariableResponse as i5, type PinClockData as i6, type PinClockErrors as i7, type PinClockError as i8, type PinClockResponses as i9, type GetStartProcessFormResponses as iA, type GetStartProcessFormResponse as iB, type GetProcessDefinitionStatisticsData as iC, type GetProcessDefinitionStatisticsErrors as iD, type GetProcessDefinitionStatisticsError as iE, type GetProcessDefinitionStatisticsResponses as iF, type GetProcessDefinitionStatisticsResponse as iG, type CreateProcessInstanceData as iH, type CreateProcessInstanceErrors as iI, type CreateProcessInstanceError as iJ, type CreateProcessInstanceResponses as iK, type CreateProcessInstanceResponse as iL, type GetProcessInstanceData as iM, type GetProcessInstanceErrors as iN, type GetProcessInstanceError as iO, type GetProcessInstanceResponses as iP, type GetProcessInstanceResponse as iQ, type GetProcessInstanceSequenceFlowsData as iR, type GetProcessInstanceSequenceFlowsErrors as iS, type GetProcessInstanceSequenceFlowsError as iT, type GetProcessInstanceSequenceFlowsResponses as iU, type GetProcessInstanceSequenceFlowsResponse as iV, type GetProcessInstanceStatisticsData as iW, type GetProcessInstanceStatisticsErrors as iX, type GetProcessInstanceStatisticsError as iY, type GetProcessInstanceStatisticsResponses as iZ, type GetProcessInstanceStatisticsResponse as i_, type PinClockResponse as ia, type ResetClockData as ib, type ResetClockErrors as ic, type ResetClockError as id, type ResetClockResponses as ie, type ResetClockResponse as ig, type SearchProcessDefinitionsData as ih, type SearchProcessDefinitionsErrors as ii, type SearchProcessDefinitionsError as ij, type SearchProcessDefinitionsResponses as ik, type SearchProcessDefinitionsResponse as il, type GetProcessDefinitionData as im, type GetProcessDefinitionErrors as io, type GetProcessDefinitionError as ip, type GetProcessDefinitionResponses as iq, type GetProcessDefinitionResponse as ir, type GetProcessDefinitionXmlData as is, type GetProcessDefinitionXmlErrors as it, type GetProcessDefinitionXmlError as iu, type GetProcessDefinitionXmlResponses as iv, type GetProcessDefinitionXmlResponse as iw, type GetStartProcessFormData as ix, type GetStartProcessFormErrors as iy, type GetStartProcessFormError as iz, isRight as j, type SearchDecisionDefinitionsResponse as j$, type SearchProcessInstancesErrors as j0, type SearchProcessInstancesError as j1, type SearchProcessInstancesResponses as j2, type SearchProcessInstancesResponse as j3, type SearchProcessInstanceIncidentsData as j4, type SearchProcessInstanceIncidentsErrors as j5, type SearchProcessInstanceIncidentsError as j6, type SearchProcessInstanceIncidentsResponses as j7, type SearchProcessInstanceIncidentsResponse as j8, type CancelProcessInstanceData as j9, type MigrateProcessInstanceError as jA, type MigrateProcessInstanceResponses as jB, type MigrateProcessInstanceResponse as jC, type ModifyProcessInstanceData as jD, type ModifyProcessInstanceErrors as jE, type ModifyProcessInstanceError as jF, type ModifyProcessInstanceResponses as jG, type ModifyProcessInstanceResponse as jH, type GetProcessInstanceCallHierarchyData as jI, type GetProcessInstanceCallHierarchyErrors as jJ, type GetProcessInstanceCallHierarchyError as jK, type GetProcessInstanceCallHierarchyResponses as jL, type GetProcessInstanceCallHierarchyResponse as jM, type SearchElementInstancesData as jN, type SearchElementInstancesErrors as jO, type SearchElementInstancesError as jP, type SearchElementInstancesResponses as jQ, type SearchElementInstancesResponse as jR, type GetElementInstanceData as jS, type GetElementInstanceErrors as jT, type GetElementInstanceError as jU, type GetElementInstanceResponses as jV, type GetElementInstanceResponse as jW, type SearchDecisionDefinitionsData as jX, type SearchDecisionDefinitionsErrors as jY, type SearchDecisionDefinitionsError as jZ, type SearchDecisionDefinitionsResponses as j_, type CancelProcessInstanceErrors as ja, type CancelProcessInstanceError as jb, type CancelProcessInstanceResponses as jc, type CancelProcessInstanceResponse as jd, type CancelProcessInstancesBatchOperationData as je, type CancelProcessInstancesBatchOperationErrors as jf, type CancelProcessInstancesBatchOperationError as jg, type CancelProcessInstancesBatchOperationResponses as jh, type CancelProcessInstancesBatchOperationResponse as ji, type ResolveIncidentsBatchOperationData as jj, type ResolveIncidentsBatchOperationErrors as jk, type ResolveIncidentsBatchOperationError as jl, type ResolveIncidentsBatchOperationResponses as jm, type ResolveIncidentsBatchOperationResponse as jn, type MigrateProcessInstancesBatchOperationData as jo, type MigrateProcessInstancesBatchOperationErrors as jp, type MigrateProcessInstancesBatchOperationError as jq, type MigrateProcessInstancesBatchOperationResponses as jr, type MigrateProcessInstancesBatchOperationResponse as js, type ModifyProcessInstancesBatchOperationData as jt, type ModifyProcessInstancesBatchOperationErrors as ju, type ModifyProcessInstancesBatchOperationError as jv, type ModifyProcessInstancesBatchOperationResponses as jw, type ModifyProcessInstancesBatchOperationResponse as jx, type MigrateProcessInstanceData as jy, type MigrateProcessInstanceErrors as jz, CamundaValidationError as k, type SearchAuthorizationsResponses as k$, type GetDecisionDefinitionData as k0, type GetDecisionDefinitionErrors as k1, type GetDecisionDefinitionError as k2, type GetDecisionDefinitionResponses as k3, type GetDecisionDefinitionResponse as k4, type GetDecisionDefinitionXmlData as k5, type GetDecisionDefinitionXmlErrors as k6, type GetDecisionDefinitionXmlError as k7, type GetDecisionDefinitionXmlResponses as k8, type GetDecisionDefinitionXmlResponse as k9, type EvaluateDecisionErrors as kA, type EvaluateDecisionError as kB, type EvaluateDecisionResponses as kC, type EvaluateDecisionResponse as kD, type CreateAuthorizationData as kE, type CreateAuthorizationErrors as kF, type CreateAuthorizationError as kG, type CreateAuthorizationResponses as kH, type CreateAuthorizationResponse as kI, type DeleteAuthorizationData as kJ, type DeleteAuthorizationErrors as kK, type DeleteAuthorizationError as kL, type DeleteAuthorizationResponses as kM, type DeleteAuthorizationResponse as kN, type GetAuthorizationData as kO, type GetAuthorizationErrors as kP, type GetAuthorizationError as kQ, type GetAuthorizationResponses as kR, type GetAuthorizationResponse as kS, type UpdateAuthorizationData as kT, type UpdateAuthorizationErrors as kU, type UpdateAuthorizationError as kV, type UpdateAuthorizationResponses as kW, type UpdateAuthorizationResponse as kX, type SearchAuthorizationsData as kY, type SearchAuthorizationsErrors as kZ, type SearchAuthorizationsError as k_, type SearchDecisionRequirementsData as ka, type SearchDecisionRequirementsErrors as kb, type SearchDecisionRequirementsError as kc, type SearchDecisionRequirementsResponses as kd, type SearchDecisionRequirementsResponse as ke, type GetDecisionRequirementsData as kf, type GetDecisionRequirementsErrors as kg, type GetDecisionRequirementsError as kh, type GetDecisionRequirementsResponses as ki, type GetDecisionRequirementsResponse as kj, type GetDecisionRequirementsXmlData as kk, type GetDecisionRequirementsXmlErrors as kl, type GetDecisionRequirementsXmlError as km, type GetDecisionRequirementsXmlResponses as kn, type GetDecisionRequirementsXmlResponse as ko, type SearchDecisionInstancesData as kp, type SearchDecisionInstancesErrors as kq, type SearchDecisionInstancesError as kr, type SearchDecisionInstancesResponses as ks, type SearchDecisionInstancesResponse as kt, type GetDecisionInstanceData as ku, type GetDecisionInstanceErrors as kv, type GetDecisionInstanceError as kw, type GetDecisionInstanceResponses as kx, type GetDecisionInstanceResponse as ky, type EvaluateDecisionData as kz, EventualConsistencyTimeoutError as l, type AssignRoleToGroupError as l$, type SearchAuthorizationsResponse as l0, type CreateRoleData as l1, type CreateRoleErrors as l2, type CreateRoleError as l3, type CreateRoleResponses as l4, type CreateRoleResponse as l5, type DeleteRoleData as l6, type DeleteRoleErrors as l7, type DeleteRoleError as l8, type DeleteRoleResponses as l9, type AssignRoleToUserData as lA, type AssignRoleToUserErrors as lB, type AssignRoleToUserError as lC, type AssignRoleToUserResponses as lD, type AssignRoleToUserResponse as lE, type UnassignRoleFromClientData as lF, type UnassignRoleFromClientErrors as lG, type UnassignRoleFromClientError as lH, type UnassignRoleFromClientResponses as lI, type UnassignRoleFromClientResponse as lJ, type AssignRoleToClientData as lK, type AssignRoleToClientErrors as lL, type AssignRoleToClientError as lM, type AssignRoleToClientResponses as lN, type AssignRoleToClientResponse as lO, type SearchRolesData as lP, type SearchRolesErrors as lQ, type SearchRolesError as lR, type SearchRolesResponses as lS, type SearchRolesResponse as lT, type UnassignRoleFromGroupData as lU, type UnassignRoleFromGroupErrors as lV, type UnassignRoleFromGroupError as lW, type UnassignRoleFromGroupResponses as lX, type UnassignRoleFromGroupResponse as lY, type AssignRoleToGroupData as lZ, type AssignRoleToGroupErrors as l_, type DeleteRoleResponse as la, type GetRoleData as lb, type GetRoleErrors as lc, type GetRoleError as ld, type GetRoleResponses as le, type GetRoleResponse as lf, type UpdateRoleData as lg, type UpdateRoleErrors as lh, type UpdateRoleError as li, type UpdateRoleResponses as lj, type UpdateRoleResponse as lk, type SearchUsersForRoleData as ll, type SearchUsersForRoleErrors as lm, type SearchUsersForRoleError as ln, type SearchUsersForRoleResponses as lo, type SearchUsersForRoleResponse as lp, type SearchClientsForRoleData as lq, type SearchClientsForRoleErrors as lr, type SearchClientsForRoleError as ls, type SearchClientsForRoleResponses as lt, type SearchClientsForRoleResponse as lu, type UnassignRoleFromUserData as lv, type UnassignRoleFromUserErrors as lw, type UnassignRoleFromUserError as lx, type UnassignRoleFromUserResponses as ly, type UnassignRoleFromUserResponse as lz, type EnrichedActivatedJob as m, type UnassignUserFromGroupErrors as m$, type AssignRoleToGroupResponses as m0, type AssignRoleToGroupResponse as m1, type SearchGroupsForRoleData as m2, type SearchGroupsForRoleErrors as m3, type SearchGroupsForRoleError as m4, type SearchGroupsForRoleResponses as m5, type SearchGroupsForRoleResponse as m6, type UnassignRoleFromMappingRuleData as m7, type UnassignRoleFromMappingRuleErrors as m8, type UnassignRoleFromMappingRuleError as m9, type GetGroupResponse as mA, type UpdateGroupData as mB, type UpdateGroupErrors as mC, type UpdateGroupError as mD, type UpdateGroupResponses as mE, type UpdateGroupResponse as mF, type SearchUsersForGroupData as mG, type SearchUsersForGroupErrors as mH, type SearchUsersForGroupError as mI, type SearchUsersForGroupResponses as mJ, type SearchUsersForGroupResponse as mK, type SearchMappingRulesForGroupData as mL, type SearchMappingRulesForGroupErrors as mM, type SearchMappingRulesForGroupError as mN, type SearchMappingRulesForGroupResponses as mO, type SearchMappingRulesForGroupResponse as mP, type SearchRolesForGroupData as mQ, type SearchRolesForGroupErrors as mR, type SearchRolesForGroupError as mS, type SearchRolesForGroupResponses as mT, type SearchRolesForGroupResponse as mU, type SearchClientsForGroupData as mV, type SearchClientsForGroupErrors as mW, type SearchClientsForGroupError as mX, type SearchClientsForGroupResponses as mY, type SearchClientsForGroupResponse as mZ, type UnassignUserFromGroupData as m_, type UnassignRoleFromMappingRuleResponses as ma, type UnassignRoleFromMappingRuleResponse as mb, type AssignRoleToMappingRuleData as mc, type AssignRoleToMappingRuleErrors as md, type AssignRoleToMappingRuleError as me, type AssignRoleToMappingRuleResponses as mf, type AssignRoleToMappingRuleResponse as mg, type SearchMappingRulesForRoleData as mh, type SearchMappingRulesForRoleErrors as mi, type SearchMappingRulesForRoleError as mj, type SearchMappingRulesForRoleResponses as mk, type SearchMappingRulesForRoleResponse as ml, type CreateGroupData as mm, type CreateGroupErrors as mn, type CreateGroupError as mo, type CreateGroupResponses as mp, type CreateGroupResponse as mq, type DeleteGroupData as mr, type DeleteGroupErrors as ms, type DeleteGroupError as mt, type DeleteGroupResponses as mu, type DeleteGroupResponse as mv, type GetGroupData as mw, type GetGroupErrors as mx, type GetGroupError as my, type GetGroupResponses as mz, type CamundaKey as n, type CorrelateMessageData as n$, type UnassignUserFromGroupError as n0, type UnassignUserFromGroupResponses as n1, type UnassignUserFromGroupResponse as n2, type AssignUserToGroupData as n3, type AssignUserToGroupErrors as n4, type AssignUserToGroupError as n5, type AssignUserToGroupResponses as n6, type AssignUserToGroupResponse as n7, type UnassignClientFromGroupData as n8, type UnassignClientFromGroupErrors as n9, type CreateMappingRuleResponses as nA, type CreateMappingRuleResponse as nB, type DeleteMappingRuleData as nC, type DeleteMappingRuleErrors as nD, type DeleteMappingRuleError as nE, type DeleteMappingRuleResponses as nF, type DeleteMappingRuleResponse as nG, type GetMappingRuleData as nH, type GetMappingRuleErrors as nI, type GetMappingRuleError as nJ, type GetMappingRuleResponses as nK, type GetMappingRuleResponse as nL, type UpdateMappingRuleData as nM, type UpdateMappingRuleErrors as nN, type UpdateMappingRuleError as nO, type UpdateMappingRuleResponses as nP, type UpdateMappingRuleResponse as nQ, type SearchMappingRuleData as nR, type SearchMappingRuleErrors as nS, type SearchMappingRuleError as nT, type SearchMappingRuleResponses as nU, type SearchMappingRuleResponse as nV, type PublishMessageData as nW, type PublishMessageErrors as nX, type PublishMessageError as nY, type PublishMessageResponses as nZ, type PublishMessageResponse as n_, type UnassignClientFromGroupError as na, type UnassignClientFromGroupResponses as nb, type UnassignClientFromGroupResponse as nc, type AssignClientToGroupData as nd, type AssignClientToGroupErrors as ne, type AssignClientToGroupError as nf, type AssignClientToGroupResponses as ng, type AssignClientToGroupResponse as nh, type UnassignMappingRuleFromGroupData as ni, type UnassignMappingRuleFromGroupErrors as nj, type UnassignMappingRuleFromGroupError as nk, type UnassignMappingRuleFromGroupResponses as nl, type UnassignMappingRuleFromGroupResponse as nm, type AssignMappingRuleToGroupData as nn, type AssignMappingRuleToGroupErrors as no, type AssignMappingRuleToGroupError as np, type AssignMappingRuleToGroupResponses as nq, type AssignMappingRuleToGroupResponse as nr, type SearchGroupsData as ns, type SearchGroupsErrors as nt, type SearchGroupsError as nu, type SearchGroupsResponses as nv, type SearchGroupsResponse as nw, type CreateMappingRuleData as nx, type CreateMappingRuleErrors as ny, type CreateMappingRuleError as nz, EndCursor as o, type UpdateUserResponse as o$, type CorrelateMessageErrors as o0, type CorrelateMessageError as o1, type CorrelateMessageResponses as o2, type CorrelateMessageResponse as o3, type SearchCorrelatedMessageSubscriptionsData as o4, type SearchCorrelatedMessageSubscriptionsErrors as o5, type SearchCorrelatedMessageSubscriptionsError as o6, type SearchCorrelatedMessageSubscriptionsResponses as o7, type SearchCorrelatedMessageSubscriptionsResponse as o8, type SearchMessageSubscriptionsData as o9, type CreateDocumentLinkError as oA, type CreateDocumentLinkResponses as oB, type CreateDocumentLinkResponse as oC, type CreateUserData as oD, type CreateUserErrors as oE, type CreateUserError as oF, type CreateUserResponses as oG, type CreateUserResponse as oH, type SearchUsersData as oI, type SearchUsersErrors as oJ, type SearchUsersError as oK, type SearchUsersResponses as oL, type SearchUsersResponse as oM, type DeleteUserData as oN, type DeleteUserErrors as oO, type DeleteUserError as oP, type DeleteUserResponses as oQ, type DeleteUserResponse as oR, type GetUserData as oS, type GetUserErrors as oT, type GetUserError as oU, type GetUserResponses as oV, type GetUserResponse as oW, type UpdateUserData as oX, type UpdateUserErrors as oY, type UpdateUserError as oZ, type UpdateUserResponses as o_, type SearchMessageSubscriptionsErrors as oa, type SearchMessageSubscriptionsError as ob, type SearchMessageSubscriptionsResponses as oc, type SearchMessageSubscriptionsResponse as od, type CreateDocumentData as oe, type CreateDocumentErrors as of, type CreateDocumentError as og, type CreateDocumentResponses as oh, type CreateDocumentResponse as oi, type CreateDocumentsData as oj, type CreateDocumentsErrors as ok, type CreateDocumentsError as ol, type CreateDocumentsResponses as om, type CreateDocumentsResponse as on, type DeleteDocumentData as oo, type DeleteDocumentErrors as op, type DeleteDocumentError as oq, type DeleteDocumentResponses as or, type DeleteDocumentResponse as os, type GetDocumentData as ot, type GetDocumentErrors as ou, type GetDocumentError as ov, type GetDocumentResponses as ow, type GetDocumentResponse as ox, type CreateDocumentLinkData as oy, type CreateDocumentLinkErrors as oz, ProcessDefinitionKey as p, type SearchBatchOperationsResponse as p$, type CreateAdminUserData as p0, type CreateAdminUserErrors as p1, type CreateAdminUserError as p2, type CreateAdminUserResponses as p3, type CreateAdminUserResponse as p4, type SearchIncidentsData as p5, type SearchIncidentsErrors as p6, type SearchIncidentsError as p7, type SearchIncidentsResponses as p8, type SearchIncidentsResponse as p9, type GetResourceContentError as pA, type GetResourceContentResponses as pB, type GetResourceContentResponse as pC, type CreateElementInstanceVariablesData as pD, type CreateElementInstanceVariablesErrors as pE, type CreateElementInstanceVariablesError as pF, type CreateElementInstanceVariablesResponses as pG, type CreateElementInstanceVariablesResponse as pH, type ActivateAdHocSubProcessActivitiesData as pI, type ActivateAdHocSubProcessActivitiesErrors as pJ, type ActivateAdHocSubProcessActivitiesError as pK, type ActivateAdHocSubProcessActivitiesResponses as pL, type ActivateAdHocSubProcessActivitiesResponse as pM, type BroadcastSignalData as pN, type BroadcastSignalErrors as pO, type BroadcastSignalError as pP, type BroadcastSignalResponses as pQ, type BroadcastSignalResponse as pR, type GetBatchOperationData as pS, type GetBatchOperationErrors as pT, type GetBatchOperationError as pU, type GetBatchOperationResponses as pV, type GetBatchOperationResponse as pW, type SearchBatchOperationsData as pX, type SearchBatchOperationsErrors as pY, type SearchBatchOperationsError as pZ, type SearchBatchOperationsResponses as p_, type GetIncidentData as pa, type GetIncidentErrors as pb, type GetIncidentError as pc, type GetIncidentResponses as pd, type GetIncidentResponse as pe, type GetUsageMetricsData as pf, type GetUsageMetricsErrors as pg, type GetUsageMetricsError as ph, type GetUsageMetricsResponses as pi, type GetUsageMetricsResponse as pj, type CreateDeploymentData as pk, type CreateDeploymentErrors as pl, type CreateDeploymentError as pm, type CreateDeploymentResponses as pn, type CreateDeploymentResponse as po, type DeleteResourceData as pp, type DeleteResourceErrors as pq, type DeleteResourceError as pr, type DeleteResourceResponses as ps, type GetResourceData as pt, type GetResourceErrors as pu, type GetResourceError as pv, type GetResourceResponses as pw, type GetResourceResponse as px, type GetResourceContentData as py, type GetResourceContentErrors as pz, ProcessDefinitionId as q, type CancelBatchOperationData as q0, type CancelBatchOperationErrors as q1, type CancelBatchOperationError as q2, type CancelBatchOperationResponses as q3, type CancelBatchOperationResponse as q4, type SuspendBatchOperationData as q5, type SuspendBatchOperationErrors as q6, type SuspendBatchOperationError as q7, type SuspendBatchOperationResponses as q8, type SuspendBatchOperationResponse as q9, type ResumeBatchOperationData as qa, type ResumeBatchOperationErrors as qb, type ResumeBatchOperationError as qc, type ResumeBatchOperationResponses as qd, type ResumeBatchOperationResponse as qe, type SearchBatchOperationItemsData as qf, type SearchBatchOperationItemsErrors as qg, type SearchBatchOperationItemsError as qh, type SearchBatchOperationItemsResponses as qi, type SearchBatchOperationItemsResponse as qj, type ClientOptions as qk, assertConstraint as ql, type Fpify as qm, type DomainError as qn, type Left as qo, type Right as qp, retryTE as qq, withTimeoutTE as qr, eventuallyTE as qs, foldDomainError as qt, classifyDomainError as qu, type TaskEither as qv, ElementInstanceKey as r, ElementId as s, FormId as t, ScopeKey as u, JobKey as v, MessageCorrelationKey as w, DecisionDefinitionKey as x, DecisionDefinitionId as y, DecisionEvaluationInstanceKey as z };
