import {
  __export,
  __require,
  createLogger
} from "./chunk-W6JB7JZH.js";

// src/runtime/errors.ts
function isSdkError(e) {
  return !!e && typeof e === "object" && "name" in e && [
    "HttpSdkError",
    "ValidationSdkError",
    "AuthSdkError",
    "NetworkSdkError",
    "CancelSdkError"
  ].includes(e.name);
}
function normalizeError(err, ctx) {
  if (isSdkError(err)) return err;
  const e = err || {};
  if (e?.name === "AbortError" || e?.name === "CancelError" || e?.name === "CancelSdkError" || e?.code === "ABORT_ERR" || /aborted|abort|cancelled|canceled/i.test(e?.message || "")) {
    const cErr = new Error("Cancelled");
    cErr.name = "CancelSdkError";
    cErr.operationId = ctx?.opId;
    if (e?.message && !/Cancelled/i.test(e.message)) cErr.message = e.message;
    if (e?.stack) cErr.stack = e.stack;
    return cErr;
  }
  if (typeof e.status === "number") {
    const msg = e.message || e.title || e.detail || `HTTP ${e.status}`;
    const httpErr = new Error(msg);
    httpErr.name = "HttpSdkError";
    httpErr.status = e.status;
    httpErr.operationId = ctx?.opId;
    for (const k of ["type", "title", "detail", "instance"]) {
      if (e[k] !== void 0) httpErr[k] = e[k];
    }
    if (e.nonRetryable) httpErr.nonRetryable = true;
    if (e.stack && typeof e.stack === "string") {
      httpErr.stack = e.stack;
    }
    return httpErr;
  }
  if (e?.code === "VALIDATION_ERROR" || /validation/i.test(e?.message || "") || /Invalid .* request/i.test(e?.message || "")) {
    const vErr = new Error(e.message || "Validation error");
    vErr.name = "ValidationSdkError";
    vErr.side = e.side || "request";
    vErr.operationId = e.operationId || ctx?.opId || "unknown";
    vErr.issues = e.issues;
    if (e.stack) vErr.stack = e.stack;
    return vErr;
  }
  if (/auth/i.test(e?.message || "") || e?.name === "AuthError") {
    const aErr = new Error(e.message || "Authentication error");
    aErr.name = "AuthSdkError";
    aErr.status = e.status;
    aErr.cause = e;
    if (e.stack) aErr.stack = e.stack;
    return aErr;
  }
  if (e?.name === "TypeError" || /network/i.test(e?.message || "")) {
    const nErr = new Error(e.message || "Network error");
    nErr.name = "NetworkSdkError";
    nErr.cause = e;
    if (e.stack) nErr.stack = e.stack;
    return nErr;
  }
  const unk = new Error(e?.message || "Unknown error");
  unk.name = "NetworkSdkError";
  unk.cause = e;
  if (e.stack) unk.stack = e.stack;
  return unk;
}
var CamundaValidationError = class extends Error {
  side;
  operationId;
  summary;
  issues;
  constructor(params) {
    super(params.message);
    this.name = "CamundaValidationError";
    this.side = params.side;
    this.operationId = params.operationId;
    this.summary = params.summary;
    this.issues = params.issues;
  }
};
var EventualConsistencyTimeoutError = class extends Error {
  code = "CAMUNDA_SDK_EVENTUAL_TIMEOUT";
  attempts;
  elapsedMs;
  lastStatus;
  lastResponseSnippet;
  operationId;
  constructor(params) {
    super(
      params.message || `Eventual consistency timeout after ${params.elapsedMs}ms (${params.attempts} attempts)`
    );
    this.name = "EventualConsistencyTimeoutError";
    this.attempts = params.attempts;
    this.elapsedMs = params.elapsedMs;
    this.lastStatus = params.lastStatus;
    this.operationId = params.operationId;
    if (params.lastResponse !== void 0) {
      try {
        const s = typeof params.lastResponse === "string" ? params.lastResponse : JSON.stringify(params.lastResponse);
        this.lastResponseSnippet = s.length > 8192 ? s.slice(0, 8192) + "\u2026[truncated]" : s;
      } catch (_e) {
      }
    }
  }
};

// src/runtime/jobWorker.ts
var JobActionReceipt = "JOB_ACTION_RECEIPT";
var _workerCounter = 0;
var DEFAULT_LONGPOLL_TIMEOUT = 55e3;
var JobWorker = class {
  _client;
  _cfg;
  _name;
  _activeJobs = 0;
  _stopped = false;
  _pollTimer = null;
  _inFlightActivation = null;
  // CancelablePromise-like
  _log;
  constructor(client2, cfg) {
    this._client = client2;
    this._cfg = { pollIntervalMs: 1, autoStart: true, validateSchemas: false, ...cfg };
    this._name = cfg.workerName || `worker-${cfg.jobType}-${++_workerCounter}`;
    this._log = this._client.logger().scope(`worker:${this._name}`);
    if (cfg.maxBackoffTimeMs !== void 0) {
      this._log.debug(() => [
        "worker.config.deprecated",
        { maxBackoffTimeMs: cfg.maxBackoffTimeMs }
      ]);
    }
    if (this._cfg.autoStart) this.start();
  }
  get name() {
    return this._name;
  }
  get activeJobs() {
    return this._activeJobs;
  }
  get stopped() {
    return this._stopped;
  }
  start() {
    if (this._stopped) return;
    if (this._pollTimer) return;
    this._log.info("worker.start");
    this._scheduleNext(0);
  }
  stop() {
    this._stopped = true;
    if (this._pollTimer) clearTimeout(this._pollTimer);
    this._pollTimer = null;
    if (this._inFlightActivation?.cancel) {
      try {
        this._inFlightActivation.cancel();
      } catch {
      }
    }
    this._log.info("worker.stop");
  }
  /**
   * Gracefully stop the worker: prevent new polls, allow any in-flight activation to finish
   * without cancellation, and wait for currently active jobs to drain (be acknowledged) up to waitUpToMs.
   * If timeout is reached, falls back to hard stop logic (cancels activation if still pending).
   */
  async stopGracefully(opts) {
    const waitUpToMs = opts?.waitUpToMs ?? 5e3;
    const checkIntervalMs = opts?.checkIntervalMs ?? 10;
    this._stopped = true;
    if (this._pollTimer) clearTimeout(this._pollTimer);
    this._pollTimer = null;
    const start = Date.now();
    if (this._inFlightActivation) {
      try {
        await Promise.race([
          this._inFlightActivation,
          new Promise(
            (_, rej) => setTimeout(() => rej(new Error("activation.wait.timeout")), waitUpToMs)
          )
        ]);
      } catch (e) {
        if (e && e.message === "activation.wait.timeout") {
          this._log.debug("worker.gracefulStop.activationTimeout");
        }
      }
    }
    while (this._activeJobs > 0 && Date.now() - start < waitUpToMs) {
      await new Promise((r) => setTimeout(r, checkIntervalMs));
    }
    const timedOut = this._activeJobs > 0;
    if (timedOut) {
      if (this._inFlightActivation?.cancel) {
        try {
          this._inFlightActivation.cancel();
        } catch {
        }
      }
      this._log.debug("worker.gracefulStop.timeout", { remaining: this._activeJobs });
    } else {
      this._log.debug("worker.gracefulStop.done");
    }
    return { remainingJobs: this._activeJobs, timedOut };
  }
  _scheduleNext(delayMs) {
    if (this._stopped) return;
    this._pollTimer = setTimeout(() => this._poll(), delayMs);
  }
  async _poll() {
    this._pollTimer = null;
    if (this._stopped) return;
    if (this._activeJobs >= this._cfg.maxParallelJobs) {
      this._scheduleNext(this._cfg.pollIntervalMs);
      return;
    }
    const batchSize = this._cfg.maxParallelJobs - this._activeJobs;
    if (batchSize <= 0) {
      this._scheduleNext(this._cfg.pollIntervalMs);
      return;
    }
    const body = {
      type: this._cfg.jobType,
      worker: this._name,
      maxJobsToActivate: batchSize,
      requestTimeout: this._cfg.pollTimeoutMs ?? DEFAULT_LONGPOLL_TIMEOUT,
      timeout: this._cfg.jobTimeoutMs
    };
    this._log.debug(() => ["activation.request", { batchSize }]);
    let result = [];
    try {
      this._inFlightActivation = this._client.activateJobs(body);
      const activation = await this._inFlightActivation;
      this._inFlightActivation = null;
      result = activation?.jobs || [];
      this._log.debug(() => ["activation.response", { jobs: result.length }]);
    } catch (e) {
      this._inFlightActivation = null;
      if (this._stopped) return;
      if (e?.name === "CancelSdkError") {
        this._log.debug("activation.cancelled");
      } else {
        this._log.error("activation.error", e);
      }
      this._scheduleNext(this._cfg.pollIntervalMs);
      return;
    }
    if (!result || result.length === 0) {
      this._scheduleNext(this._cfg.pollIntervalMs);
      return;
    }
    this._activeJobs += result.length;
    this._scheduleNext(0);
    for (const raw of result) {
      this._handleJob(raw).catch((err) => {
        this._log.error("job.handler.unexpected", err);
      });
    }
  }
  async _handleJob(raw) {
    if (this._stopped) {
      this._decrementOnce();
      return;
    }
    let variables = raw.variables;
    let headers = raw.customHeaders;
    if (this._cfg.validateSchemas) {
      if (this._cfg.inputSchema) {
        const parsed = this._cfg.inputSchema.safeParse(variables);
        if (!parsed.success) {
          this._log.warn("job.validation.variables.failed", parsed.error.flatten());
          await this._failValidation(raw, "Invalid variables");
          return;
        }
        variables = parsed.data;
      }
      if (this._cfg.customHeadersSchema) {
        const parsed = this._cfg.customHeadersSchema.safeParse(headers);
        if (!parsed.success) {
          this._log.warn("job.validation.headers.failed", parsed.error.flatten());
          await this._failValidation(raw, "Invalid custom headers");
          return;
        }
        headers = parsed.data;
      }
    }
    const job = Object.assign(raw, { variables, customHeaders: headers });
    try {
      const receipt = await this._cfg.jobHandler(job);
      if (!job.acknowledged) {
        this._log.warn("job.handler.noAction", { jobKey: raw.jobKey });
      }
      return receipt;
    } catch (e) {
      this._log.error("job.handler.error", e);
      try {
        const retries = raw.retries;
        await this._client.failJob({
          jobKey: raw.jobKey,
          errorMessage: e?.message || "Handler error",
          retries: typeof retries === "number" ? Math.max(0, retries - 1) : 0
        });
      } catch (failErr) {
        this._log.error("job.fail.error", failErr);
      }
      return JobActionReceipt;
    } finally {
      this._decrementOnce();
    }
  }
  async _failValidation(raw, msg) {
    try {
      await this._client.failJob({ jobKey: raw.jobKey, errorMessage: msg });
    } catch (e) {
      this._log.error("job.fail.validation.error", e);
    } finally {
      this._decrementOnce();
    }
  }
  _decrementOnce() {
    this._activeJobs = Math.max(0, this._activeJobs - 1);
  }
};

// src/gen/core/serverSentEvents.gen.ts
var createSseClient = ({
  onRequest,
  onSseError,
  onSseEvent,
  responseTransformer,
  responseValidator,
  sseDefaultRetryDelay,
  sseMaxRetryAttempts,
  sseMaxRetryDelay,
  sseSleepFn,
  url,
  ...options
}) => {
  let lastEventId;
  const sleep2 = sseSleepFn ?? ((ms) => new Promise((resolve) => setTimeout(resolve, ms)));
  const createStream = async function* () {
    let retryDelay = sseDefaultRetryDelay ?? 3e3;
    let attempt = 0;
    const signal = options.signal ?? new AbortController().signal;
    while (true) {
      if (signal.aborted) break;
      attempt++;
      const headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers);
      if (lastEventId !== void 0) {
        headers.set("Last-Event-ID", lastEventId);
      }
      try {
        const requestInit = {
          redirect: "follow",
          ...options,
          body: options.serializedBody,
          headers,
          signal
        };
        let request = new Request(url, requestInit);
        if (onRequest) {
          request = await onRequest(url, requestInit);
        }
        const _fetch = options.fetch ?? globalThis.fetch;
        const response = await _fetch(request);
        if (!response.ok)
          throw new Error(
            `SSE failed: ${response.status} ${response.statusText}`
          );
        if (!response.body) throw new Error("No body in SSE response");
        const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
        let buffer = "";
        const abortHandler = () => {
          try {
            reader.cancel();
          } catch {
          }
        };
        signal.addEventListener("abort", abortHandler);
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += value;
            const chunks = buffer.split("\n\n");
            buffer = chunks.pop() ?? "";
            for (const chunk of chunks) {
              const lines = chunk.split("\n");
              const dataLines = [];
              let eventName;
              for (const line of lines) {
                if (line.startsWith("data:")) {
                  dataLines.push(line.replace(/^data:\s*/, ""));
                } else if (line.startsWith("event:")) {
                  eventName = line.replace(/^event:\s*/, "");
                } else if (line.startsWith("id:")) {
                  lastEventId = line.replace(/^id:\s*/, "");
                } else if (line.startsWith("retry:")) {
                  const parsed = Number.parseInt(
                    line.replace(/^retry:\s*/, ""),
                    10
                  );
                  if (!Number.isNaN(parsed)) {
                    retryDelay = parsed;
                  }
                }
              }
              let data;
              let parsedJson = false;
              if (dataLines.length) {
                const rawData = dataLines.join("\n");
                try {
                  data = JSON.parse(rawData);
                  parsedJson = true;
                } catch {
                  data = rawData;
                }
              }
              if (parsedJson) {
                if (responseValidator) {
                  await responseValidator(data);
                }
                if (responseTransformer) {
                  data = await responseTransformer(data);
                }
              }
              onSseEvent?.({
                data,
                event: eventName,
                id: lastEventId,
                retry: retryDelay
              });
              if (dataLines.length) {
                yield data;
              }
            }
          }
        } finally {
          signal.removeEventListener("abort", abortHandler);
          reader.releaseLock();
        }
        break;
      } catch (error) {
        onSseError?.(error);
        if (sseMaxRetryAttempts !== void 0 && attempt >= sseMaxRetryAttempts) {
          break;
        }
        const backoff = Math.min(
          retryDelay * 2 ** (attempt - 1),
          sseMaxRetryDelay ?? 3e4
        );
        await sleep2(backoff);
      }
    }
  };
  const stream = createStream();
  return { stream };
};

// src/gen/core/auth.gen.ts
var getAuthToken = async (auth, callback) => {
  const token = typeof callback === "function" ? await callback(auth) : callback;
  if (!token) {
    return;
  }
  if (auth.scheme === "bearer") {
    return `Bearer ${token}`;
  }
  if (auth.scheme === "basic") {
    return `Basic ${btoa(token)}`;
  }
  return token;
};

// src/gen/core/bodySerializer.gen.ts
var serializeFormDataPair = (data, key, value) => {
  if (typeof value === "string" || value instanceof Blob) {
    data.append(key, value);
  } else if (value instanceof Date) {
    data.append(key, value.toISOString());
  } else {
    data.append(key, JSON.stringify(value));
  }
};
var formDataBodySerializer = {
  bodySerializer: (body) => {
    const data = new FormData();
    Object.entries(body).forEach(([key, value]) => {
      if (value === void 0 || value === null) {
        return;
      }
      if (Array.isArray(value)) {
        value.forEach((v) => serializeFormDataPair(data, key, v));
      } else {
        serializeFormDataPair(data, key, value);
      }
    });
    return data;
  }
};
var jsonBodySerializer = {
  bodySerializer: (body) => JSON.stringify(
    body,
    (_key, value) => typeof value === "bigint" ? value.toString() : value
  )
};

// src/gen/core/pathSerializer.gen.ts
var separatorArrayExplode = (style) => {
  switch (style) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var separatorArrayNoExplode = (style) => {
  switch (style) {
    case "form":
      return ",";
    case "pipeDelimited":
      return "|";
    case "spaceDelimited":
      return "%20";
    default:
      return ",";
  }
};
var separatorObjectExplode = (style) => {
  switch (style) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var serializeArrayParam = ({
  allowReserved,
  explode,
  name,
  style,
  value
}) => {
  if (!explode) {
    const joinedValues2 = (allowReserved ? value : value.map((v) => encodeURIComponent(v))).join(separatorArrayNoExplode(style));
    switch (style) {
      case "label":
        return `.${joinedValues2}`;
      case "matrix":
        return `;${name}=${joinedValues2}`;
      case "simple":
        return joinedValues2;
      default:
        return `${name}=${joinedValues2}`;
    }
  }
  const separator = separatorArrayExplode(style);
  const joinedValues = value.map((v) => {
    if (style === "label" || style === "simple") {
      return allowReserved ? v : encodeURIComponent(v);
    }
    return serializePrimitiveParam({
      allowReserved,
      name,
      value: v
    });
  }).join(separator);
  return style === "label" || style === "matrix" ? separator + joinedValues : joinedValues;
};
var serializePrimitiveParam = ({
  allowReserved,
  name,
  value
}) => {
  if (value === void 0 || value === null) {
    return "";
  }
  if (typeof value === "object") {
    throw new Error(
      "Deeply-nested arrays/objects aren\u2019t supported. Provide your own `querySerializer()` to handle these."
    );
  }
  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;
};
var serializeObjectParam = ({
  allowReserved,
  explode,
  name,
  style,
  value,
  valueOnly
}) => {
  if (value instanceof Date) {
    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;
  }
  if (style !== "deepObject" && !explode) {
    let values = [];
    Object.entries(value).forEach(([key, v]) => {
      values = [
        ...values,
        key,
        allowReserved ? v : encodeURIComponent(v)
      ];
    });
    const joinedValues2 = values.join(",");
    switch (style) {
      case "form":
        return `${name}=${joinedValues2}`;
      case "label":
        return `.${joinedValues2}`;
      case "matrix":
        return `;${name}=${joinedValues2}`;
      default:
        return joinedValues2;
    }
  }
  const separator = separatorObjectExplode(style);
  const joinedValues = Object.entries(value).map(
    ([key, v]) => serializePrimitiveParam({
      allowReserved,
      name: style === "deepObject" ? `${name}[${key}]` : key,
      value: v
    })
  ).join(separator);
  return style === "label" || style === "matrix" ? separator + joinedValues : joinedValues;
};

// src/gen/core/utils.gen.ts
var PATH_PARAM_RE = /\{[^{}]+\}/g;
var defaultPathSerializer = ({ path: path2, url: _url }) => {
  let url = _url;
  const matches = _url.match(PATH_PARAM_RE);
  if (matches) {
    for (const match of matches) {
      let explode = false;
      let name = match.substring(1, match.length - 1);
      let style = "simple";
      if (name.endsWith("*")) {
        explode = true;
        name = name.substring(0, name.length - 1);
      }
      if (name.startsWith(".")) {
        name = name.substring(1);
        style = "label";
      } else if (name.startsWith(";")) {
        name = name.substring(1);
        style = "matrix";
      }
      const value = path2[name];
      if (value === void 0 || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        url = url.replace(
          match,
          serializeArrayParam({ explode, name, style, value })
        );
        continue;
      }
      if (typeof value === "object") {
        url = url.replace(
          match,
          serializeObjectParam({
            explode,
            name,
            style,
            value,
            valueOnly: true
          })
        );
        continue;
      }
      if (style === "matrix") {
        url = url.replace(
          match,
          `;${serializePrimitiveParam({
            name,
            value
          })}`
        );
        continue;
      }
      const replaceValue = encodeURIComponent(
        style === "label" ? `.${value}` : value
      );
      url = url.replace(match, replaceValue);
    }
  }
  return url;
};
var getUrl = ({
  baseUrl,
  path: path2,
  query,
  querySerializer,
  url: _url
}) => {
  const pathUrl = _url.startsWith("/") ? _url : `/${_url}`;
  let url = (baseUrl ?? "") + pathUrl;
  if (path2) {
    url = defaultPathSerializer({ path: path2, url });
  }
  let search = query ? querySerializer(query) : "";
  if (search.startsWith("?")) {
    search = search.substring(1);
  }
  if (search) {
    url += `?${search}`;
  }
  return url;
};

// src/gen/client/utils.gen.ts
var createQuerySerializer = ({
  allowReserved,
  array,
  object
} = {}) => {
  const querySerializer = (queryParams) => {
    const search = [];
    if (queryParams && typeof queryParams === "object") {
      for (const name in queryParams) {
        const value = queryParams[name];
        if (value === void 0 || value === null) {
          continue;
        }
        if (Array.isArray(value)) {
          const serializedArray = serializeArrayParam({
            allowReserved,
            explode: true,
            name,
            style: "form",
            value,
            ...array
          });
          if (serializedArray) search.push(serializedArray);
        } else if (typeof value === "object") {
          const serializedObject = serializeObjectParam({
            allowReserved,
            explode: true,
            name,
            style: "deepObject",
            value,
            ...object
          });
          if (serializedObject) search.push(serializedObject);
        } else {
          const serializedPrimitive = serializePrimitiveParam({
            allowReserved,
            name,
            value
          });
          if (serializedPrimitive) search.push(serializedPrimitive);
        }
      }
    }
    return search.join("&");
  };
  return querySerializer;
};
var getParseAs = (contentType) => {
  if (!contentType) {
    return "stream";
  }
  const cleanContent = contentType.split(";")[0]?.trim();
  if (!cleanContent) {
    return;
  }
  if (cleanContent.startsWith("application/json") || cleanContent.endsWith("+json")) {
    return "json";
  }
  if (cleanContent === "multipart/form-data") {
    return "formData";
  }
  if (["application/", "audio/", "image/", "video/"].some(
    (type) => cleanContent.startsWith(type)
  )) {
    return "blob";
  }
  if (cleanContent.startsWith("text/")) {
    return "text";
  }
  return;
};
var checkForExistence = (options, name) => {
  if (!name) {
    return false;
  }
  if (options.headers.has(name) || options.query?.[name] || options.headers.get("Cookie")?.includes(`${name}=`)) {
    return true;
  }
  return false;
};
var setAuthParams = async ({
  security,
  ...options
}) => {
  for (const auth of security) {
    if (checkForExistence(options, auth.name)) {
      continue;
    }
    const token = await getAuthToken(auth, options.auth);
    if (!token) {
      continue;
    }
    const name = auth.name ?? "Authorization";
    switch (auth.in) {
      case "query":
        if (!options.query) {
          options.query = {};
        }
        options.query[name] = token;
        break;
      case "cookie":
        options.headers.append("Cookie", `${name}=${token}`);
        break;
      case "header":
      default:
        options.headers.set(name, token);
        break;
    }
  }
};
var buildUrl = (options) => getUrl({
  baseUrl: options.baseUrl,
  path: options.path,
  query: options.query,
  querySerializer: typeof options.querySerializer === "function" ? options.querySerializer : createQuerySerializer(options.querySerializer),
  url: options.url
});
var mergeConfigs = (a, b) => {
  const config = { ...a, ...b };
  if (config.baseUrl?.endsWith("/")) {
    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);
  }
  config.headers = mergeHeaders(a.headers, b.headers);
  return config;
};
var mergeHeaders = (...headers) => {
  const mergedHeaders = new Headers();
  for (const header of headers) {
    if (!header || typeof header !== "object") {
      continue;
    }
    const iterator = header instanceof Headers ? header.entries() : Object.entries(header);
    for (const [key, value] of iterator) {
      if (value === null) {
        mergedHeaders.delete(key);
      } else if (Array.isArray(value)) {
        for (const v of value) {
          mergedHeaders.append(key, v);
        }
      } else if (value !== void 0) {
        mergedHeaders.set(
          key,
          typeof value === "object" ? JSON.stringify(value) : value
        );
      }
    }
  }
  return mergedHeaders;
};
var Interceptors = class {
  _fns;
  constructor() {
    this._fns = [];
  }
  clear() {
    this._fns = [];
  }
  getInterceptorIndex(id) {
    if (typeof id === "number") {
      return this._fns[id] ? id : -1;
    } else {
      return this._fns.indexOf(id);
    }
  }
  exists(id) {
    const index = this.getInterceptorIndex(id);
    return !!this._fns[index];
  }
  eject(id) {
    const index = this.getInterceptorIndex(id);
    if (this._fns[index]) {
      this._fns[index] = null;
    }
  }
  update(id, fn) {
    const index = this.getInterceptorIndex(id);
    if (this._fns[index]) {
      this._fns[index] = fn;
      return id;
    } else {
      return false;
    }
  }
  use(fn) {
    this._fns = [...this._fns, fn];
    return this._fns.length - 1;
  }
};
var createInterceptors = () => ({
  error: new Interceptors(),
  request: new Interceptors(),
  response: new Interceptors()
});
var defaultQuerySerializer = createQuerySerializer({
  allowReserved: false,
  array: {
    explode: true,
    style: "form"
  },
  object: {
    explode: true,
    style: "deepObject"
  }
});
var defaultHeaders = {
  "Content-Type": "application/json"
};
var createConfig = (override = {}) => ({
  ...jsonBodySerializer,
  headers: defaultHeaders,
  parseAs: "auto",
  querySerializer: defaultQuerySerializer,
  ...override
});

// src/gen/client/client.gen.ts
var createClient = (config = {}) => {
  let _config = mergeConfigs(createConfig(), config);
  const getConfig = () => ({ ..._config });
  const setConfig = (config2) => {
    _config = mergeConfigs(_config, config2);
    return getConfig();
  };
  const interceptors = createInterceptors();
  const beforeRequest = async (options) => {
    const opts = {
      ..._config,
      ...options,
      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,
      headers: mergeHeaders(_config.headers, options.headers),
      serializedBody: void 0
    };
    if (opts.security) {
      await setAuthParams({
        ...opts,
        security: opts.security
      });
    }
    if (opts.requestValidator) {
      await opts.requestValidator(opts);
    }
    if (opts.body && opts.bodySerializer) {
      opts.serializedBody = opts.bodySerializer(opts.body);
    }
    if (opts.serializedBody === void 0 || opts.serializedBody === "") {
      opts.headers.delete("Content-Type");
    }
    const url = buildUrl(opts);
    return { opts, url };
  };
  const request = async (options) => {
    const { opts, url } = await beforeRequest(options);
    const requestInit = {
      redirect: "follow",
      ...opts,
      body: opts.serializedBody
    };
    let request2 = new Request(url, requestInit);
    for (const fn of interceptors.request._fns) {
      if (fn) {
        request2 = await fn(request2, opts);
      }
    }
    const _fetch = opts.fetch;
    let response = await _fetch(request2);
    for (const fn of interceptors.response._fns) {
      if (fn) {
        response = await fn(response, request2, opts);
      }
    }
    const result = {
      request: request2,
      response
    };
    if (response.ok) {
      const parseAs = (opts.parseAs === "auto" ? getParseAs(response.headers.get("Content-Type")) : opts.parseAs) ?? "json";
      if (response.status === 204 || response.headers.get("Content-Length") === "0") {
        let emptyData;
        switch (parseAs) {
          case "arrayBuffer":
          case "blob":
          case "text":
            emptyData = await response[parseAs]();
            break;
          case "formData":
            emptyData = new FormData();
            break;
          case "stream":
            emptyData = response.body;
            break;
          case "json":
          default:
            emptyData = {};
            break;
        }
        return opts.responseStyle === "data" ? emptyData : {
          data: emptyData,
          ...result
        };
      }
      let data;
      switch (parseAs) {
        case "arrayBuffer":
        case "blob":
        case "formData":
        case "json":
        case "text":
          data = await response[parseAs]();
          break;
        case "stream":
          return opts.responseStyle === "data" ? response.body : {
            data: response.body,
            ...result
          };
      }
      if (parseAs === "json") {
        if (opts.responseValidator) {
          await opts.responseValidator(data);
        }
        if (opts.responseTransformer) {
          data = await opts.responseTransformer(data);
        }
      }
      return opts.responseStyle === "data" ? data : {
        data,
        ...result
      };
    }
    const textError = await response.text();
    let jsonError;
    try {
      jsonError = JSON.parse(textError);
    } catch {
    }
    const error = jsonError ?? textError;
    let finalError = error;
    for (const fn of interceptors.error._fns) {
      if (fn) {
        finalError = await fn(error, response, request2, opts);
      }
    }
    finalError = finalError || {};
    if (opts.throwOnError) {
      throw finalError;
    }
    return opts.responseStyle === "data" ? void 0 : {
      error: finalError,
      ...result
    };
  };
  const makeMethodFn = (method) => (options) => request({ ...options, method });
  const makeSseFn = (method) => async (options) => {
    const { opts, url } = await beforeRequest(options);
    return createSseClient({
      ...opts,
      body: opts.body,
      headers: opts.headers,
      method,
      onRequest: async (url2, init) => {
        let request2 = new Request(url2, init);
        for (const fn of interceptors.request._fns) {
          if (fn) {
            request2 = await fn(request2, opts);
          }
        }
        return request2;
      },
      url
    });
  };
  return {
    buildUrl,
    connect: makeMethodFn("CONNECT"),
    delete: makeMethodFn("DELETE"),
    get: makeMethodFn("GET"),
    getConfig,
    head: makeMethodFn("HEAD"),
    interceptors,
    options: makeMethodFn("OPTIONS"),
    patch: makeMethodFn("PATCH"),
    post: makeMethodFn("POST"),
    put: makeMethodFn("PUT"),
    request,
    setConfig,
    sse: {
      connect: makeSseFn("CONNECT"),
      delete: makeSseFn("DELETE"),
      get: makeSseFn("GET"),
      head: makeSseFn("HEAD"),
      options: makeSseFn("OPTIONS"),
      patch: makeSseFn("PATCH"),
      post: makeSseFn("POST"),
      put: makeSseFn("PUT"),
      trace: makeSseFn("TRACE")
    },
    trace: makeMethodFn("TRACE")
  };
};

// src/gen/client.gen.ts
var client = createClient(createConfig({
  throwOnError: true
}));

// src/gen/sdk.gen.ts
var getTopology = (options) => {
  return (options?.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/topology",
    ...options
  });
};
var getStatus = (options) => {
  return (options?.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/status",
    ...options
  });
};
var getLicense = (options) => {
  return (options?.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/license",
    ...options
  });
};
var getAuthentication = (options) => {
  return (options?.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    security: [
      {
        scheme: "bearer",
        type: "http"
      }
    ],
    url: "/authentication/me",
    ...options
  });
};
var activateJobs = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/jobs/activation",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchJobs = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/jobs/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var failJob = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/jobs/{jobKey}/failure",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var throwJobError = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/jobs/{jobKey}/error",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var completeJob = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/jobs/{jobKey}/completion",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var updateJob = (options) => {
  return (options.client ?? client).patch({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/jobs/{jobKey}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var resolveIncident = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/incidents/{incidentKey}/resolution",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var createTenant = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var deleteTenant = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}",
    ...options
  });
};
var getTenant = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}",
    ...options
  });
};
var updateTenant = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var unassignUserFromTenant = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/users/{username}",
    ...options
  });
};
var assignUserToTenant = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/users/{username}",
    ...options
  });
};
var searchUsersForTenant = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/users/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchClientsForTenant = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/clients/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchGroupIdsForTenant = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/groups/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchRolesForTenant = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/roles/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var unassignClientFromTenant = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/clients/{clientId}",
    ...options
  });
};
var assignClientToTenant = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/clients/{clientId}",
    ...options
  });
};
var unassignMappingRuleFromTenant = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/mapping-rules/{mappingRuleId}",
    ...options
  });
};
var assignMappingRuleToTenant = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/mapping-rules/{mappingRuleId}",
    ...options
  });
};
var searchMappingRulesForTenant = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/mapping-rules/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var unassignGroupFromTenant = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/groups/{groupId}",
    ...options
  });
};
var assignGroupToTenant = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/groups/{groupId}",
    ...options
  });
};
var unassignRoleFromTenant = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/roles/{roleId}",
    ...options
  });
};
var assignRoleToTenant = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/{tenantId}/roles/{roleId}",
    ...options
  });
};
var searchTenants = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/tenants/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var completeUserTask = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/user-tasks/{userTaskKey}/completion",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var assignUserTask = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/user-tasks/{userTaskKey}/assignment",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var getUserTask = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/user-tasks/{userTaskKey}",
    ...options
  });
};
var updateUserTask = (options) => {
  return (options.client ?? client).patch({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/user-tasks/{userTaskKey}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var getUserTaskForm = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/user-tasks/{userTaskKey}/form",
    ...options
  });
};
var unassignUserTask = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/user-tasks/{userTaskKey}/assignee",
    ...options
  });
};
var searchUserTasks = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/user-tasks/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var searchUserTaskVariables = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/user-tasks/{userTaskKey}/variables/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchVariables = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/variables/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var getVariable = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/variables/{variableKey}",
    ...options
  });
};
var pinClock = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/clock",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var resetClock = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/clock/reset",
    ...options
  });
};
var searchProcessDefinitions = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-definitions/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var getProcessDefinition = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-definitions/{processDefinitionKey}",
    ...options
  });
};
var getProcessDefinitionXml = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-definitions/{processDefinitionKey}/xml",
    ...options
  });
};
var getStartProcessForm = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-definitions/{processDefinitionKey}/form",
    ...options
  });
};
var getProcessDefinitionStatistics = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-definitions/{processDefinitionKey}/statistics/element-instances",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var createProcessInstance = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var getProcessInstance = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances/{processInstanceKey}",
    ...options
  });
};
var getProcessInstanceSequenceFlows = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances/{processInstanceKey}/sequence-flows",
    ...options
  });
};
var getProcessInstanceStatistics = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances/{processInstanceKey}/statistics/element-instances",
    ...options
  });
};
var searchProcessInstances = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var searchProcessInstanceIncidents = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances/{processInstanceKey}/incidents/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var cancelProcessInstance = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances/{processInstanceKey}/cancellation",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var cancelProcessInstancesBatchOperation = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances/cancellation",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var resolveIncidentsBatchOperation = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances/incident-resolution",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var migrateProcessInstancesBatchOperation = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances/migration",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var modifyProcessInstancesBatchOperation = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances/modification",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var migrateProcessInstance = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances/{processInstanceKey}/migration",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var modifyProcessInstance = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances/{processInstanceKey}/modification",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var getProcessInstanceCallHierarchy = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/process-instances/{processInstanceKey}/call-hierarchy",
    ...options
  });
};
var searchElementInstances = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/element-instances/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var getElementInstance = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/element-instances/{elementInstanceKey}",
    ...options
  });
};
var searchDecisionDefinitions = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/decision-definitions/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var getDecisionDefinition = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/decision-definitions/{decisionDefinitionKey}",
    ...options
  });
};
var getDecisionDefinitionXml = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/decision-definitions/{decisionDefinitionKey}/xml",
    ...options
  });
};
var searchDecisionRequirements = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/decision-requirements/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var getDecisionRequirements = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/decision-requirements/{decisionRequirementsKey}",
    ...options
  });
};
var getDecisionRequirementsXml = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/decision-requirements/{decisionRequirementsKey}/xml",
    ...options
  });
};
var searchDecisionInstances = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/decision-instances/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var getDecisionInstance = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/decision-instances/{decisionEvaluationInstanceKey}",
    ...options
  });
};
var evaluateDecision = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/decision-definitions/evaluation",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var createAuthorization = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/authorizations",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var deleteAuthorization = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/authorizations/{authorizationKey}",
    ...options
  });
};
var getAuthorization = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/authorizations/{authorizationKey}",
    ...options
  });
};
var updateAuthorization = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/authorizations/{authorizationKey}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchAuthorizations = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/authorizations/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var createRole = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var deleteRole = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}",
    ...options
  });
};
var getRole = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}",
    ...options
  });
};
var updateRole = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchUsersForRole = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}/users/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchClientsForRole = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}/clients/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var unassignRoleFromUser = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}/users/{username}",
    ...options
  });
};
var assignRoleToUser = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}/users/{username}",
    ...options
  });
};
var unassignRoleFromClient = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}/clients/{clientId}",
    ...options
  });
};
var assignRoleToClient = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}/clients/{clientId}",
    ...options
  });
};
var searchRoles = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var unassignRoleFromGroup = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}/groups/{groupId}",
    ...options
  });
};
var assignRoleToGroup = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}/groups/{groupId}",
    ...options
  });
};
var searchGroupsForRole = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}/groups/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var unassignRoleFromMappingRule = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}/mapping-rules/{mappingRuleId}",
    ...options
  });
};
var assignRoleToMappingRule = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}/mapping-rules/{mappingRuleId}",
    ...options
  });
};
var searchMappingRulesForRole = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/roles/{roleId}/mapping-rules/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var createGroup = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var deleteGroup = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/{groupId}",
    ...options
  });
};
var getGroup = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/{groupId}",
    ...options
  });
};
var updateGroup = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/{groupId}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchUsersForGroup = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/{groupId}/users/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchMappingRulesForGroup = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/{groupId}/mapping-rules/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchRolesForGroup = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/{groupId}/roles/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchClientsForGroup = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/{groupId}/clients/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var unassignUserFromGroup = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/{groupId}/users/{username}",
    ...options
  });
};
var assignUserToGroup = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/{groupId}/users/{username}",
    ...options
  });
};
var unassignClientFromGroup = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/{groupId}/clients/{clientId}",
    ...options
  });
};
var assignClientToGroup = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/{groupId}/clients/{clientId}",
    ...options
  });
};
var unassignMappingRuleFromGroup = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/{groupId}/mapping-rules/{mappingRuleId}",
    ...options
  });
};
var assignMappingRuleToGroup = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/{groupId}/mapping-rules/{mappingRuleId}",
    ...options
  });
};
var searchGroups = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/groups/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var createMappingRule = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/mapping-rules",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var deleteMappingRule = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/mapping-rules/{mappingRuleId}",
    ...options
  });
};
var getMappingRule = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/mapping-rules/{mappingRuleId}",
    ...options
  });
};
var updateMappingRule = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/mapping-rules/{mappingRuleId}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchMappingRule = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/mapping-rules/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var publishMessage = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/messages/publication",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var correlateMessage = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/messages/correlation",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchCorrelatedMessageSubscriptions = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/correlated-message-subscriptions/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var searchMessageSubscriptions = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/message-subscriptions/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var createDocument = (options) => {
  return (options.client ?? client).post({
    ...formDataBodySerializer,
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/documents",
    ...options,
    headers: {
      "Content-Type": null,
      ...options.headers
    }
  });
};
var createDocuments = (options) => {
  return (options.client ?? client).post({
    ...formDataBodySerializer,
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/documents/batch",
    ...options,
    headers: {
      "Content-Type": null,
      ...options.headers
    }
  });
};
var deleteDocument = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/documents/{documentId}",
    ...options
  });
};
var getDocument = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/documents/{documentId}",
    ...options
  });
};
var createDocumentLink = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/documents/{documentId}/links",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var createUser = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/users",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchUsers = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/users/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var deleteUser = (options) => {
  return (options.client ?? client).delete({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/users/{username}",
    ...options
  });
};
var getUser = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/users/{username}",
    ...options
  });
};
var updateUser = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/users/{username}",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var createAdminUser = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/setup/user",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchIncidents = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/incidents/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var getIncident = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/incidents/{incidentKey}",
    ...options
  });
};
var getUsageMetrics = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/system/usage-metrics",
    ...options
  });
};
var createDeployment = (options) => {
  return (options.client ?? client).post({
    ...formDataBodySerializer,
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/deployments",
    ...options,
    headers: {
      "Content-Type": null,
      ...options.headers
    }
  });
};
var deleteResource = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    url: "/resources/{resourceKey}/deletion",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var getResource = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/resources/{resourceKey}",
    ...options
  });
};
var getResourceContent = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/resources/{resourceKey}/content",
    ...options
  });
};
var createElementInstanceVariables = (options) => {
  return (options.client ?? client).put({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/element-instances/{elementInstanceKey}/variables",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var activateAdHocSubProcessActivities = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/element-instances/ad-hoc-activities/{adHocSubProcessInstanceKey}/activation",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var broadcastSignal = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/signals/broadcast",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var getBatchOperation = (options) => {
  return (options.client ?? client).get({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/batch-operations/{batchOperationKey}",
    ...options
  });
};
var searchBatchOperations = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/batch-operations/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var cancelBatchOperation = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/batch-operations/{batchOperationKey}/cancellation",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var suspendBatchOperation = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/batch-operations/{batchOperationKey}/suspension",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var resumeBatchOperation = (options) => {
  return (options.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/batch-operations/{batchOperationKey}/resumption",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers
    }
  });
};
var searchBatchOperationItems = (options) => {
  return (options?.client ?? client).post({
    requestValidator: void 0,
    responseValidator: void 0,
    url: "/batch-operation-items/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};

// src/gen/zod.gen.ts
var zod_gen_exports = {};
__export(zod_gen_exports, {
  zActivateAdHocSubProcessActivitiesData: () => zActivateAdHocSubProcessActivitiesData,
  zActivateAdHocSubProcessActivitiesResponse: () => zActivateAdHocSubProcessActivitiesResponse,
  zActivateJobsData: () => zActivateJobsData,
  zActivateJobsResponse: () => zActivateJobsResponse,
  zActivatedJobResult: () => zActivatedJobResult,
  zAdHocSubProcessActivateActivitiesInstruction: () => zAdHocSubProcessActivateActivitiesInstruction,
  zAdHocSubProcessActivateActivityReference: () => zAdHocSubProcessActivateActivityReference,
  zAdvancedBatchOperationItemStateFilter: () => zAdvancedBatchOperationItemStateFilter,
  zAdvancedBatchOperationStateFilter: () => zAdvancedBatchOperationStateFilter,
  zAdvancedBatchOperationTypeFilter: () => zAdvancedBatchOperationTypeFilter,
  zAdvancedDateTimeFilter: () => zAdvancedDateTimeFilter,
  zAdvancedDecisionDefinitionKeyFilter: () => zAdvancedDecisionDefinitionKeyFilter,
  zAdvancedElementInstanceKeyFilter: () => zAdvancedElementInstanceKeyFilter,
  zAdvancedElementInstanceStateFilter: () => zAdvancedElementInstanceStateFilter,
  zAdvancedIntegerFilter: () => zAdvancedIntegerFilter,
  zAdvancedJobKeyFilter: () => zAdvancedJobKeyFilter,
  zAdvancedJobKindFilter: () => zAdvancedJobKindFilter,
  zAdvancedJobListenerEventTypeFilter: () => zAdvancedJobListenerEventTypeFilter,
  zAdvancedJobStateFilter: () => zAdvancedJobStateFilter,
  zAdvancedMessageSubscriptionKeyFilter: () => zAdvancedMessageSubscriptionKeyFilter,
  zAdvancedMessageSubscriptionStateFilter: () => zAdvancedMessageSubscriptionStateFilter,
  zAdvancedProcessDefinitionKeyFilter: () => zAdvancedProcessDefinitionKeyFilter,
  zAdvancedProcessInstanceKeyFilter: () => zAdvancedProcessInstanceKeyFilter,
  zAdvancedProcessInstanceStateFilter: () => zAdvancedProcessInstanceStateFilter,
  zAdvancedScopeKeyFilter: () => zAdvancedScopeKeyFilter,
  zAdvancedStringFilter: () => zAdvancedStringFilter,
  zAdvancedUserTaskStateFilter: () => zAdvancedUserTaskStateFilter,
  zAdvancedVariableKeyFilter: () => zAdvancedVariableKeyFilter,
  zAssignClientToGroupData: () => zAssignClientToGroupData,
  zAssignClientToGroupResponse: () => zAssignClientToGroupResponse,
  zAssignClientToTenantData: () => zAssignClientToTenantData,
  zAssignClientToTenantResponse: () => zAssignClientToTenantResponse,
  zAssignGroupToTenantData: () => zAssignGroupToTenantData,
  zAssignGroupToTenantResponse: () => zAssignGroupToTenantResponse,
  zAssignMappingRuleToGroupData: () => zAssignMappingRuleToGroupData,
  zAssignMappingRuleToGroupResponse: () => zAssignMappingRuleToGroupResponse,
  zAssignMappingRuleToTenantData: () => zAssignMappingRuleToTenantData,
  zAssignMappingRuleToTenantResponse: () => zAssignMappingRuleToTenantResponse,
  zAssignRoleToClientData: () => zAssignRoleToClientData,
  zAssignRoleToClientResponse: () => zAssignRoleToClientResponse,
  zAssignRoleToGroupData: () => zAssignRoleToGroupData,
  zAssignRoleToGroupResponse: () => zAssignRoleToGroupResponse,
  zAssignRoleToMappingRuleData: () => zAssignRoleToMappingRuleData,
  zAssignRoleToMappingRuleResponse: () => zAssignRoleToMappingRuleResponse,
  zAssignRoleToTenantData: () => zAssignRoleToTenantData,
  zAssignRoleToTenantResponse: () => zAssignRoleToTenantResponse,
  zAssignRoleToUserData: () => zAssignRoleToUserData,
  zAssignRoleToUserResponse: () => zAssignRoleToUserResponse,
  zAssignUserTaskData: () => zAssignUserTaskData,
  zAssignUserTaskResponse: () => zAssignUserTaskResponse,
  zAssignUserToGroupData: () => zAssignUserToGroupData,
  zAssignUserToGroupResponse: () => zAssignUserToGroupResponse,
  zAssignUserToTenantData: () => zAssignUserToTenantData,
  zAssignUserToTenantResponse: () => zAssignUserToTenantResponse,
  zAuthorizationCreateResult: () => zAuthorizationCreateResult,
  zAuthorizationFilter: () => zAuthorizationFilter,
  zAuthorizationKey: () => zAuthorizationKey,
  zAuthorizationRequest: () => zAuthorizationRequest,
  zAuthorizationResult: () => zAuthorizationResult,
  zAuthorizationSearchQuery: () => zAuthorizationSearchQuery,
  zAuthorizationSearchQuerySortRequest: () => zAuthorizationSearchQuerySortRequest,
  zAuthorizationSearchResult: () => zAuthorizationSearchResult,
  zBaseProcessInstanceFilterFields: () => zBaseProcessInstanceFilterFields,
  zBasicStringFilter: () => zBasicStringFilter,
  zBasicStringFilterProperty: () => zBasicStringFilterProperty,
  zBatchOperationCreatedResult: () => zBatchOperationCreatedResult,
  zBatchOperationError: () => zBatchOperationError,
  zBatchOperationFilter: () => zBatchOperationFilter,
  zBatchOperationItemFilter: () => zBatchOperationItemFilter,
  zBatchOperationItemResponse: () => zBatchOperationItemResponse,
  zBatchOperationItemSearchQuery: () => zBatchOperationItemSearchQuery,
  zBatchOperationItemSearchQueryResult: () => zBatchOperationItemSearchQueryResult,
  zBatchOperationItemSearchQuerySortRequest: () => zBatchOperationItemSearchQuerySortRequest,
  zBatchOperationItemStateEnum: () => zBatchOperationItemStateEnum,
  zBatchOperationItemStateFilterProperty: () => zBatchOperationItemStateFilterProperty,
  zBatchOperationKey: () => zBatchOperationKey,
  zBatchOperationResponse: () => zBatchOperationResponse,
  zBatchOperationSearchQuery: () => zBatchOperationSearchQuery,
  zBatchOperationSearchQueryResult: () => zBatchOperationSearchQueryResult,
  zBatchOperationSearchQuerySortRequest: () => zBatchOperationSearchQuerySortRequest,
  zBatchOperationStateEnum: () => zBatchOperationStateEnum,
  zBatchOperationStateFilterProperty: () => zBatchOperationStateFilterProperty,
  zBatchOperationTypeEnum: () => zBatchOperationTypeEnum,
  zBatchOperationTypeFilterProperty: () => zBatchOperationTypeFilterProperty,
  zBroadcastSignalData: () => zBroadcastSignalData,
  zBroadcastSignalResponse: () => zBroadcastSignalResponse,
  zBrokerInfo: () => zBrokerInfo,
  zCamundaUserResult: () => zCamundaUserResult,
  zCancelBatchOperationData: () => zCancelBatchOperationData,
  zCancelBatchOperationResponse: () => zCancelBatchOperationResponse,
  zCancelProcessInstanceData: () => zCancelProcessInstanceData,
  zCancelProcessInstanceRequest: () => zCancelProcessInstanceRequest,
  zCancelProcessInstanceResponse: () => zCancelProcessInstanceResponse,
  zCancelProcessInstancesBatchOperationData: () => zCancelProcessInstancesBatchOperationData,
  zCancelProcessInstancesBatchOperationResponse: () => zCancelProcessInstancesBatchOperationResponse,
  zChangeset: () => zChangeset,
  zClockPinRequest: () => zClockPinRequest,
  zCompleteJobData: () => zCompleteJobData,
  zCompleteJobResponse: () => zCompleteJobResponse,
  zCompleteUserTaskData: () => zCompleteUserTaskData,
  zCompleteUserTaskResponse: () => zCompleteUserTaskResponse,
  zCorrelateMessageData: () => zCorrelateMessageData,
  zCorrelateMessageResponse: () => zCorrelateMessageResponse,
  zCorrelatedMessageSubscriptionFilter: () => zCorrelatedMessageSubscriptionFilter,
  zCorrelatedMessageSubscriptionResult: () => zCorrelatedMessageSubscriptionResult,
  zCorrelatedMessageSubscriptionSearchQuery: () => zCorrelatedMessageSubscriptionSearchQuery,
  zCorrelatedMessageSubscriptionSearchQueryResult: () => zCorrelatedMessageSubscriptionSearchQueryResult,
  zCorrelatedMessageSubscriptionSearchQuerySortRequest: () => zCorrelatedMessageSubscriptionSearchQuerySortRequest,
  zCreateAdminUserData: () => zCreateAdminUserData,
  zCreateAdminUserResponse: () => zCreateAdminUserResponse,
  zCreateAuthorizationData: () => zCreateAuthorizationData,
  zCreateAuthorizationResponse: () => zCreateAuthorizationResponse,
  zCreateDeploymentData: () => zCreateDeploymentData,
  zCreateDeploymentResponse: () => zCreateDeploymentResponse,
  zCreateDocumentData: () => zCreateDocumentData,
  zCreateDocumentLinkData: () => zCreateDocumentLinkData,
  zCreateDocumentLinkResponse: () => zCreateDocumentLinkResponse,
  zCreateDocumentResponse: () => zCreateDocumentResponse,
  zCreateDocumentsData: () => zCreateDocumentsData,
  zCreateDocumentsResponse: () => zCreateDocumentsResponse,
  zCreateElementInstanceVariablesData: () => zCreateElementInstanceVariablesData,
  zCreateElementInstanceVariablesResponse: () => zCreateElementInstanceVariablesResponse,
  zCreateGroupData: () => zCreateGroupData,
  zCreateGroupResponse: () => zCreateGroupResponse,
  zCreateMappingRuleData: () => zCreateMappingRuleData,
  zCreateMappingRuleResponse: () => zCreateMappingRuleResponse,
  zCreateProcessInstanceData: () => zCreateProcessInstanceData,
  zCreateProcessInstanceResponse: () => zCreateProcessInstanceResponse,
  zCreateProcessInstanceResult: () => zCreateProcessInstanceResult,
  zCreateRoleData: () => zCreateRoleData,
  zCreateRoleResponse: () => zCreateRoleResponse,
  zCreateTenantData: () => zCreateTenantData,
  zCreateTenantResponse: () => zCreateTenantResponse,
  zCreateUserData: () => zCreateUserData,
  zCreateUserResponse: () => zCreateUserResponse,
  zCursorBackwardPagination: () => zCursorBackwardPagination,
  zCursorForwardPagination: () => zCursorForwardPagination,
  zDateTimeFilterProperty: () => zDateTimeFilterProperty,
  zDecisionDefinitionFilter: () => zDecisionDefinitionFilter,
  zDecisionDefinitionId: () => zDecisionDefinitionId,
  zDecisionDefinitionKey: () => zDecisionDefinitionKey,
  zDecisionDefinitionKeyFilterProperty: () => zDecisionDefinitionKeyFilterProperty,
  zDecisionDefinitionResult: () => zDecisionDefinitionResult,
  zDecisionDefinitionSearchQuery: () => zDecisionDefinitionSearchQuery,
  zDecisionDefinitionSearchQueryResult: () => zDecisionDefinitionSearchQueryResult,
  zDecisionDefinitionSearchQuerySortRequest: () => zDecisionDefinitionSearchQuerySortRequest,
  zDecisionDefinitionTypeEnum: () => zDecisionDefinitionTypeEnum,
  zDecisionEvaluationById: () => zDecisionEvaluationById,
  zDecisionEvaluationByKey: () => zDecisionEvaluationByKey,
  zDecisionEvaluationInstanceKey: () => zDecisionEvaluationInstanceKey,
  zDecisionEvaluationInstruction: () => zDecisionEvaluationInstruction,
  zDecisionEvaluationKey: () => zDecisionEvaluationKey,
  zDecisionInstanceFilter: () => zDecisionInstanceFilter,
  zDecisionInstanceGetQueryResult: () => zDecisionInstanceGetQueryResult,
  zDecisionInstanceKey: () => zDecisionInstanceKey,
  zDecisionInstanceResult: () => zDecisionInstanceResult,
  zDecisionInstanceSearchQuery: () => zDecisionInstanceSearchQuery,
  zDecisionInstanceSearchQueryResult: () => zDecisionInstanceSearchQueryResult,
  zDecisionInstanceSearchQuerySortRequest: () => zDecisionInstanceSearchQuerySortRequest,
  zDecisionInstanceStateEnum: () => zDecisionInstanceStateEnum,
  zDecisionRequirementsFilter: () => zDecisionRequirementsFilter,
  zDecisionRequirementsKey: () => zDecisionRequirementsKey,
  zDecisionRequirementsResult: () => zDecisionRequirementsResult,
  zDecisionRequirementsSearchQuery: () => zDecisionRequirementsSearchQuery,
  zDecisionRequirementsSearchQueryResult: () => zDecisionRequirementsSearchQueryResult,
  zDecisionRequirementsSearchQuerySortRequest: () => zDecisionRequirementsSearchQuerySortRequest,
  zDeleteAuthorizationData: () => zDeleteAuthorizationData,
  zDeleteAuthorizationResponse: () => zDeleteAuthorizationResponse,
  zDeleteDocumentData: () => zDeleteDocumentData,
  zDeleteDocumentResponse: () => zDeleteDocumentResponse,
  zDeleteGroupData: () => zDeleteGroupData,
  zDeleteGroupResponse: () => zDeleteGroupResponse,
  zDeleteMappingRuleData: () => zDeleteMappingRuleData,
  zDeleteMappingRuleResponse: () => zDeleteMappingRuleResponse,
  zDeleteResourceData: () => zDeleteResourceData,
  zDeleteResourceRequest: () => zDeleteResourceRequest,
  zDeleteRoleData: () => zDeleteRoleData,
  zDeleteRoleResponse: () => zDeleteRoleResponse,
  zDeleteTenantData: () => zDeleteTenantData,
  zDeleteTenantResponse: () => zDeleteTenantResponse,
  zDeleteUserData: () => zDeleteUserData,
  zDeleteUserResponse: () => zDeleteUserResponse,
  zDeploymentDecisionRequirementsResult: () => zDeploymentDecisionRequirementsResult,
  zDeploymentDecisionResult: () => zDeploymentDecisionResult,
  zDeploymentFormResult: () => zDeploymentFormResult,
  zDeploymentKey: () => zDeploymentKey,
  zDeploymentMetadataResult: () => zDeploymentMetadataResult,
  zDeploymentProcessResult: () => zDeploymentProcessResult,
  zDeploymentResourceResult: () => zDeploymentResourceResult,
  zDeploymentResult: () => zDeploymentResult,
  zDocumentCreationBatchResponse: () => zDocumentCreationBatchResponse,
  zDocumentCreationFailureDetail: () => zDocumentCreationFailureDetail,
  zDocumentId: () => zDocumentId,
  zDocumentLink: () => zDocumentLink,
  zDocumentLinkRequest: () => zDocumentLinkRequest,
  zDocumentMetadata: () => zDocumentMetadata,
  zDocumentReference: () => zDocumentReference,
  zElementId: () => zElementId,
  zElementInstanceFilter: () => zElementInstanceFilter,
  zElementInstanceKey: () => zElementInstanceKey,
  zElementInstanceKeyFilterProperty: () => zElementInstanceKeyFilterProperty,
  zElementInstanceResult: () => zElementInstanceResult,
  zElementInstanceSearchQuery: () => zElementInstanceSearchQuery,
  zElementInstanceSearchQueryResult: () => zElementInstanceSearchQueryResult,
  zElementInstanceSearchQuerySortRequest: () => zElementInstanceSearchQuerySortRequest,
  zElementInstanceStateEnum: () => zElementInstanceStateEnum,
  zElementInstanceStateFilterProperty: () => zElementInstanceStateFilterProperty,
  zEndCursor: () => zEndCursor,
  zEvaluateDecisionData: () => zEvaluateDecisionData,
  zEvaluateDecisionResponse: () => zEvaluateDecisionResponse,
  zEvaluateDecisionResult: () => zEvaluateDecisionResult,
  zEvaluatedDecisionInputItem: () => zEvaluatedDecisionInputItem,
  zEvaluatedDecisionOutputItem: () => zEvaluatedDecisionOutputItem,
  zEvaluatedDecisionResult: () => zEvaluatedDecisionResult,
  zFailJobData: () => zFailJobData,
  zFailJobResponse: () => zFailJobResponse,
  zFormId: () => zFormId,
  zFormKey: () => zFormKey,
  zFormResult: () => zFormResult,
  zGetAuthenticationData: () => zGetAuthenticationData,
  zGetAuthenticationResponse: () => zGetAuthenticationResponse,
  zGetAuthorizationData: () => zGetAuthorizationData,
  zGetAuthorizationResponse: () => zGetAuthorizationResponse,
  zGetBatchOperationData: () => zGetBatchOperationData,
  zGetBatchOperationResponse: () => zGetBatchOperationResponse,
  zGetDecisionDefinitionData: () => zGetDecisionDefinitionData,
  zGetDecisionDefinitionResponse: () => zGetDecisionDefinitionResponse,
  zGetDecisionDefinitionXmlData: () => zGetDecisionDefinitionXmlData,
  zGetDecisionDefinitionXmlResponse: () => zGetDecisionDefinitionXmlResponse,
  zGetDecisionInstanceData: () => zGetDecisionInstanceData,
  zGetDecisionInstanceResponse: () => zGetDecisionInstanceResponse,
  zGetDecisionRequirementsData: () => zGetDecisionRequirementsData,
  zGetDecisionRequirementsResponse: () => zGetDecisionRequirementsResponse,
  zGetDecisionRequirementsXmlData: () => zGetDecisionRequirementsXmlData,
  zGetDecisionRequirementsXmlResponse: () => zGetDecisionRequirementsXmlResponse,
  zGetDocumentData: () => zGetDocumentData,
  zGetDocumentResponse: () => zGetDocumentResponse,
  zGetElementInstanceData: () => zGetElementInstanceData,
  zGetElementInstanceResponse: () => zGetElementInstanceResponse,
  zGetGroupData: () => zGetGroupData,
  zGetGroupResponse: () => zGetGroupResponse,
  zGetIncidentData: () => zGetIncidentData,
  zGetIncidentResponse: () => zGetIncidentResponse,
  zGetLicenseData: () => zGetLicenseData,
  zGetLicenseResponse: () => zGetLicenseResponse,
  zGetMappingRuleData: () => zGetMappingRuleData,
  zGetMappingRuleResponse: () => zGetMappingRuleResponse,
  zGetProcessDefinitionData: () => zGetProcessDefinitionData,
  zGetProcessDefinitionResponse: () => zGetProcessDefinitionResponse,
  zGetProcessDefinitionStatisticsData: () => zGetProcessDefinitionStatisticsData,
  zGetProcessDefinitionStatisticsResponse: () => zGetProcessDefinitionStatisticsResponse,
  zGetProcessDefinitionXmlData: () => zGetProcessDefinitionXmlData,
  zGetProcessDefinitionXmlResponse: () => zGetProcessDefinitionXmlResponse,
  zGetProcessInstanceCallHierarchyData: () => zGetProcessInstanceCallHierarchyData,
  zGetProcessInstanceCallHierarchyResponse: () => zGetProcessInstanceCallHierarchyResponse,
  zGetProcessInstanceData: () => zGetProcessInstanceData,
  zGetProcessInstanceResponse: () => zGetProcessInstanceResponse,
  zGetProcessInstanceSequenceFlowsData: () => zGetProcessInstanceSequenceFlowsData,
  zGetProcessInstanceSequenceFlowsResponse: () => zGetProcessInstanceSequenceFlowsResponse,
  zGetProcessInstanceStatisticsData: () => zGetProcessInstanceStatisticsData,
  zGetProcessInstanceStatisticsResponse: () => zGetProcessInstanceStatisticsResponse,
  zGetResourceContentData: () => zGetResourceContentData,
  zGetResourceContentResponse: () => zGetResourceContentResponse,
  zGetResourceData: () => zGetResourceData,
  zGetResourceResponse: () => zGetResourceResponse,
  zGetRoleData: () => zGetRoleData,
  zGetRoleResponse: () => zGetRoleResponse,
  zGetStartProcessFormData: () => zGetStartProcessFormData,
  zGetStartProcessFormResponse: () => zGetStartProcessFormResponse,
  zGetStatusData: () => zGetStatusData,
  zGetStatusResponse: () => zGetStatusResponse,
  zGetTenantData: () => zGetTenantData,
  zGetTenantResponse: () => zGetTenantResponse,
  zGetTopologyData: () => zGetTopologyData,
  zGetTopologyResponse: () => zGetTopologyResponse,
  zGetUsageMetricsData: () => zGetUsageMetricsData,
  zGetUsageMetricsResponse: () => zGetUsageMetricsResponse,
  zGetUserData: () => zGetUserData,
  zGetUserResponse: () => zGetUserResponse,
  zGetUserTaskData: () => zGetUserTaskData,
  zGetUserTaskFormData: () => zGetUserTaskFormData,
  zGetUserTaskFormResponse: () => zGetUserTaskFormResponse,
  zGetUserTaskResponse: () => zGetUserTaskResponse,
  zGetVariableData: () => zGetVariableData,
  zGetVariableResponse: () => zGetVariableResponse,
  zGroupClientResult: () => zGroupClientResult,
  zGroupClientSearchQueryRequest: () => zGroupClientSearchQueryRequest,
  zGroupClientSearchQuerySortRequest: () => zGroupClientSearchQuerySortRequest,
  zGroupClientSearchResult: () => zGroupClientSearchResult,
  zGroupCreateRequest: () => zGroupCreateRequest,
  zGroupCreateResult: () => zGroupCreateResult,
  zGroupFilter: () => zGroupFilter,
  zGroupResult: () => zGroupResult,
  zGroupSearchQueryRequest: () => zGroupSearchQueryRequest,
  zGroupSearchQueryResult: () => zGroupSearchQueryResult,
  zGroupSearchQuerySortRequest: () => zGroupSearchQuerySortRequest,
  zGroupUpdateRequest: () => zGroupUpdateRequest,
  zGroupUpdateResult: () => zGroupUpdateResult,
  zGroupUserResult: () => zGroupUserResult,
  zGroupUserSearchQueryRequest: () => zGroupUserSearchQueryRequest,
  zGroupUserSearchQuerySortRequest: () => zGroupUserSearchQuerySortRequest,
  zGroupUserSearchResult: () => zGroupUserSearchResult,
  zIncidentFilter: () => zIncidentFilter,
  zIncidentKey: () => zIncidentKey,
  zIncidentResolutionRequest: () => zIncidentResolutionRequest,
  zIncidentResult: () => zIncidentResult,
  zIncidentSearchQuery: () => zIncidentSearchQuery,
  zIncidentSearchQueryResult: () => zIncidentSearchQueryResult,
  zIncidentSearchQuerySortRequest: () => zIncidentSearchQuerySortRequest,
  zIntegerFilterProperty: () => zIntegerFilterProperty,
  zJobActivationRequest: () => zJobActivationRequest,
  zJobActivationResult: () => zJobActivationResult,
  zJobChangeset: () => zJobChangeset,
  zJobCompletionRequest: () => zJobCompletionRequest,
  zJobErrorRequest: () => zJobErrorRequest,
  zJobFailRequest: () => zJobFailRequest,
  zJobFilter: () => zJobFilter,
  zJobKey: () => zJobKey,
  zJobKeyFilterProperty: () => zJobKeyFilterProperty,
  zJobKindEnum: () => zJobKindEnum,
  zJobKindFilterProperty: () => zJobKindFilterProperty,
  zJobListenerEventTypeEnum: () => zJobListenerEventTypeEnum,
  zJobListenerEventTypeFilterProperty: () => zJobListenerEventTypeFilterProperty,
  zJobResult: () => zJobResult,
  zJobResultActivateElement: () => zJobResultActivateElement,
  zJobResultAdHocSubProcess: () => zJobResultAdHocSubProcess,
  zJobResultCorrections: () => zJobResultCorrections,
  zJobResultUserTask: () => zJobResultUserTask,
  zJobSearchQuery: () => zJobSearchQuery,
  zJobSearchQueryResult: () => zJobSearchQueryResult,
  zJobSearchQuerySortRequest: () => zJobSearchQuerySortRequest,
  zJobSearchResult: () => zJobSearchResult,
  zJobStateEnum: () => zJobStateEnum,
  zJobStateFilterProperty: () => zJobStateFilterProperty,
  zJobUpdateRequest: () => zJobUpdateRequest,
  zLicenseResponse: () => zLicenseResponse,
  zLikeFilter: () => zLikeFilter,
  zLongKey: () => zLongKey,
  zMappingRuleCreateRequest: () => zMappingRuleCreateRequest,
  zMappingRuleCreateResult: () => zMappingRuleCreateResult,
  zMappingRuleCreateUpdateRequest: () => zMappingRuleCreateUpdateRequest,
  zMappingRuleCreateUpdateResult: () => zMappingRuleCreateUpdateResult,
  zMappingRuleFilter: () => zMappingRuleFilter,
  zMappingRuleResult: () => zMappingRuleResult,
  zMappingRuleSearchQueryRequest: () => zMappingRuleSearchQueryRequest,
  zMappingRuleSearchQueryResult: () => zMappingRuleSearchQueryResult,
  zMappingRuleSearchQuerySortRequest: () => zMappingRuleSearchQuerySortRequest,
  zMappingRuleUpdateRequest: () => zMappingRuleUpdateRequest,
  zMappingRuleUpdateResult: () => zMappingRuleUpdateResult,
  zMatchedDecisionRuleItem: () => zMatchedDecisionRuleItem,
  zMessageCorrelationKey: () => zMessageCorrelationKey,
  zMessageCorrelationRequest: () => zMessageCorrelationRequest,
  zMessageCorrelationResult: () => zMessageCorrelationResult,
  zMessageKey: () => zMessageKey,
  zMessagePublicationRequest: () => zMessagePublicationRequest,
  zMessagePublicationResult: () => zMessagePublicationResult,
  zMessageSubscriptionFilter: () => zMessageSubscriptionFilter,
  zMessageSubscriptionKey: () => zMessageSubscriptionKey,
  zMessageSubscriptionKeyFilterProperty: () => zMessageSubscriptionKeyFilterProperty,
  zMessageSubscriptionResult: () => zMessageSubscriptionResult,
  zMessageSubscriptionSearchQuery: () => zMessageSubscriptionSearchQuery,
  zMessageSubscriptionSearchQueryResult: () => zMessageSubscriptionSearchQueryResult,
  zMessageSubscriptionSearchQuerySortRequest: () => zMessageSubscriptionSearchQuerySortRequest,
  zMessageSubscriptionStateEnum: () => zMessageSubscriptionStateEnum,
  zMessageSubscriptionStateFilterProperty: () => zMessageSubscriptionStateFilterProperty,
  zMigrateProcessInstanceData: () => zMigrateProcessInstanceData,
  zMigrateProcessInstanceMappingInstruction: () => zMigrateProcessInstanceMappingInstruction,
  zMigrateProcessInstanceResponse: () => zMigrateProcessInstanceResponse,
  zMigrateProcessInstancesBatchOperationData: () => zMigrateProcessInstancesBatchOperationData,
  zMigrateProcessInstancesBatchOperationResponse: () => zMigrateProcessInstancesBatchOperationResponse,
  zModifyProcessInstanceData: () => zModifyProcessInstanceData,
  zModifyProcessInstanceResponse: () => zModifyProcessInstanceResponse,
  zModifyProcessInstanceVariableInstruction: () => zModifyProcessInstanceVariableInstruction,
  zModifyProcessInstancesBatchOperationData: () => zModifyProcessInstancesBatchOperationData,
  zModifyProcessInstancesBatchOperationResponse: () => zModifyProcessInstancesBatchOperationResponse,
  zOffsetPagination: () => zOffsetPagination,
  zOperationReference: () => zOperationReference,
  zOwnerTypeEnum: () => zOwnerTypeEnum,
  zPartition: () => zPartition,
  zPermissionTypeEnum: () => zPermissionTypeEnum,
  zPinClockData: () => zPinClockData,
  zPinClockResponse: () => zPinClockResponse,
  zProblemDetail: () => zProblemDetail,
  zProcessDefinitionElementStatisticsQuery: () => zProcessDefinitionElementStatisticsQuery,
  zProcessDefinitionElementStatisticsQueryResult: () => zProcessDefinitionElementStatisticsQueryResult,
  zProcessDefinitionFilter: () => zProcessDefinitionFilter,
  zProcessDefinitionId: () => zProcessDefinitionId,
  zProcessDefinitionKey: () => zProcessDefinitionKey,
  zProcessDefinitionKeyFilterProperty: () => zProcessDefinitionKeyFilterProperty,
  zProcessDefinitionResult: () => zProcessDefinitionResult,
  zProcessDefinitionSearchQuery: () => zProcessDefinitionSearchQuery,
  zProcessDefinitionSearchQueryResult: () => zProcessDefinitionSearchQueryResult,
  zProcessDefinitionSearchQuerySortRequest: () => zProcessDefinitionSearchQuerySortRequest,
  zProcessDefinitionStatisticsFilter: () => zProcessDefinitionStatisticsFilter,
  zProcessElementStatisticsResult: () => zProcessElementStatisticsResult,
  zProcessInstanceCallHierarchyEntry: () => zProcessInstanceCallHierarchyEntry,
  zProcessInstanceCancellationBatchOperationRequest: () => zProcessInstanceCancellationBatchOperationRequest,
  zProcessInstanceCreationInstruction: () => zProcessInstanceCreationInstruction,
  zProcessInstanceCreationInstructionById: () => zProcessInstanceCreationInstructionById,
  zProcessInstanceCreationInstructionByKey: () => zProcessInstanceCreationInstructionByKey,
  zProcessInstanceCreationRuntimeInstruction: () => zProcessInstanceCreationRuntimeInstruction,
  zProcessInstanceCreationStartInstruction: () => zProcessInstanceCreationStartInstruction,
  zProcessInstanceCreationTerminateInstruction: () => zProcessInstanceCreationTerminateInstruction,
  zProcessInstanceElementStatisticsQueryResult: () => zProcessInstanceElementStatisticsQueryResult,
  zProcessInstanceFilter: () => zProcessInstanceFilter,
  zProcessInstanceFilterFields: () => zProcessInstanceFilterFields,
  zProcessInstanceIncidentResolutionBatchOperationRequest: () => zProcessInstanceIncidentResolutionBatchOperationRequest,
  zProcessInstanceIncidentSearchQuery: () => zProcessInstanceIncidentSearchQuery,
  zProcessInstanceKey: () => zProcessInstanceKey,
  zProcessInstanceKeyFilterProperty: () => zProcessInstanceKeyFilterProperty,
  zProcessInstanceMigrationBatchOperationPlan: () => zProcessInstanceMigrationBatchOperationPlan,
  zProcessInstanceMigrationBatchOperationRequest: () => zProcessInstanceMigrationBatchOperationRequest,
  zProcessInstanceMigrationInstruction: () => zProcessInstanceMigrationInstruction,
  zProcessInstanceModificationActivateInstruction: () => zProcessInstanceModificationActivateInstruction,
  zProcessInstanceModificationBatchOperationRequest: () => zProcessInstanceModificationBatchOperationRequest,
  zProcessInstanceModificationInstruction: () => zProcessInstanceModificationInstruction,
  zProcessInstanceModificationMoveBatchOperationInstruction: () => zProcessInstanceModificationMoveBatchOperationInstruction,
  zProcessInstanceModificationTerminateInstruction: () => zProcessInstanceModificationTerminateInstruction,
  zProcessInstanceResult: () => zProcessInstanceResult,
  zProcessInstanceSearchQuery: () => zProcessInstanceSearchQuery,
  zProcessInstanceSearchQueryResult: () => zProcessInstanceSearchQueryResult,
  zProcessInstanceSearchQuerySortRequest: () => zProcessInstanceSearchQuerySortRequest,
  zProcessInstanceSequenceFlowResult: () => zProcessInstanceSequenceFlowResult,
  zProcessInstanceSequenceFlowsQueryResult: () => zProcessInstanceSequenceFlowsQueryResult,
  zProcessInstanceStateEnum: () => zProcessInstanceStateEnum,
  zProcessInstanceStateFilterProperty: () => zProcessInstanceStateFilterProperty,
  zPublishMessageData: () => zPublishMessageData,
  zPublishMessageResponse: () => zPublishMessageResponse,
  zResetClockData: () => zResetClockData,
  zResetClockResponse: () => zResetClockResponse,
  zResolveIncidentData: () => zResolveIncidentData,
  zResolveIncidentResponse: () => zResolveIncidentResponse,
  zResolveIncidentsBatchOperationData: () => zResolveIncidentsBatchOperationData,
  zResolveIncidentsBatchOperationResponse: () => zResolveIncidentsBatchOperationResponse,
  zResourceKey: () => zResourceKey,
  zResourceResult: () => zResourceResult,
  zResourceTypeEnum: () => zResourceTypeEnum,
  zResumeBatchOperationData: () => zResumeBatchOperationData,
  zResumeBatchOperationResponse: () => zResumeBatchOperationResponse,
  zRoleClientResult: () => zRoleClientResult,
  zRoleClientSearchQueryRequest: () => zRoleClientSearchQueryRequest,
  zRoleClientSearchQuerySortRequest: () => zRoleClientSearchQuerySortRequest,
  zRoleClientSearchResult: () => zRoleClientSearchResult,
  zRoleCreateRequest: () => zRoleCreateRequest,
  zRoleCreateResult: () => zRoleCreateResult,
  zRoleFilter: () => zRoleFilter,
  zRoleGroupResult: () => zRoleGroupResult,
  zRoleGroupSearchQueryRequest: () => zRoleGroupSearchQueryRequest,
  zRoleGroupSearchQuerySortRequest: () => zRoleGroupSearchQuerySortRequest,
  zRoleGroupSearchResult: () => zRoleGroupSearchResult,
  zRoleResult: () => zRoleResult,
  zRoleSearchQueryRequest: () => zRoleSearchQueryRequest,
  zRoleSearchQueryResult: () => zRoleSearchQueryResult,
  zRoleSearchQuerySortRequest: () => zRoleSearchQuerySortRequest,
  zRoleUpdateRequest: () => zRoleUpdateRequest,
  zRoleUpdateResult: () => zRoleUpdateResult,
  zRoleUserResult: () => zRoleUserResult,
  zRoleUserSearchQueryRequest: () => zRoleUserSearchQueryRequest,
  zRoleUserSearchQuerySortRequest: () => zRoleUserSearchQuerySortRequest,
  zRoleUserSearchResult: () => zRoleUserSearchResult,
  zScopeKey: () => zScopeKey,
  zScopeKeyFilterProperty: () => zScopeKeyFilterProperty,
  zSearchAuthorizationsData: () => zSearchAuthorizationsData,
  zSearchAuthorizationsResponse: () => zSearchAuthorizationsResponse,
  zSearchBatchOperationItemsData: () => zSearchBatchOperationItemsData,
  zSearchBatchOperationItemsResponse: () => zSearchBatchOperationItemsResponse,
  zSearchBatchOperationsData: () => zSearchBatchOperationsData,
  zSearchBatchOperationsResponse: () => zSearchBatchOperationsResponse,
  zSearchClientsForGroupData: () => zSearchClientsForGroupData,
  zSearchClientsForGroupResponse: () => zSearchClientsForGroupResponse,
  zSearchClientsForRoleData: () => zSearchClientsForRoleData,
  zSearchClientsForRoleResponse: () => zSearchClientsForRoleResponse,
  zSearchClientsForTenantData: () => zSearchClientsForTenantData,
  zSearchClientsForTenantResponse: () => zSearchClientsForTenantResponse,
  zSearchCorrelatedMessageSubscriptionsData: () => zSearchCorrelatedMessageSubscriptionsData,
  zSearchCorrelatedMessageSubscriptionsResponse: () => zSearchCorrelatedMessageSubscriptionsResponse,
  zSearchDecisionDefinitionsData: () => zSearchDecisionDefinitionsData,
  zSearchDecisionDefinitionsResponse: () => zSearchDecisionDefinitionsResponse,
  zSearchDecisionInstancesData: () => zSearchDecisionInstancesData,
  zSearchDecisionInstancesResponse: () => zSearchDecisionInstancesResponse,
  zSearchDecisionRequirementsData: () => zSearchDecisionRequirementsData,
  zSearchDecisionRequirementsResponse: () => zSearchDecisionRequirementsResponse,
  zSearchElementInstancesData: () => zSearchElementInstancesData,
  zSearchElementInstancesResponse: () => zSearchElementInstancesResponse,
  zSearchGroupIdsForTenantData: () => zSearchGroupIdsForTenantData,
  zSearchGroupIdsForTenantResponse: () => zSearchGroupIdsForTenantResponse,
  zSearchGroupsData: () => zSearchGroupsData,
  zSearchGroupsForRoleData: () => zSearchGroupsForRoleData,
  zSearchGroupsForRoleResponse: () => zSearchGroupsForRoleResponse,
  zSearchGroupsResponse: () => zSearchGroupsResponse,
  zSearchIncidentsData: () => zSearchIncidentsData,
  zSearchIncidentsResponse: () => zSearchIncidentsResponse,
  zSearchJobsData: () => zSearchJobsData,
  zSearchJobsResponse: () => zSearchJobsResponse,
  zSearchMappingRuleData: () => zSearchMappingRuleData,
  zSearchMappingRuleResponse: () => zSearchMappingRuleResponse,
  zSearchMappingRulesForGroupData: () => zSearchMappingRulesForGroupData,
  zSearchMappingRulesForGroupResponse: () => zSearchMappingRulesForGroupResponse,
  zSearchMappingRulesForRoleData: () => zSearchMappingRulesForRoleData,
  zSearchMappingRulesForRoleResponse: () => zSearchMappingRulesForRoleResponse,
  zSearchMappingRulesForTenantData: () => zSearchMappingRulesForTenantData,
  zSearchMappingRulesForTenantResponse: () => zSearchMappingRulesForTenantResponse,
  zSearchMessageSubscriptionsData: () => zSearchMessageSubscriptionsData,
  zSearchMessageSubscriptionsResponse: () => zSearchMessageSubscriptionsResponse,
  zSearchProcessDefinitionsData: () => zSearchProcessDefinitionsData,
  zSearchProcessDefinitionsResponse: () => zSearchProcessDefinitionsResponse,
  zSearchProcessInstanceIncidentsData: () => zSearchProcessInstanceIncidentsData,
  zSearchProcessInstanceIncidentsResponse: () => zSearchProcessInstanceIncidentsResponse,
  zSearchProcessInstancesData: () => zSearchProcessInstancesData,
  zSearchProcessInstancesResponse: () => zSearchProcessInstancesResponse,
  zSearchQueryPageRequest: () => zSearchQueryPageRequest,
  zSearchQueryPageResponse: () => zSearchQueryPageResponse,
  zSearchQueryRequest: () => zSearchQueryRequest,
  zSearchQueryResponse: () => zSearchQueryResponse,
  zSearchRolesData: () => zSearchRolesData,
  zSearchRolesForGroupData: () => zSearchRolesForGroupData,
  zSearchRolesForGroupResponse: () => zSearchRolesForGroupResponse,
  zSearchRolesForTenantData: () => zSearchRolesForTenantData,
  zSearchRolesForTenantResponse: () => zSearchRolesForTenantResponse,
  zSearchRolesResponse: () => zSearchRolesResponse,
  zSearchTenantsData: () => zSearchTenantsData,
  zSearchTenantsResponse: () => zSearchTenantsResponse,
  zSearchUserTaskVariablesData: () => zSearchUserTaskVariablesData,
  zSearchUserTaskVariablesResponse: () => zSearchUserTaskVariablesResponse,
  zSearchUserTasksData: () => zSearchUserTasksData,
  zSearchUserTasksResponse: () => zSearchUserTasksResponse,
  zSearchUsersData: () => zSearchUsersData,
  zSearchUsersForGroupData: () => zSearchUsersForGroupData,
  zSearchUsersForGroupResponse: () => zSearchUsersForGroupResponse,
  zSearchUsersForRoleData: () => zSearchUsersForRoleData,
  zSearchUsersForRoleResponse: () => zSearchUsersForRoleResponse,
  zSearchUsersForTenantData: () => zSearchUsersForTenantData,
  zSearchUsersForTenantResponse: () => zSearchUsersForTenantResponse,
  zSearchUsersResponse: () => zSearchUsersResponse,
  zSearchVariablesData: () => zSearchVariablesData,
  zSearchVariablesResponse: () => zSearchVariablesResponse,
  zSetVariableRequest: () => zSetVariableRequest,
  zSignalBroadcastRequest: () => zSignalBroadcastRequest,
  zSignalBroadcastResult: () => zSignalBroadcastResult,
  zSignalKey: () => zSignalKey,
  zSortOrderEnum: () => zSortOrderEnum,
  zStartCursor: () => zStartCursor,
  zStringFilterProperty: () => zStringFilterProperty,
  zSuspendBatchOperationData: () => zSuspendBatchOperationData,
  zSuspendBatchOperationResponse: () => zSuspendBatchOperationResponse,
  zTag: () => zTag,
  zTagSet: () => zTagSet,
  zTenantClientResult: () => zTenantClientResult,
  zTenantClientSearchQueryRequest: () => zTenantClientSearchQueryRequest,
  zTenantClientSearchQuerySortRequest: () => zTenantClientSearchQuerySortRequest,
  zTenantClientSearchResult: () => zTenantClientSearchResult,
  zTenantCreateRequest: () => zTenantCreateRequest,
  zTenantCreateResult: () => zTenantCreateResult,
  zTenantFilter: () => zTenantFilter,
  zTenantGroupResult: () => zTenantGroupResult,
  zTenantGroupSearchQueryRequest: () => zTenantGroupSearchQueryRequest,
  zTenantGroupSearchQuerySortRequest: () => zTenantGroupSearchQuerySortRequest,
  zTenantGroupSearchResult: () => zTenantGroupSearchResult,
  zTenantId: () => zTenantId,
  zTenantResult: () => zTenantResult,
  zTenantSearchQueryRequest: () => zTenantSearchQueryRequest,
  zTenantSearchQueryResult: () => zTenantSearchQueryResult,
  zTenantSearchQuerySortRequest: () => zTenantSearchQuerySortRequest,
  zTenantUpdateRequest: () => zTenantUpdateRequest,
  zTenantUpdateResult: () => zTenantUpdateResult,
  zTenantUserResult: () => zTenantUserResult,
  zTenantUserSearchQueryRequest: () => zTenantUserSearchQueryRequest,
  zTenantUserSearchQuerySortRequest: () => zTenantUserSearchQuerySortRequest,
  zTenantUserSearchResult: () => zTenantUserSearchResult,
  zThrowJobErrorData: () => zThrowJobErrorData,
  zThrowJobErrorResponse: () => zThrowJobErrorResponse,
  zTopologyResponse: () => zTopologyResponse,
  zUnassignClientFromGroupData: () => zUnassignClientFromGroupData,
  zUnassignClientFromGroupResponse: () => zUnassignClientFromGroupResponse,
  zUnassignClientFromTenantData: () => zUnassignClientFromTenantData,
  zUnassignClientFromTenantResponse: () => zUnassignClientFromTenantResponse,
  zUnassignGroupFromTenantData: () => zUnassignGroupFromTenantData,
  zUnassignGroupFromTenantResponse: () => zUnassignGroupFromTenantResponse,
  zUnassignMappingRuleFromGroupData: () => zUnassignMappingRuleFromGroupData,
  zUnassignMappingRuleFromGroupResponse: () => zUnassignMappingRuleFromGroupResponse,
  zUnassignMappingRuleFromTenantData: () => zUnassignMappingRuleFromTenantData,
  zUnassignMappingRuleFromTenantResponse: () => zUnassignMappingRuleFromTenantResponse,
  zUnassignRoleFromClientData: () => zUnassignRoleFromClientData,
  zUnassignRoleFromClientResponse: () => zUnassignRoleFromClientResponse,
  zUnassignRoleFromGroupData: () => zUnassignRoleFromGroupData,
  zUnassignRoleFromGroupResponse: () => zUnassignRoleFromGroupResponse,
  zUnassignRoleFromMappingRuleData: () => zUnassignRoleFromMappingRuleData,
  zUnassignRoleFromMappingRuleResponse: () => zUnassignRoleFromMappingRuleResponse,
  zUnassignRoleFromTenantData: () => zUnassignRoleFromTenantData,
  zUnassignRoleFromTenantResponse: () => zUnassignRoleFromTenantResponse,
  zUnassignRoleFromUserData: () => zUnassignRoleFromUserData,
  zUnassignRoleFromUserResponse: () => zUnassignRoleFromUserResponse,
  zUnassignUserFromGroupData: () => zUnassignUserFromGroupData,
  zUnassignUserFromGroupResponse: () => zUnassignUserFromGroupResponse,
  zUnassignUserFromTenantData: () => zUnassignUserFromTenantData,
  zUnassignUserFromTenantResponse: () => zUnassignUserFromTenantResponse,
  zUnassignUserTaskData: () => zUnassignUserTaskData,
  zUnassignUserTaskResponse: () => zUnassignUserTaskResponse,
  zUpdateAuthorizationData: () => zUpdateAuthorizationData,
  zUpdateAuthorizationResponse: () => zUpdateAuthorizationResponse,
  zUpdateGroupData: () => zUpdateGroupData,
  zUpdateGroupResponse: () => zUpdateGroupResponse,
  zUpdateJobData: () => zUpdateJobData,
  zUpdateJobResponse: () => zUpdateJobResponse,
  zUpdateMappingRuleData: () => zUpdateMappingRuleData,
  zUpdateMappingRuleResponse: () => zUpdateMappingRuleResponse,
  zUpdateRoleData: () => zUpdateRoleData,
  zUpdateRoleResponse: () => zUpdateRoleResponse,
  zUpdateTenantData: () => zUpdateTenantData,
  zUpdateTenantResponse: () => zUpdateTenantResponse,
  zUpdateUserData: () => zUpdateUserData,
  zUpdateUserResponse: () => zUpdateUserResponse,
  zUpdateUserTaskData: () => zUpdateUserTaskData,
  zUpdateUserTaskResponse: () => zUpdateUserTaskResponse,
  zUsageMetricsResponse: () => zUsageMetricsResponse,
  zUsageMetricsResponseItem: () => zUsageMetricsResponseItem,
  zUserCreateResult: () => zUserCreateResult,
  zUserFilter: () => zUserFilter,
  zUserRequest: () => zUserRequest,
  zUserResult: () => zUserResult,
  zUserSearchQueryRequest: () => zUserSearchQueryRequest,
  zUserSearchQuerySortRequest: () => zUserSearchQuerySortRequest,
  zUserSearchResult: () => zUserSearchResult,
  zUserTaskAssignmentRequest: () => zUserTaskAssignmentRequest,
  zUserTaskCompletionRequest: () => zUserTaskCompletionRequest,
  zUserTaskFilter: () => zUserTaskFilter,
  zUserTaskKey: () => zUserTaskKey,
  zUserTaskProperties: () => zUserTaskProperties,
  zUserTaskResult: () => zUserTaskResult,
  zUserTaskSearchQuery: () => zUserTaskSearchQuery,
  zUserTaskSearchQueryResult: () => zUserTaskSearchQueryResult,
  zUserTaskSearchQuerySortRequest: () => zUserTaskSearchQuerySortRequest,
  zUserTaskStateEnum: () => zUserTaskStateEnum,
  zUserTaskStateFilterProperty: () => zUserTaskStateFilterProperty,
  zUserTaskUpdateRequest: () => zUserTaskUpdateRequest,
  zUserTaskVariableFilter: () => zUserTaskVariableFilter,
  zUserTaskVariableSearchQueryRequest: () => zUserTaskVariableSearchQueryRequest,
  zUserTaskVariableSearchQuerySortRequest: () => zUserTaskVariableSearchQuerySortRequest,
  zUserUpdateRequest: () => zUserUpdateRequest,
  zUserUpdateResult: () => zUserUpdateResult,
  zUsername: () => zUsername,
  zVariableFilter: () => zVariableFilter,
  zVariableKey: () => zVariableKey,
  zVariableKeyFilterProperty: () => zVariableKeyFilterProperty,
  zVariableResult: () => zVariableResult,
  zVariableResultBase: () => zVariableResultBase,
  zVariableSearchQuery: () => zVariableSearchQuery,
  zVariableSearchQueryResult: () => zVariableSearchQueryResult,
  zVariableSearchQuerySortRequest: () => zVariableSearchQuerySortRequest,
  zVariableSearchResult: () => zVariableSearchResult,
  zVariableValueFilterProperty: () => zVariableValueFilterProperty
});
import { z } from "zod";
var zLongKey = z.string().min(1).max(25).regex(/^-?[0-9]+$/).register(z.globalRegistry, {
  description: "Zeebe Engine resource key (Java long serialized as string)"
});
var zStartCursor = z.string().min(2).max(300).regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$/).register(z.globalRegistry, {
  description: "The start cursor in a search query result set."
});
var zEndCursor = z.string().min(2).max(300).regex(/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$/).register(z.globalRegistry, {
  description: "The end cursor in a search query result set."
});
var zProcessInstanceKey = zLongKey;
var zDeploymentKey = zLongKey;
var zUserTaskKey = zLongKey;
var zProcessDefinitionKey = zLongKey;
var zProcessDefinitionId = z.string().min(1).regex(/^[a-zA-Z_][a-zA-Z0-9_\-\.]*$/).register(z.globalRegistry, {
  description: "Id of a process definition, from the model. Only ids of process definitions that are deployed are useful."
});
var zElementInstanceKey = zLongKey;
var zElementId = z.string().register(z.globalRegistry, {
  description: "The model-defined id of an element."
});
var zFormKey = zLongKey;
var zFormId = z.string().register(z.globalRegistry, {
  description: "The user-defined id for the form"
});
var zVariableKey = zLongKey;
var zDecisionRequirementsKey = zLongKey;
var zDecisionDefinitionKey = zLongKey;
var zResourceKey = z.union([
  zProcessDefinitionKey,
  zDecisionRequirementsKey,
  zFormKey,
  zDecisionDefinitionKey
]);
var zScopeKey = zLongKey;
var zIncidentKey = zLongKey;
var zJobKey = zLongKey;
var zMessageSubscriptionKey = zLongKey;
var zMessageCorrelationKey = zLongKey;
var zDecisionDefinitionId = z.string().min(1).max(256).regex(/^[A-Za-z0-9_@.+-]+$/).register(z.globalRegistry, {
  description: "Id of a decision definition, from the model. Only ids of decision definitions that are deployed are useful."
});
var zDecisionEvaluationInstanceKey = zLongKey;
var zDecisionEvaluationKey = zLongKey;
var zAuthorizationKey = zLongKey;
var zMessageKey = zLongKey;
var zDecisionInstanceKey = zLongKey;
var zSignalKey = zLongKey;
var zBatchOperationKey = z.string().register(z.globalRegistry, {
  description: "System-generated key for an batch operation."
});
var zTenantCreateRequest = z.object({
  tenantId: z.string().min(1).max(256).regex(/^[A-Za-z0-9_@.+-]+$/).register(z.globalRegistry, {
    description: "The unique ID for the tenant. Must be 255 characters or less. Can contain letters, numbers, [`_`, `-`, `+`, `.`, `@`]."
  }),
  name: z.string().register(z.globalRegistry, {
    description: "The name of the tenant."
  }),
  description: z.optional(z.string().register(z.globalRegistry, {
    description: "The description of the tenant."
  }))
});
var zTenantId = z.string().min(1).max(256).regex(/^(<default>|[A-Za-z0-9_@.+-]+)$/).register(z.globalRegistry, {
  description: "The unique identifier of the tenant."
});
var zTenantCreateResult = z.object({
  tenantId: z.optional(zTenantId),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the tenant."
  })),
  description: z.optional(z.string().register(z.globalRegistry, {
    description: "The description of the tenant."
  }))
});
var zTenantUpdateRequest = z.object({
  name: z.string().register(z.globalRegistry, {
    description: "The new name of the tenant."
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The new description of the tenant."
  })
});
var zTenantUpdateResult = z.object({
  tenantId: z.optional(zTenantId),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the tenant."
  })),
  description: z.optional(z.string().register(z.globalRegistry, {
    description: "The description of the tenant."
  }))
});
var zTenantResult = z.object({
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The tenant name."
  })),
  tenantId: z.optional(zTenantId),
  description: z.optional(z.string().register(z.globalRegistry, {
    description: "The tenant description."
  }))
}).register(z.globalRegistry, {
  description: "Tenant search response item."
});
var zSortOrderEnum = z.enum([
  "ASC",
  "DESC"
]).register(z.globalRegistry, {
  description: "The order in which to sort the related field."
});
var zTenantSearchQuerySortRequest = z.object({
  field: z.enum([
    "key",
    "name",
    "tenantId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zOffsetPagination = z.object({
  from: z.optional(z.int().gte(0).register(z.globalRegistry, {
    description: "The index of items to start searching from."
  })).default(0),
  limit: z.optional(z.int().gte(1).register(z.globalRegistry, {
    description: "The maximum number of items to return in one request."
  })).default(100)
});
var zCursorForwardPagination = z.object({
  after: zEndCursor,
  limit: z.optional(z.int().register(z.globalRegistry, {
    description: "The maximum number of items to return in one request."
  })).default(100)
});
var zCursorBackwardPagination = z.object({
  before: zStartCursor,
  limit: z.optional(z.int().register(z.globalRegistry, {
    description: "The maximum number of items to return in one request."
  })).default(100)
});
var zSearchQueryPageRequest = z.union([
  zOffsetPagination,
  zCursorForwardPagination,
  zCursorBackwardPagination
]);
var zSearchQueryRequest = z.object({
  page: z.optional(zSearchQueryPageRequest)
});
var zTenantFilter = z.object({
  tenantId: z.optional(zTenantId),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the tenant."
  }))
}).register(z.globalRegistry, {
  description: "Tenant filter request"
});
var zTenantSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zTenantSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zTenantFilter)
}).register(z.globalRegistry, {
  description: "Tenant search request"
}));
var zSearchQueryPageResponse = z.object({
  totalItems: z.coerce.bigint().register(z.globalRegistry, {
    description: "Total items matching the criteria."
  }),
  hasMoreTotalItems: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Indicates if more results exist beyond the reported totalItems value. Due to system limitations, the totalItems value can be capped.\n"
  })),
  startCursor: z.optional(zStartCursor),
  endCursor: z.optional(zEndCursor)
}).register(z.globalRegistry, {
  description: "Pagination information about the search results."
});
var zSearchQueryResponse = z.object({
  page: zSearchQueryPageResponse
});
var zTenantSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zTenantResult).register(z.globalRegistry, {
    description: "The matching tenants."
  }))
}).register(z.globalRegistry, {
  description: "Tenant search response."
}));
var zUserTaskSearchQuerySortRequest = z.object({
  field: z.enum([
    "creationDate",
    "completionDate",
    "followUpDate",
    "dueDate",
    "priority",
    "name"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zUserTaskStateEnum = z.enum([
  "CREATING",
  "CREATED",
  "ASSIGNING",
  "UPDATING",
  "COMPLETING",
  "COMPLETED",
  "CANCELING",
  "CANCELED",
  "FAILED"
]).register(z.globalRegistry, {
  description: "The state of the user task."
});
var zLikeFilter = z.string().register(z.globalRegistry, {
  description: "Checks if the property matches the provided like value.\n\nSupported wildcard characters are:\n\n* `*`: matches zero, one, or multiple characters.\n* `?`: matches one, single character.\n\nWildcard characters can be escaped with backslash, for instance: `\\*`.\n"
});
var zAdvancedUserTaskStateFilter = z.object({
  "$eq": z.optional(zUserTaskStateEnum),
  "$neq": z.optional(zUserTaskStateEnum),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zUserTaskStateEnum).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$like": z.optional(zLikeFilter)
}).register(z.globalRegistry, {
  description: "Advanced UserTaskStateEnum filter."
});
var zUserTaskStateFilterProperty = z.union([
  zUserTaskStateEnum,
  zAdvancedUserTaskStateFilter
]);
var zBasicStringFilter = z.object({
  "$eq": z.optional(z.string().register(z.globalRegistry, {
    description: "Checks for equality with the provided value."
  })),
  "$neq": z.optional(z.string().register(z.globalRegistry, {
    description: "Checks for inequality with the provided value."
  })),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(z.string()).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$notIn": z.optional(z.array(z.string()).register(z.globalRegistry, {
    description: "Checks if the property matches none of the provided values."
  }))
}).register(z.globalRegistry, {
  description: "Basic advanced string filter."
});
var zAdvancedStringFilter = zBasicStringFilter.and(z.object({
  "$like": z.optional(zLikeFilter)
}));
var zStringFilterProperty = z.union([
  z.string().register(z.globalRegistry, {
    description: "Matches the value exactly."
  }),
  zAdvancedStringFilter
]);
var zAdvancedIntegerFilter = z.object({
  "$eq": z.optional(z.int().register(z.globalRegistry, {
    description: "Checks for equality with the provided value."
  })),
  "$neq": z.optional(z.int().register(z.globalRegistry, {
    description: "Checks for inequality with the provided value."
  })),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$gt": z.optional(z.int().register(z.globalRegistry, {
    description: "Greater than comparison with the provided value."
  })),
  "$gte": z.optional(z.int().register(z.globalRegistry, {
    description: "Greater than or equal comparison with the provided value."
  })),
  "$lt": z.optional(z.int().register(z.globalRegistry, {
    description: "Lower than comparison with the provided value."
  })),
  "$lte": z.optional(z.int().register(z.globalRegistry, {
    description: "Lower than or equal comparison with the provided value."
  })),
  "$in": z.optional(z.array(z.int()).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  }))
}).register(z.globalRegistry, {
  description: "Advanced integer (int32) filter."
});
var zIntegerFilterProperty = z.union([
  z.int().register(z.globalRegistry, {
    description: "Matches the value exactly."
  }),
  zAdvancedIntegerFilter
]);
var zAdvancedDateTimeFilter = z.object({
  "$eq": z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "Checks for equality with the provided value."
  })),
  "$neq": z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "Checks for inequality with the provided value."
  })),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$gt": z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "Greater than comparison with the provided value."
  })),
  "$gte": z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "Greater than or equal comparison with the provided value."
  })),
  "$lt": z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "Lower than comparison with the provided value."
  })),
  "$lte": z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "Lower than or equal comparison with the provided value."
  })),
  "$in": z.optional(z.array(z.iso.datetime()).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  }))
}).register(z.globalRegistry, {
  description: "Advanced date-time filter."
});
var zDateTimeFilterProperty = z.union([
  z.iso.datetime().register(z.globalRegistry, {
    description: "Matches the value exactly."
  }),
  zAdvancedDateTimeFilter
]);
var zVariableValueFilterProperty = z.object({
  name: z.string().register(z.globalRegistry, {
    description: "Name of the variable."
  }),
  value: zStringFilterProperty
});
var zUserTaskFilter = z.object({
  state: z.optional(zUserTaskStateFilterProperty),
  assignee: z.optional(zStringFilterProperty),
  priority: z.optional(zIntegerFilterProperty),
  elementId: z.optional(zElementId),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The task name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.\n"
  })),
  candidateGroup: z.optional(zStringFilterProperty),
  candidateUser: z.optional(zStringFilterProperty),
  tenantId: z.optional(zStringFilterProperty),
  processDefinitionId: z.optional(zProcessDefinitionId),
  creationDate: z.optional(zDateTimeFilterProperty),
  completionDate: z.optional(zDateTimeFilterProperty),
  followUpDate: z.optional(zDateTimeFilterProperty),
  dueDate: z.optional(zDateTimeFilterProperty),
  processInstanceVariables: z.optional(z.array(zVariableValueFilterProperty).register(z.globalRegistry, {
    description: "Process instance variables associated with the user task."
  })),
  localVariables: z.optional(z.array(zVariableValueFilterProperty).register(z.globalRegistry, {
    description: "Local variables associated with the user task."
  })),
  userTaskKey: z.optional(zUserTaskKey),
  processDefinitionKey: z.optional(zProcessDefinitionKey),
  processInstanceKey: z.optional(zProcessInstanceKey),
  elementInstanceKey: z.optional(zElementInstanceKey)
}).register(z.globalRegistry, {
  description: "User task filter request."
});
var zUserTaskSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zUserTaskSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zUserTaskFilter)
}).register(z.globalRegistry, {
  description: "User task search query request."
}));
var zUserTaskVariableSearchQuerySortRequest = z.object({
  field: z.enum([
    "value",
    "name",
    "tenantId",
    "variableKey",
    "scopeKey",
    "processInstanceKey"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zUserTaskVariableFilter = z.object({
  name: z.optional(zStringFilterProperty)
}).register(z.globalRegistry, {
  description: "The user task variable search filters."
});
var zUserTaskVariableSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zUserTaskVariableSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zUserTaskVariableFilter)
}).register(z.globalRegistry, {
  description: "User task search query request."
}));
var zUserTaskResult = z.object({
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The name for this user task."
  })),
  state: z.optional(zUserTaskStateEnum),
  assignee: z.optional(z.string().register(z.globalRegistry, {
    description: "The assignee of the user task."
  })),
  elementId: z.optional(zElementId),
  candidateGroups: z.optional(z.array(z.string()).register(z.globalRegistry, {
    description: "The candidate groups for this user task."
  })),
  candidateUsers: z.optional(z.array(z.string()).register(z.globalRegistry, {
    description: "The candidate users for this user task."
  })),
  processDefinitionId: z.optional(zProcessDefinitionId),
  creationDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "The creation date of a user task."
  })),
  completionDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "The completion date of a user task."
  })),
  followUpDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "The follow date of a user task."
  })),
  dueDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "The due date of a user task."
  })),
  tenantId: z.optional(zTenantId),
  externalFormReference: z.optional(z.string().register(z.globalRegistry, {
    description: "The external form reference."
  })),
  processDefinitionVersion: z.optional(z.int().register(z.globalRegistry, {
    description: "The version of the process definition."
  })),
  customHeaders: z.optional(z.record(z.string(), z.string()).register(z.globalRegistry, {
    description: "Custom headers for the user task."
  })),
  priority: z.optional(z.int().gte(0).lte(100).register(z.globalRegistry, {
    description: "The priority of a user task. The higher the value the higher the priority."
  })).default(50),
  userTaskKey: zUserTaskKey,
  elementInstanceKey: z.optional(zElementInstanceKey),
  processName: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the process definition."
  })),
  processDefinitionKey: z.optional(zProcessDefinitionKey),
  processInstanceKey: z.optional(zProcessInstanceKey),
  formKey: z.optional(zFormKey)
});
var zUserTaskSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.array(zUserTaskResult).register(z.globalRegistry, {
    description: "The matching user tasks."
  })
}).register(z.globalRegistry, {
  description: "User task search query response."
}));
var zVariableSearchQuerySortRequest = z.object({
  field: z.enum([
    "value",
    "name",
    "tenantId",
    "variableKey",
    "scopeKey",
    "processInstanceKey"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zAdvancedVariableKeyFilter = z.object({
  "$eq": z.optional(zVariableKey),
  "$neq": z.optional(zVariableKey),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zVariableKey).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$notIn": z.optional(z.array(zVariableKey).register(z.globalRegistry, {
    description: "Checks if the property matches none of the provided values."
  }))
}).register(z.globalRegistry, {
  description: "Advanced VariableKey filter."
});
var zVariableKeyFilterProperty = z.union([
  zVariableKey,
  zAdvancedVariableKeyFilter
]);
var zAdvancedScopeKeyFilter = z.object({
  "$eq": z.optional(zScopeKey),
  "$neq": z.optional(zScopeKey),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zScopeKey).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$notIn": z.optional(z.array(zScopeKey).register(z.globalRegistry, {
    description: "Checks if the property matches none of the provided values."
  }))
}).register(z.globalRegistry, {
  description: "Advanced ScopeKey filter."
});
var zScopeKeyFilterProperty = z.union([
  zScopeKey,
  zAdvancedScopeKeyFilter
]);
var zAdvancedProcessInstanceKeyFilter = z.object({
  "$eq": z.optional(zProcessInstanceKey),
  "$neq": z.optional(zProcessInstanceKey),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zProcessInstanceKey).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$notIn": z.optional(z.array(zProcessInstanceKey).register(z.globalRegistry, {
    description: "Checks if the property matches none of the provided values."
  }))
}).register(z.globalRegistry, {
  description: "Advanced ProcessInstanceKey filter."
});
var zProcessInstanceKeyFilterProperty = z.union([
  zProcessInstanceKey,
  zAdvancedProcessInstanceKeyFilter
]);
var zVariableFilter = z.object({
  name: z.optional(zStringFilterProperty),
  value: z.optional(zStringFilterProperty),
  tenantId: z.optional(zTenantId),
  isTruncated: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Whether the value is truncated or not."
  })),
  variableKey: z.optional(zVariableKeyFilterProperty),
  scopeKey: z.optional(zScopeKeyFilterProperty),
  processInstanceKey: z.optional(zProcessInstanceKeyFilterProperty)
}).register(z.globalRegistry, {
  description: "Variable filter request."
});
var zVariableSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zVariableSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zVariableFilter)
}).register(z.globalRegistry, {
  description: "Variable search query request."
}));
var zVariableResultBase = z.object({
  name: z.string().register(z.globalRegistry, {
    description: "Name of this variable."
  }),
  tenantId: zTenantId,
  variableKey: zVariableKey,
  scopeKey: zScopeKey,
  processInstanceKey: zProcessInstanceKey
}).register(z.globalRegistry, {
  description: "Variable response item."
});
var zVariableSearchResult = zVariableResultBase.and(z.object({
  value: z.string().register(z.globalRegistry, {
    description: "Value of this variable. Can be truncated."
  }),
  isTruncated: z.boolean().register(z.globalRegistry, {
    description: "Whether the value is truncated or not."
  })
}).register(z.globalRegistry, {
  description: "Variable search response item."
}));
var zVariableSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.array(zVariableSearchResult).register(z.globalRegistry, {
    description: "The matching variables."
  })
}).register(z.globalRegistry, {
  description: "Variable search query response."
}));
var zVariableResult = zVariableResultBase.and(z.object({
  value: z.string().register(z.globalRegistry, {
    description: "Full value of this variable."
  })
}).register(z.globalRegistry, {
  description: "Variable search response item."
}));
var zProcessDefinitionSearchQuerySortRequest = z.object({
  field: z.enum([
    "processDefinitionKey",
    "name",
    "resourceName",
    "version",
    "versionTag",
    "processDefinitionId",
    "tenantId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zProcessDefinitionFilter = z.object({
  name: z.optional(zStringFilterProperty),
  isLatestVersion: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Whether to only return the latest version of each process definition.\nWhen using this filter, pagination functionality is limited, you can only paginate forward using `after` and `limit`.\nThe response contains no `startCursor` in the `page`, and requests ignore the `from` and `before` in the `page`.\n"
  })),
  resourceName: z.optional(z.string().register(z.globalRegistry, {
    description: "Resource name of this process definition."
  })),
  version: z.optional(z.int().register(z.globalRegistry, {
    description: "Version of this process definition."
  })),
  versionTag: z.optional(z.string().register(z.globalRegistry, {
    description: "Version tag of this process definition."
  })),
  processDefinitionId: z.optional(zStringFilterProperty),
  tenantId: z.optional(zTenantId),
  processDefinitionKey: z.optional(zProcessDefinitionKey),
  hasStartForm: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Indicates whether the start event of the process has an associated Form Key."
  }))
}).register(z.globalRegistry, {
  description: "Process definition search filter."
});
var zProcessDefinitionSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zProcessDefinitionSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zProcessDefinitionFilter)
}));
var zProcessDefinitionResult = z.object({
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "Name of this process definition."
  })),
  resourceName: z.optional(z.string().register(z.globalRegistry, {
    description: "Resource name for this process definition."
  })),
  version: z.optional(z.int().register(z.globalRegistry, {
    description: "Version of this process definition."
  })),
  versionTag: z.optional(z.string().register(z.globalRegistry, {
    description: "Version tag of this process definition."
  })),
  processDefinitionId: z.optional(zProcessDefinitionId),
  tenantId: z.optional(zTenantId),
  processDefinitionKey: z.optional(zProcessDefinitionKey),
  hasStartForm: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Indicates whether the start event of the process has an associated Form Key."
  }))
});
var zProcessDefinitionSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zProcessDefinitionResult).register(z.globalRegistry, {
    description: "The matching process definitions."
  }))
}));
var zProcessInstanceSearchQuerySortRequest = z.object({
  field: z.enum([
    "processInstanceKey",
    "processDefinitionId",
    "processDefinitionName",
    "processDefinitionVersion",
    "processDefinitionVersionTag",
    "processDefinitionKey",
    "parentProcessInstanceKey",
    "parentElementInstanceKey",
    "startDate",
    "endDate",
    "state",
    "hasIncident",
    "tenantId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zProcessInstanceStateEnum = z.enum([
  "ACTIVE",
  "COMPLETED",
  "TERMINATED"
]).register(z.globalRegistry, {
  description: "Process instance states"
});
var zAdvancedProcessInstanceStateFilter = z.object({
  "$eq": z.optional(zProcessInstanceStateEnum),
  "$neq": z.optional(zProcessInstanceStateEnum),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zProcessInstanceStateEnum).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$like": z.optional(zLikeFilter)
}).register(z.globalRegistry, {
  description: "Advanced ProcessInstanceStateEnum filter."
});
var zProcessInstanceStateFilterProperty = z.union([
  zProcessInstanceStateEnum,
  zAdvancedProcessInstanceStateFilter
]);
var zAdvancedElementInstanceKeyFilter = z.object({
  "$eq": z.optional(zElementInstanceKey),
  "$neq": z.optional(zElementInstanceKey),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zElementInstanceKey).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$notIn": z.optional(z.array(zElementInstanceKey).register(z.globalRegistry, {
    description: "Checks if the property matches none of the provided values."
  }))
}).register(z.globalRegistry, {
  description: "Advanced ElementInstanceKey filter."
});
var zElementInstanceKeyFilterProperty = z.union([
  zElementInstanceKey,
  zAdvancedElementInstanceKeyFilter
]);
var zElementInstanceStateEnum = z.enum([
  "ACTIVE",
  "COMPLETED",
  "TERMINATED"
]).register(z.globalRegistry, {
  description: "Element states"
});
var zAdvancedElementInstanceStateFilter = z.object({
  "$eq": z.optional(zElementInstanceStateEnum),
  "$neq": z.optional(zElementInstanceStateEnum),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zElementInstanceStateEnum).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$like": z.optional(zLikeFilter)
}).register(z.globalRegistry, {
  description: "Advanced ElementInstanceStateEnum filter."
});
var zElementInstanceStateFilterProperty = z.union([
  zElementInstanceStateEnum,
  zAdvancedElementInstanceStateFilter
]);
var zTag = z.string().min(1).max(100).regex(/^[A-Za-z][A-Za-z0-9_\-:.]{0,99}$/).register(z.globalRegistry, {
  description: "A tag. Needs to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length \u2264 100."
});
var zTagSet = z.array(zTag).max(10).register(z.globalRegistry, {
  description: "List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length \u2264 100."
});
var zBaseProcessInstanceFilterFields = z.object({
  startDate: z.optional(zDateTimeFilterProperty),
  endDate: z.optional(zDateTimeFilterProperty),
  state: z.optional(zProcessInstanceStateFilterProperty),
  hasIncident: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Whether this process instance has a related incident or not."
  })),
  tenantId: z.optional(zStringFilterProperty),
  variables: z.optional(z.array(zVariableValueFilterProperty).register(z.globalRegistry, {
    description: "The process instance variables."
  })),
  processInstanceKey: z.optional(zProcessInstanceKeyFilterProperty),
  parentProcessInstanceKey: z.optional(zProcessInstanceKeyFilterProperty),
  parentElementInstanceKey: z.optional(zElementInstanceKeyFilterProperty),
  batchOperationId: z.optional(zStringFilterProperty),
  errorMessage: z.optional(zStringFilterProperty),
  hasRetriesLeft: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Whether the process has failed jobs with retries left."
  })),
  elementInstanceState: z.optional(zElementInstanceStateFilterProperty),
  elementId: z.optional(zStringFilterProperty),
  hasElementInstanceIncident: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Whether the element instance has an incident or not."
  })),
  incidentErrorHashCode: z.optional(zIntegerFilterProperty),
  tags: z.optional(zTagSet)
}).register(z.globalRegistry, {
  description: "Base process instance search filter."
});
var zAdvancedProcessDefinitionKeyFilter = z.object({
  "$eq": z.optional(zProcessDefinitionKey),
  "$neq": z.optional(zProcessDefinitionKey),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zProcessDefinitionKey).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$notIn": z.optional(z.array(zProcessDefinitionKey).register(z.globalRegistry, {
    description: "Checks if the property matches none of the provided values."
  }))
}).register(z.globalRegistry, {
  description: "Advanced ProcessDefinitionKey filter."
});
var zProcessDefinitionKeyFilterProperty = z.union([
  zProcessDefinitionKey,
  zAdvancedProcessDefinitionKeyFilter
]);
var zProcessInstanceFilterFields = zBaseProcessInstanceFilterFields.and(z.object({
  processDefinitionId: z.optional(zStringFilterProperty),
  processDefinitionName: z.optional(zStringFilterProperty),
  processDefinitionVersion: z.optional(zIntegerFilterProperty),
  processDefinitionVersionTag: z.optional(zStringFilterProperty),
  processDefinitionKey: z.optional(zProcessDefinitionKeyFilterProperty)
}).register(z.globalRegistry, {
  description: "Process instance search filter."
}));
var zProcessInstanceFilter = zProcessInstanceFilterFields.and(z.object({
  "$or": z.optional(z.array(zProcessInstanceFilterFields).register(z.globalRegistry, {
    description: 'Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.\n\nTop-level fields and the `$or` clause are combined using AND logic \u2014 meaning: (top-level filters) AND (any of the `$or` filters) must match.\n<br>\n<em>Example:</em>\n\n```json\n{\n  "state": "ACTIVE",\n  "tenantId": 123,\n  "$or": [\n    { "processDefinitionId": "process_v1" },\n    { "processDefinitionId": "process_v2", "hasIncident": true }\n  ]\n}\n```\nThis matches process instances that:\n\n<ul style="padding-left: 20px; margin-left: 20px;">\n  <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>\n  <li style="list-style-type: disc;">have tenant ID equal to <em>123</em></li>\n  <li style="list-style-type: disc;">and match either:\n    <ul style="padding-left: 20px; margin-left: 20px;">\n      <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>\n      <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>\n    </ul>\n  </li>\n</ul>\n<br>\n<p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.\n'
  }))
}));
var zProcessInstanceSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zProcessInstanceSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zProcessInstanceFilter)
}).register(z.globalRegistry, {
  description: "Process instance search request."
}));
var zIncidentSearchQuerySortRequest = z.object({
  field: z.enum([
    "incidentKey",
    "processDefinitionKey",
    "processDefinitionId",
    "processInstanceKey",
    "errorType",
    "errorMessage",
    "elementId",
    "elementInstanceKey",
    "creationTime",
    "state",
    "jobKey",
    "tenantId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zProcessInstanceIncidentSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zIncidentSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  }))
}));
var zAdvancedDecisionDefinitionKeyFilter = z.object({
  "$eq": z.optional(zDecisionDefinitionKey),
  "$neq": z.optional(zDecisionDefinitionKey),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zDecisionDefinitionKey).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$notIn": z.optional(z.array(zDecisionDefinitionKey).register(z.globalRegistry, {
    description: "Checks if the property matches none of the provided values."
  }))
}).register(z.globalRegistry, {
  description: "Advanced DecisionDefinitionKey filter."
});
var zDecisionDefinitionKeyFilterProperty = z.union([
  zDecisionDefinitionKey,
  zAdvancedDecisionDefinitionKeyFilter
]);
var zBasicStringFilterProperty = z.union([
  z.string().register(z.globalRegistry, {
    description: "Matches the value exactly."
  }),
  zBasicStringFilter
]);
var zAdvancedMessageSubscriptionKeyFilter = z.object({
  "$eq": z.optional(zMessageSubscriptionKey),
  "$neq": z.optional(zMessageSubscriptionKey),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zMessageSubscriptionKey).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$notIn": z.optional(z.array(zMessageSubscriptionKey).register(z.globalRegistry, {
    description: "Checks if the property matches none of the provided values."
  }))
}).register(z.globalRegistry, {
  description: "Advanced MessageSubscriptionKey filter."
});
var zMessageSubscriptionKeyFilterProperty = z.union([
  zMessageSubscriptionKey,
  zAdvancedMessageSubscriptionKeyFilter
]);
var zAdvancedJobKeyFilter = z.object({
  "$eq": z.optional(zJobKey),
  "$neq": z.optional(zJobKey),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zJobKey).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$notIn": z.optional(z.array(zJobKey).register(z.globalRegistry, {
    description: "Checks if the property matches none of the provided values."
  }))
}).register(z.globalRegistry, {
  description: "Advanced JobKey filter."
});
var zJobKeyFilterProperty = z.union([
  zJobKey,
  zAdvancedJobKeyFilter
]);
var zProcessDefinitionStatisticsFilter = zBaseProcessInstanceFilterFields.and(z.object({
  "$or": z.optional(z.array(zBaseProcessInstanceFilterFields).register(z.globalRegistry, {
    description: 'Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.\n\nTop-level fields and the `$or` clause are combined using AND logic \u2014 meaning: (top-level filters) AND (any of the `$or` filters) must match.\n<br>\n<em>Example:</em>\n\n```json\n{\n  "state": "ACTIVE",\n  "tenantId": 123,\n  "$or": [\n    { "processDefinitionId": "process_v1" },\n    { "processDefinitionId": "process_v2", "hasIncident": true }\n  ]\n}\n```\nThis matches process instances that:\n\n<ul style="padding-left: 20px; margin-left: 20px;">\n  <li style="list-style-type: disc;">are in <em>ACTIVE</em> state</li>\n  <li style="list-style-type: disc;">have tenant ID equal to <em>123</em></li>\n  <li style="list-style-type: disc;">and match either:\n    <ul style="padding-left: 20px; margin-left: 20px;">\n      <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v1</em>, or</li>\n      <li style="list-style-type: circle;"><code>processDefinitionId</code> is <em>process_v2</em> and <code>hasIncident</code> is <em>true</em></li>\n    </ul>\n  </li>\n</ul>\n<br>\n<p>Note: Using complex <code>$or</code> conditions may impact performance, use with caution in high-volume environments.\n'
  }))
}));
var zProcessInstanceResult = z.object({
  processDefinitionId: zProcessDefinitionId,
  processDefinitionName: z.string().register(z.globalRegistry, {
    description: "The process definition name."
  }),
  processDefinitionVersion: z.int().register(z.globalRegistry, {
    description: "The process definition version."
  }),
  processDefinitionVersionTag: z.optional(z.string().register(z.globalRegistry, {
    description: "The process definition version tag."
  })),
  startDate: z.iso.datetime().register(z.globalRegistry, {
    description: "The start date."
  }),
  endDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "The end date."
  })),
  state: zProcessInstanceStateEnum,
  hasIncident: z.boolean().register(z.globalRegistry, {
    description: "Whether this process instance has a related incident or not."
  }),
  tenantId: zTenantId,
  processInstanceKey: zProcessInstanceKey,
  processDefinitionKey: zProcessDefinitionKey,
  parentProcessInstanceKey: z.optional(zProcessInstanceKey),
  parentElementInstanceKey: z.optional(zElementInstanceKey),
  tags: z.optional(zTagSet)
}).register(z.globalRegistry, {
  description: "Process instance search response item."
});
var zProcessInstanceSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.array(zProcessInstanceResult).register(z.globalRegistry, {
    description: "The matching process instances."
  })
}).register(z.globalRegistry, {
  description: "Process instance search response."
}));
var zProcessInstanceCallHierarchyEntry = z.object({
  processInstanceKey: zProcessInstanceKey,
  processDefinitionKey: zProcessDefinitionKey,
  processDefinitionName: z.string().register(z.globalRegistry, {
    description: "The name of the process definition (fall backs to the process definition ID if not available)."
  })
});
var zProcessInstanceSequenceFlowResult = z.object({
  sequenceFlowId: z.optional(z.string().register(z.globalRegistry, {
    description: "The sequence flow ID."
  })),
  processInstanceKey: z.optional(zProcessInstanceKey),
  processDefinitionKey: z.optional(zProcessDefinitionKey),
  processDefinitionId: z.optional(zProcessDefinitionId),
  elementId: z.optional(zElementId),
  tenantId: z.optional(zTenantId)
}).register(z.globalRegistry, {
  description: "Process instance sequence flow result."
});
var zProcessInstanceSequenceFlowsQueryResult = z.object({
  items: z.optional(z.array(zProcessInstanceSequenceFlowResult).register(z.globalRegistry, {
    description: "The sequence flows."
  }))
}).register(z.globalRegistry, {
  description: "Process instance sequence flows query response."
});
var zProcessDefinitionElementStatisticsQuery = z.object({
  filter: z.optional(zProcessDefinitionStatisticsFilter)
}).register(z.globalRegistry, {
  description: "Process definition element statistics request."
});
var zProcessElementStatisticsResult = z.object({
  elementId: z.optional(zElementId),
  active: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "The total number of active instances of the element."
  })),
  canceled: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "The total number of canceled instances of the element."
  })),
  incidents: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "The total number of incidents for the element."
  })),
  completed: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "The total number of completed instances of the element."
  }))
}).register(z.globalRegistry, {
  description: "Process element statistics response."
});
var zProcessDefinitionElementStatisticsQueryResult = z.object({
  items: z.optional(z.array(zProcessElementStatisticsResult).register(z.globalRegistry, {
    description: "The element statistics."
  }))
}).register(z.globalRegistry, {
  description: "Process definition element statistics query response."
});
var zProcessInstanceElementStatisticsQueryResult = z.object({
  items: z.optional(z.array(zProcessElementStatisticsResult).register(z.globalRegistry, {
    description: "The element statistics."
  }))
}).register(z.globalRegistry, {
  description: "Process instance element statistics query response."
});
var zOperationReference = z.coerce.bigint().gte(BigInt(1)).register(z.globalRegistry, {
  description: "A reference key chosen by the user that will be part of all records resulting from this operation.\nMust be > 0 if provided.\n"
});
var zCancelProcessInstanceRequest = z.union([
  z.object({
    operationReference: z.optional(zOperationReference)
  }),
  z.null()
]);
var zElementInstanceSearchQuerySortRequest = z.object({
  field: z.enum([
    "elementInstanceKey",
    "processInstanceKey",
    "processDefinitionKey",
    "processDefinitionId",
    "startDate",
    "endDate",
    "elementId",
    "elementName",
    "type",
    "state",
    "incidentKey",
    "tenantId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zElementInstanceFilter = z.object({
  processDefinitionId: z.optional(zProcessDefinitionId),
  state: z.optional(zElementInstanceStateFilterProperty),
  type: z.optional(z.enum([
    "UNSPECIFIED",
    "PROCESS",
    "SUB_PROCESS",
    "EVENT_SUB_PROCESS",
    "AD_HOC_SUB_PROCESS",
    "AD_HOC_SUB_PROCESS_INNER_INSTANCE",
    "START_EVENT",
    "INTERMEDIATE_CATCH_EVENT",
    "INTERMEDIATE_THROW_EVENT",
    "BOUNDARY_EVENT",
    "END_EVENT",
    "SERVICE_TASK",
    "RECEIVE_TASK",
    "USER_TASK",
    "MANUAL_TASK",
    "TASK",
    "EXCLUSIVE_GATEWAY",
    "INCLUSIVE_GATEWAY",
    "PARALLEL_GATEWAY",
    "EVENT_BASED_GATEWAY",
    "SEQUENCE_FLOW",
    "MULTI_INSTANCE_BODY",
    "CALL_ACTIVITY",
    "BUSINESS_RULE_TASK",
    "SCRIPT_TASK",
    "SEND_TASK",
    "UNKNOWN"
  ]).register(z.globalRegistry, {
    description: "Type of element as defined set of values."
  })),
  elementId: z.optional(zElementId),
  elementName: z.optional(z.string().register(z.globalRegistry, {
    description: "The element name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.\n"
  })),
  hasIncident: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Shows whether this element instance has an incident related to."
  })),
  tenantId: z.optional(zTenantId),
  elementInstanceKey: z.optional(zElementInstanceKey),
  processInstanceKey: z.optional(zProcessInstanceKey),
  processDefinitionKey: z.optional(zProcessDefinitionKey),
  incidentKey: z.optional(zIncidentKey),
  startDate: z.optional(zDateTimeFilterProperty),
  endDate: z.optional(zDateTimeFilterProperty),
  elementInstanceScopeKey: z.optional(z.union([
    zElementInstanceKey,
    zProcessInstanceKey
  ]))
}).register(z.globalRegistry, {
  description: "Element instance filter."
});
var zElementInstanceSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zElementInstanceSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zElementInstanceFilter)
}).register(z.globalRegistry, {
  description: "Element instance search request."
}));
var zElementInstanceResult = z.object({
  processDefinitionId: zProcessDefinitionId,
  startDate: z.iso.datetime().register(z.globalRegistry, {
    description: "Date when element instance started."
  }),
  endDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "Date when element instance finished."
  })),
  elementId: zElementId,
  elementName: z.string().register(z.globalRegistry, {
    description: "The element name for this element instance."
  }),
  type: z.enum([
    "UNSPECIFIED",
    "PROCESS",
    "SUB_PROCESS",
    "EVENT_SUB_PROCESS",
    "AD_HOC_SUB_PROCESS",
    "AD_HOC_SUB_PROCESS_INNER_INSTANCE",
    "START_EVENT",
    "INTERMEDIATE_CATCH_EVENT",
    "INTERMEDIATE_THROW_EVENT",
    "BOUNDARY_EVENT",
    "END_EVENT",
    "SERVICE_TASK",
    "RECEIVE_TASK",
    "USER_TASK",
    "MANUAL_TASK",
    "TASK",
    "EXCLUSIVE_GATEWAY",
    "INCLUSIVE_GATEWAY",
    "PARALLEL_GATEWAY",
    "EVENT_BASED_GATEWAY",
    "SEQUENCE_FLOW",
    "MULTI_INSTANCE_BODY",
    "CALL_ACTIVITY",
    "BUSINESS_RULE_TASK",
    "SCRIPT_TASK",
    "SEND_TASK",
    "UNKNOWN"
  ]).register(z.globalRegistry, {
    description: "Type of element as defined set of values."
  }),
  state: zElementInstanceStateEnum,
  hasIncident: z.boolean().register(z.globalRegistry, {
    description: "Shows whether this element instance has an incident. If true also an incidentKey is provided."
  }),
  tenantId: zTenantId,
  elementInstanceKey: zElementInstanceKey,
  processInstanceKey: zProcessInstanceKey,
  processDefinitionKey: zProcessDefinitionKey,
  incidentKey: z.optional(zIncidentKey)
});
var zElementInstanceSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zElementInstanceResult).register(z.globalRegistry, {
    description: "The matching element instances."
  }))
}));
var zAdHocSubProcessActivateActivityReference = z.object({
  elementId: zElementId,
  variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "Variables to be set when activating the element."
  }))
});
var zAdHocSubProcessActivateActivitiesInstruction = z.object({
  elements: z.array(zAdHocSubProcessActivateActivityReference).register(z.globalRegistry, {
    description: "Activities to activate."
  }),
  cancelRemainingInstances: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Whether to cancel remaining instances of the ad-hoc sub-process."
  })).default(false)
});
var zDecisionDefinitionSearchQuerySortRequest = z.object({
  field: z.enum([
    "decisionDefinitionKey",
    "decisionDefinitionId",
    "name",
    "version",
    "decisionRequirementsId",
    "decisionRequirementsKey",
    "tenantId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zDecisionDefinitionFilter = z.object({
  decisionDefinitionId: z.optional(zDecisionDefinitionId),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The DMN name of the decision definition."
  })),
  version: z.optional(z.int().register(z.globalRegistry, {
    description: "The assigned version of the decision definition."
  })),
  decisionRequirementsId: z.optional(z.string().register(z.globalRegistry, {
    description: "the DMN ID of the decision requirements graph that the decision definition is part of."
  })),
  tenantId: z.optional(zTenantId),
  decisionDefinitionKey: z.optional(zDecisionDefinitionKey),
  decisionRequirementsKey: z.optional(zDecisionRequirementsKey)
}).register(z.globalRegistry, {
  description: "Decision definition search filter."
});
var zDecisionDefinitionSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zDecisionDefinitionSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zDecisionDefinitionFilter)
}));
var zIncidentFilter = z.object({
  processDefinitionId: z.optional(zProcessDefinitionId),
  errorType: z.optional(z.enum([
    "UNSPECIFIED",
    "UNKNOWN",
    "IO_MAPPING_ERROR",
    "JOB_NO_RETRIES",
    "EXECUTION_LISTENER_NO_RETRIES",
    "TASK_LISTENER_NO_RETRIES",
    "AD_HOC_SUB_PROCESS_NO_RETRIES",
    "CONDITION_ERROR",
    "EXTRACT_VALUE_ERROR",
    "CALLED_ELEMENT_ERROR",
    "UNHANDLED_ERROR_EVENT",
    "MESSAGE_SIZE_EXCEEDED",
    "CALLED_DECISION_ERROR",
    "DECISION_EVALUATION_ERROR",
    "FORM_NOT_FOUND",
    "RESOURCE_NOT_FOUND"
  ]).register(z.globalRegistry, {
    description: "Incident error type with a defined set of values."
  })),
  errorMessage: z.optional(z.string().register(z.globalRegistry, {
    description: "Error message which describes the error in more detail."
  })),
  elementId: z.optional(zElementId),
  creationTime: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "Date of incident creation."
  })),
  state: z.optional(z.enum([
    "ACTIVE",
    "MIGRATED",
    "RESOLVED",
    "PENDING"
  ]).register(z.globalRegistry, {
    description: "State of this incident with a defined set of values."
  })),
  tenantId: z.optional(zTenantId),
  incidentKey: z.optional(zIncidentKey),
  processDefinitionKey: z.optional(zProcessDefinitionKey),
  processInstanceKey: z.optional(zProcessInstanceKey),
  elementInstanceKey: z.optional(zElementInstanceKey),
  jobKey: z.optional(zJobKey)
}).register(z.globalRegistry, {
  description: "Incident search filter."
});
var zIncidentSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zIncidentSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zIncidentFilter)
}));
var zIncidentResult = z.object({
  processDefinitionId: z.optional(zProcessDefinitionId),
  errorType: z.optional(z.enum([
    "UNSPECIFIED",
    "UNKNOWN",
    "IO_MAPPING_ERROR",
    "JOB_NO_RETRIES",
    "EXECUTION_LISTENER_NO_RETRIES",
    "TASK_LISTENER_NO_RETRIES",
    "AD_HOC_SUB_PROCESS_NO_RETRIES",
    "CONDITION_ERROR",
    "EXTRACT_VALUE_ERROR",
    "CALLED_ELEMENT_ERROR",
    "UNHANDLED_ERROR_EVENT",
    "MESSAGE_SIZE_EXCEEDED",
    "CALLED_DECISION_ERROR",
    "DECISION_EVALUATION_ERROR",
    "FORM_NOT_FOUND",
    "RESOURCE_NOT_FOUND"
  ]).register(z.globalRegistry, {
    description: "Incident error type with a defined set of values."
  })),
  errorMessage: z.optional(z.string().register(z.globalRegistry, {
    description: "Error message which describes the error in more detail."
  })),
  elementId: z.optional(zElementId),
  creationTime: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "Date of incident creation."
  })),
  state: z.optional(z.enum([
    "ACTIVE",
    "MIGRATED",
    "RESOLVED",
    "PENDING"
  ]).register(z.globalRegistry, {
    description: "State of this incident with a defined set of values."
  })),
  tenantId: z.optional(zTenantId),
  incidentKey: z.optional(zIncidentKey),
  processDefinitionKey: z.optional(zProcessDefinitionKey),
  processInstanceKey: z.optional(zProcessInstanceKey),
  elementInstanceKey: z.optional(zElementInstanceKey),
  jobKey: z.optional(zJobKey)
});
var zIncidentSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zIncidentResult).register(z.globalRegistry, {
    description: "The matching incidents."
  }))
}));
var zCorrelatedMessageSubscriptionResult = z.object({
  correlationKey: z.string().register(z.globalRegistry, {
    description: "The correlation key of the message."
  }),
  correlationTime: z.iso.datetime().register(z.globalRegistry, {
    description: "The time when the message was correlated."
  }),
  elementId: z.string().register(z.globalRegistry, {
    description: "The element ID that received the message."
  }),
  elementInstanceKey: z.optional(zElementInstanceKey),
  messageKey: zMessageKey,
  messageName: z.string().register(z.globalRegistry, {
    description: "The name of the message."
  }),
  partitionId: z.int().register(z.globalRegistry, {
    description: "The partition ID that correlated the message."
  }),
  processDefinitionId: zProcessDefinitionId,
  processDefinitionKey: z.optional(zProcessDefinitionKey),
  processInstanceKey: zProcessInstanceKey,
  subscriptionKey: zMessageSubscriptionKey,
  tenantId: zTenantId
});
var zCorrelatedMessageSubscriptionSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zCorrelatedMessageSubscriptionResult).register(z.globalRegistry, {
    description: "The matching correlated message subscriptions."
  }))
}));
var zCorrelatedMessageSubscriptionSearchQuerySortRequest = z.object({
  field: z.enum([
    "correlationKey",
    "correlationTime",
    "elementId",
    "elementInstanceKey",
    "messageKey",
    "messageName",
    "partitionId",
    "processDefinitionId",
    "processDefinitionKey",
    "processInstanceKey",
    "subscriptionKey",
    "tenantId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zCorrelatedMessageSubscriptionFilter = z.object({
  correlationKey: z.optional(zStringFilterProperty),
  correlationTime: z.optional(zDateTimeFilterProperty),
  elementId: z.optional(zStringFilterProperty),
  elementInstanceKey: z.optional(zElementInstanceKeyFilterProperty),
  messageKey: z.optional(zBasicStringFilterProperty),
  messageName: z.optional(zStringFilterProperty),
  partitionId: z.optional(zIntegerFilterProperty),
  processDefinitionId: z.optional(zStringFilterProperty),
  processDefinitionKey: z.optional(zBasicStringFilterProperty),
  processInstanceKey: z.optional(zBasicStringFilterProperty),
  subscriptionKey: z.optional(zBasicStringFilterProperty),
  tenantId: z.optional(zStringFilterProperty)
}).register(z.globalRegistry, {
  description: "Correlated message subscriptions search filter."
});
var zCorrelatedMessageSubscriptionSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zCorrelatedMessageSubscriptionSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zCorrelatedMessageSubscriptionFilter)
}));
var zMessageSubscriptionStateEnum = z.enum([
  "CORRELATED",
  "CREATED",
  "DELETED",
  "MIGRATED"
]).register(z.globalRegistry, {
  description: "The state of message subscription."
});
var zMessageSubscriptionResult = z.object({
  messageSubscriptionKey: z.optional(zMessageSubscriptionKey),
  processDefinitionId: z.optional(zProcessDefinitionId),
  processDefinitionKey: z.optional(zProcessDefinitionKey),
  processInstanceKey: z.optional(zProcessInstanceKey),
  elementId: z.optional(zElementId),
  elementInstanceKey: z.optional(zElementInstanceKey),
  messageSubscriptionState: z.optional(zMessageSubscriptionStateEnum),
  lastUpdatedDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "The last updated date of the message subscription."
  })),
  messageName: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the message associated with the message subscription."
  })),
  correlationKey: z.optional(zMessageCorrelationKey),
  tenantId: z.optional(zTenantId)
});
var zMessageSubscriptionSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zMessageSubscriptionResult).register(z.globalRegistry, {
    description: "The matching message subscriptions."
  }))
}));
var zMessageSubscriptionSearchQuerySortRequest = z.object({
  field: z.enum([
    "messageSubscriptionKey",
    "processDefinitionId",
    "processInstanceKey",
    "elementId",
    "elementInstanceKey",
    "messageSubscriptionState",
    "lastUpdatedDate",
    "messageName",
    "correlationKey",
    "tenantId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zAdvancedMessageSubscriptionStateFilter = z.object({
  "$eq": z.optional(zMessageSubscriptionStateEnum),
  "$neq": z.optional(zMessageSubscriptionStateEnum),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zMessageSubscriptionStateEnum).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$like": z.optional(zLikeFilter)
}).register(z.globalRegistry, {
  description: "Advanced MessageSubscriptionStateEnum filter"
});
var zMessageSubscriptionStateFilterProperty = z.union([
  zMessageSubscriptionStateEnum,
  zAdvancedMessageSubscriptionStateFilter
]);
var zMessageSubscriptionFilter = z.object({
  messageSubscriptionKey: z.optional(zMessageSubscriptionKeyFilterProperty),
  processDefinitionId: z.optional(zStringFilterProperty),
  processInstanceKey: z.optional(zProcessInstanceKeyFilterProperty),
  elementId: z.optional(zStringFilterProperty),
  elementInstanceKey: z.optional(zElementInstanceKeyFilterProperty),
  messageSubscriptionState: z.optional(zMessageSubscriptionStateFilterProperty),
  lastUpdatedDate: z.optional(zDateTimeFilterProperty),
  messageName: z.optional(zStringFilterProperty),
  correlationKey: z.optional(zStringFilterProperty),
  tenantId: z.optional(zStringFilterProperty)
}).register(z.globalRegistry, {
  description: "Message subscription search filter."
});
var zMessageSubscriptionSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zMessageSubscriptionSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zMessageSubscriptionFilter)
}));
var zDecisionDefinitionResult = z.object({
  decisionDefinitionId: z.optional(zDecisionDefinitionId),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The DMN name of the decision definition."
  })),
  version: z.optional(z.int().register(z.globalRegistry, {
    description: "The assigned version of the decision definition."
  })),
  decisionRequirementsId: z.optional(z.string().register(z.globalRegistry, {
    description: "the DMN ID of the decision requirements graph that the decision definition is part of."
  })),
  tenantId: z.optional(zTenantId),
  decisionDefinitionKey: z.optional(zDecisionDefinitionKey),
  decisionRequirementsKey: z.optional(zDecisionRequirementsKey)
});
var zDecisionDefinitionSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zDecisionDefinitionResult).register(z.globalRegistry, {
    description: "The matching decision definitions."
  }))
}));
var zUsageMetricsResponseItem = z.object({
  processInstances: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "The amount of created root process instances."
  })),
  decisionInstances: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "The amount of executed decision instances."
  })),
  assignees: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "The amount of unique active task users."
  }))
});
var zUsageMetricsResponse = zUsageMetricsResponseItem.and(z.object({
  activeTenants: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "The amount of active tenants."
  })),
  tenants: z.optional(z.record(z.string(), zUsageMetricsResponseItem).register(z.globalRegistry, {
    description: "The usage metrics by tenants. Only available if request `withTenants` query parameter was `true`."
  }))
}));
var zPermissionTypeEnum = z.enum([
  "ACCESS",
  "CREATE",
  "CREATE_BATCH_OPERATION_CANCEL_PROCESS_INSTANCE",
  "CREATE_BATCH_OPERATION_DELETE_PROCESS_INSTANCE",
  "CREATE_BATCH_OPERATION_MIGRATE_PROCESS_INSTANCE",
  "CREATE_BATCH_OPERATION_MODIFY_PROCESS_INSTANCE",
  "CREATE_BATCH_OPERATION_RESOLVE_INCIDENT",
  "CREATE_BATCH_OPERATION_DELETE_DECISION_INSTANCE",
  "CREATE_BATCH_OPERATION_DELETE_DECISION_DEFINITION",
  "CREATE_BATCH_OPERATION_DELETE_PROCESS_DEFINITION",
  "CREATE_PROCESS_INSTANCE",
  "CREATE_DECISION_INSTANCE",
  "READ",
  "READ_PROCESS_INSTANCE",
  "READ_USER_TASK",
  "READ_DECISION_INSTANCE",
  "READ_PROCESS_DEFINITION",
  "READ_DECISION_DEFINITION",
  "READ_USAGE_METRIC",
  "UPDATE",
  "UPDATE_PROCESS_INSTANCE",
  "UPDATE_USER_TASK",
  "CANCEL_PROCESS_INSTANCE",
  "MODIFY_PROCESS_INSTANCE",
  "DELETE",
  "DELETE_PROCESS",
  "DELETE_DRD",
  "DELETE_FORM",
  "DELETE_RESOURCE",
  "DELETE_PROCESS_INSTANCE",
  "DELETE_DECISION_INSTANCE"
]).register(z.globalRegistry, {
  description: "Specifies the type of permissions."
});
var zResourceTypeEnum = z.enum([
  "AUTHORIZATION",
  "MAPPING_RULE",
  "MESSAGE",
  "BATCH",
  "COMPONENT",
  "SYSTEM",
  "TENANT",
  "RESOURCE",
  "PROCESS_DEFINITION",
  "DECISION_REQUIREMENTS_DEFINITION",
  "DECISION_DEFINITION",
  "GROUP",
  "USER",
  "ROLE",
  "DOCUMENT"
]).register(z.globalRegistry, {
  description: "The type of resource to add/remove permissions to/from."
});
var zOwnerTypeEnum = z.enum([
  "USER",
  "CLIENT",
  "ROLE",
  "GROUP",
  "MAPPING_RULE",
  "UNSPECIFIED"
]).register(z.globalRegistry, {
  description: "The type of the owner of permissions."
});
var zAuthorizationRequest = z.object({
  ownerId: z.string().register(z.globalRegistry, {
    description: "The ID of the owner of the permissions."
  }),
  ownerType: zOwnerTypeEnum,
  resourceId: z.string().register(z.globalRegistry, {
    description: "The ID of the resource to add permissions to."
  }),
  resourceType: zResourceTypeEnum,
  permissionTypes: z.array(zPermissionTypeEnum).register(z.globalRegistry, {
    description: "The permission types to add."
  })
});
var zAuthorizationCreateResult = z.object({
  authorizationKey: z.optional(zAuthorizationKey)
});
var zAuthorizationSearchQuerySortRequest = z.object({
  field: z.enum([
    "ownerId",
    "ownerType",
    "resourceId",
    "resourceType"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zAuthorizationFilter = z.object({
  ownerId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the owner of permissions."
  })),
  ownerType: z.optional(zOwnerTypeEnum),
  resourceIds: z.optional(z.array(z.string()).register(z.globalRegistry, {
    description: "The IDs of the resource to search permissions for."
  })),
  resourceType: z.optional(zResourceTypeEnum)
}).register(z.globalRegistry, {
  description: "Authorization search filter."
});
var zAuthorizationSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zAuthorizationSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zAuthorizationFilter)
}));
var zAuthorizationResult = z.object({
  ownerId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the owner of permissions."
  })),
  ownerType: z.optional(zOwnerTypeEnum),
  resourceType: z.optional(zResourceTypeEnum),
  resourceId: z.optional(z.string().register(z.globalRegistry, {
    description: "ID of the resource the permission relates to."
  })),
  permissionTypes: z.optional(z.array(zPermissionTypeEnum).register(z.globalRegistry, {
    description: "Specifies the types of the permissions."
  })),
  authorizationKey: z.optional(zAuthorizationKey)
});
var zAuthorizationSearchResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zAuthorizationResult).register(z.globalRegistry, {
    description: "The matching authorizations."
  }))
}));
var zUserRequest = z.object({
  password: z.string().register(z.globalRegistry, {
    description: "The password of the user."
  }),
  username: z.string().register(z.globalRegistry, {
    description: "The username of the user."
  }),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the user."
  })),
  email: z.optional(z.string().register(z.globalRegistry, {
    description: "The email of the user."
  }))
});
var zUsername = z.string().min(1).max(256).regex(/^(<default>|[A-Za-z0-9_@.+-]+)$/).register(z.globalRegistry, {
  description: "The unique name of a user."
});
var zUserCreateResult = z.object({
  username: z.optional(zUsername),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the user."
  })),
  email: z.optional(z.string().register(z.globalRegistry, {
    description: "The email of the user."
  }))
});
var zUserUpdateResult = z.object({
  username: z.optional(zUsername),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the user."
  })),
  email: z.optional(z.string().register(z.globalRegistry, {
    description: "The email of the user."
  }))
});
var zUserSearchQuerySortRequest = z.object({
  field: z.enum([
    "username",
    "name",
    "email"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zUserFilter = z.object({
  username: z.optional(zStringFilterProperty),
  name: z.optional(zStringFilterProperty),
  email: z.optional(zStringFilterProperty)
}).register(z.globalRegistry, {
  description: "User search filter."
});
var zUserSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zUserSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zUserFilter)
}));
var zMappingRuleSearchQuerySortRequest = z.object({
  field: z.enum([
    "mappingRuleId",
    "claimName",
    "claimValue",
    "name"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zMappingRuleFilter = z.object({
  claimName: z.optional(z.string().register(z.globalRegistry, {
    description: "The claim name to match against a token."
  })),
  claimValue: z.optional(z.string().register(z.globalRegistry, {
    description: "The value of the claim to match."
  })),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the mapping rule."
  })),
  mappingRuleId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the mapping rule."
  }))
}).register(z.globalRegistry, {
  description: "Mapping rule search filter."
});
var zMappingRuleSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zMappingRuleSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zMappingRuleFilter)
}));
var zCamundaUserResult = z.object({
  username: z.optional(z.union([
    zUsername,
    z.null()
  ])),
  displayName: z.optional(z.union([
    z.string(),
    z.null()
  ])),
  email: z.optional(z.union([
    z.string(),
    z.null()
  ])),
  authorizedComponents: z.optional(z.array(z.string()).register(z.globalRegistry, {
    description: "The web components the user is authorized to use."
  })),
  tenants: z.array(zTenantResult).register(z.globalRegistry, {
    description: "The tenants the user is a member of."
  }),
  groups: z.array(z.string()).register(z.globalRegistry, {
    description: "The groups assigned to the user."
  }),
  roles: z.array(z.string()).register(z.globalRegistry, {
    description: "The roles assigned to the user."
  }),
  salesPlanType: z.string().register(z.globalRegistry, {
    description: "The plan of the user."
  }),
  c8Links: z.record(z.string(), z.string()).register(z.globalRegistry, {
    description: "The links to the components in the C8 stack."
  }),
  canLogout: z.boolean().register(z.globalRegistry, {
    description: "Flag for understanding if the user is able to perform logout."
  })
});
var zUserResult = z.object({
  username: z.optional(zUsername),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the user."
  })),
  email: z.optional(z.string().register(z.globalRegistry, {
    description: "The email of the user."
  }))
});
var zUserSearchResult = zSearchQueryResponse.and(z.object({
  items: z.array(zUserResult).register(z.globalRegistry, {
    description: "The matching users."
  })
}));
var zUserUpdateRequest = z.object({
  password: z.optional(z.string().register(z.globalRegistry, {
    description: "The password of the user. If blank, the password is unchanged."
  })),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the user."
  })),
  email: z.optional(z.string().register(z.globalRegistry, {
    description: "The email of the user."
  }))
});
var zTenantClientResult = z.object({
  clientId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the client."
  }))
});
var zTenantClientSearchResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zTenantClientResult).register(z.globalRegistry, {
    description: "The matching clients."
  }))
}));
var zTenantClientSearchQuerySortRequest = z.object({
  field: z.enum([
    "clientId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zTenantClientSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zTenantClientSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  }))
}));
var zTenantUserResult = z.object({
  username: z.optional(zUsername)
});
var zTenantUserSearchResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zTenantUserResult).register(z.globalRegistry, {
    description: "The matching users."
  }))
}));
var zTenantUserSearchQuerySortRequest = z.object({
  field: z.enum([
    "username"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zTenantUserSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zTenantUserSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  }))
}));
var zTenantGroupResult = z.object({
  groupId: z.optional(z.string().register(z.globalRegistry, {
    description: "The groupId of the group."
  }))
});
var zTenantGroupSearchResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zTenantGroupResult).register(z.globalRegistry, {
    description: "The matching groups."
  }))
}));
var zTenantGroupSearchQuerySortRequest = z.object({
  field: z.enum([
    "groupId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zTenantGroupSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zTenantGroupSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  }))
}));
var zRoleCreateRequest = z.object({
  roleId: z.string().register(z.globalRegistry, {
    description: "The ID of the new role."
  }),
  name: z.string().register(z.globalRegistry, {
    description: "The display name of the new role."
  }),
  description: z.optional(z.string().register(z.globalRegistry, {
    description: "The description of the new role."
  }))
});
var zRoleCreateResult = z.object({
  roleId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the created role."
  })),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The display name of the created role."
  })),
  description: z.optional(z.string().register(z.globalRegistry, {
    description: "The description of the created role."
  }))
});
var zRoleUpdateRequest = z.object({
  name: z.string().register(z.globalRegistry, {
    description: "The display name of the new role."
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The description of the new role."
  })
});
var zRoleUpdateResult = z.object({
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The display name of the updated role."
  })),
  description: z.optional(z.string().register(z.globalRegistry, {
    description: "The description of the updated role."
  })),
  roleId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the updated role."
  }))
});
var zRoleResult = z.object({
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The role name."
  })),
  roleId: z.optional(z.string().register(z.globalRegistry, {
    description: "The role id."
  })),
  description: z.optional(z.string().register(z.globalRegistry, {
    description: "The description of the role."
  }))
}).register(z.globalRegistry, {
  description: "Role search response item."
});
var zRoleSearchQuerySortRequest = z.object({
  field: z.enum([
    "name",
    "roleId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zRoleFilter = z.object({
  roleId: z.optional(z.string().register(z.globalRegistry, {
    description: "The role ID search filters."
  })),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The role name search filters."
  }))
}).register(z.globalRegistry, {
  description: "Role filter request"
});
var zRoleSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zRoleSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zRoleFilter)
}).register(z.globalRegistry, {
  description: "Role search request."
}));
var zRoleSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zRoleResult).register(z.globalRegistry, {
    description: "The matching roles."
  }))
}).register(z.globalRegistry, {
  description: "Role search response."
}));
var zRoleUserResult = z.object({
  username: z.optional(zUsername)
});
var zRoleUserSearchResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zRoleUserResult).register(z.globalRegistry, {
    description: "The matching users."
  }))
}));
var zRoleUserSearchQuerySortRequest = z.object({
  field: z.enum([
    "username"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zRoleUserSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zRoleUserSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  }))
}));
var zRoleClientResult = z.object({
  clientId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the client."
  }))
});
var zRoleClientSearchResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zRoleClientResult).register(z.globalRegistry, {
    description: "The matching clients."
  }))
}));
var zRoleClientSearchQuerySortRequest = z.object({
  field: z.enum([
    "clientId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zRoleClientSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zRoleClientSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  }))
}));
var zRoleGroupResult = z.object({
  groupId: z.optional(z.string().register(z.globalRegistry, {
    description: "The id of the group."
  }))
});
var zRoleGroupSearchResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zRoleGroupResult).register(z.globalRegistry, {
    description: "The matching groups."
  }))
}));
var zRoleGroupSearchQuerySortRequest = z.object({
  field: z.enum([
    "groupId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zRoleGroupSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zRoleGroupSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  }))
}));
var zGroupCreateRequest = z.object({
  groupId: z.string().register(z.globalRegistry, {
    description: "The ID of the new group."
  }),
  name: z.string().register(z.globalRegistry, {
    description: "The display name of the new group."
  }),
  description: z.optional(z.string().register(z.globalRegistry, {
    description: "The description of the new group."
  }))
});
var zGroupCreateResult = z.object({
  groupId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the created group."
  })),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The display name of the created group."
  })),
  description: z.optional(z.string().register(z.globalRegistry, {
    description: "The description of the created group."
  }))
});
var zGroupUpdateRequest = z.object({
  name: z.string().register(z.globalRegistry, {
    description: "The new name of the group."
  }),
  description: z.string().register(z.globalRegistry, {
    description: "The new description of the group."
  })
});
var zGroupUpdateResult = z.object({
  groupId: z.optional(z.string().register(z.globalRegistry, {
    description: "The unique external group ID."
  })),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the group."
  })),
  description: z.optional(z.string().register(z.globalRegistry, {
    description: "The description of the group."
  }))
});
var zGroupResult = z.object({
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The group name."
  })),
  groupId: z.optional(z.string().register(z.globalRegistry, {
    description: "The group ID."
  })),
  description: z.optional(z.string().register(z.globalRegistry, {
    description: "The group description."
  }))
}).register(z.globalRegistry, {
  description: "Group search response item."
});
var zGroupSearchQuerySortRequest = z.object({
  field: z.enum([
    "name",
    "groupId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zGroupFilter = z.object({
  groupId: z.optional(zStringFilterProperty),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The group name search filters."
  }))
}).register(z.globalRegistry, {
  description: "Group filter request"
});
var zGroupSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zGroupSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zGroupFilter)
}).register(z.globalRegistry, {
  description: "Group search request."
}));
var zGroupSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zGroupResult).register(z.globalRegistry, {
    description: "The matching groups."
  }))
}).register(z.globalRegistry, {
  description: "Group search response."
}));
var zGroupUserResult = z.object({
  username: z.optional(zUsername)
});
var zGroupUserSearchResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zGroupUserResult).register(z.globalRegistry, {
    description: "The matching members."
  }))
}));
var zGroupUserSearchQuerySortRequest = z.object({
  field: z.enum([
    "username"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zGroupUserSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zGroupUserSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  }))
}));
var zGroupClientResult = z.object({
  clientId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the client."
  }))
});
var zGroupClientSearchResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zGroupClientResult).register(z.globalRegistry, {
    description: "The matching client IDs."
  }))
}));
var zGroupClientSearchQuerySortRequest = z.object({
  field: z.enum([
    "clientId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zGroupClientSearchQueryRequest = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zGroupClientSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  }))
}));
var zMappingRuleCreateUpdateRequest = z.object({
  claimName: z.string().register(z.globalRegistry, {
    description: "The name of the claim to map."
  }),
  claimValue: z.string().register(z.globalRegistry, {
    description: "The value of the claim to map."
  }),
  name: z.string().register(z.globalRegistry, {
    description: "The name of the mapping rule."
  })
});
var zMappingRuleCreateRequest = zMappingRuleCreateUpdateRequest.and(z.object({
  mappingRuleId: z.string().register(z.globalRegistry, {
    description: "The unique ID of the mapping rule."
  })
}));
var zMappingRuleUpdateRequest = zMappingRuleCreateUpdateRequest;
var zMappingRuleCreateUpdateResult = z.object({
  claimName: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the claim to map."
  })),
  claimValue: z.optional(z.string().register(z.globalRegistry, {
    description: "The value of the claim to map."
  })),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the mapping rule."
  })),
  mappingRuleId: z.optional(z.string().register(z.globalRegistry, {
    description: "The unique ID of the mapping rule."
  }))
});
var zMappingRuleCreateResult = zMappingRuleCreateUpdateResult;
var zMappingRuleUpdateResult = zMappingRuleCreateUpdateResult;
var zMappingRuleResult = z.object({
  claimName: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the claim to map."
  })),
  claimValue: z.optional(z.string().register(z.globalRegistry, {
    description: "The value of the claim to map."
  })),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the mapping rule."
  })),
  mappingRuleId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the mapping rule."
  }))
});
var zMappingRuleSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zMappingRuleResult).register(z.globalRegistry, {
    description: "The matching mapping rules."
  }))
}));
var zPartition = z.object({
  partitionId: z.int().register(z.globalRegistry, {
    description: "The unique ID of this partition."
  }),
  role: z.enum([
    "leader",
    "follower",
    "inactive"
  ]).register(z.globalRegistry, {
    description: "Describes the Raft role of the broker for a given partition."
  }),
  health: z.enum([
    "healthy",
    "unhealthy",
    "dead"
  ]).register(z.globalRegistry, {
    description: "Describes the current health of the partition."
  })
}).register(z.globalRegistry, {
  description: "Provides information on a partition within a broker node."
});
var zBrokerInfo = z.object({
  nodeId: z.int().register(z.globalRegistry, {
    description: "The unique (within a cluster) node ID for the broker."
  }),
  host: z.string().register(z.globalRegistry, {
    description: "The hostname for reaching the broker."
  }),
  port: z.int().register(z.globalRegistry, {
    description: "The port for reaching the broker."
  }),
  partitions: z.array(zPartition).register(z.globalRegistry, {
    description: "A list of partitions managed or replicated on this broker."
  }),
  version: z.string().register(z.globalRegistry, {
    description: "The broker version."
  })
}).register(z.globalRegistry, {
  description: "Provides information on a broker node."
});
var zTopologyResponse = z.object({
  brokers: z.array(zBrokerInfo).register(z.globalRegistry, {
    description: "A list of brokers that are part of this cluster."
  }),
  clusterSize: z.int().register(z.globalRegistry, {
    description: "The number of brokers in the cluster."
  }),
  partitionsCount: z.int().register(z.globalRegistry, {
    description: "The number of partitions are spread across the cluster."
  }),
  replicationFactor: z.int().register(z.globalRegistry, {
    description: "The configured replication factor for this cluster."
  }),
  gatewayVersion: z.string().register(z.globalRegistry, {
    description: "The version of the Zeebe Gateway."
  }),
  lastCompletedChangeId: z.string().register(z.globalRegistry, {
    description: "ID of the last completed change"
  })
}).register(z.globalRegistry, {
  description: "The response of a topology request."
});
var zLicenseResponse = z.object({
  validLicense: z.boolean().register(z.globalRegistry, {
    description: "True if the Camunda license is valid, false if otherwise"
  }),
  licenseType: z.string().register(z.globalRegistry, {
    description: "Will return the license type property of the Camunda license"
  }),
  isCommercial: z.boolean().register(z.globalRegistry, {
    description: "Will be false when a license contains a non-commerical=true property"
  }),
  expiresAt: z.optional(z.union([
    z.iso.datetime(),
    z.null()
  ]))
}).register(z.globalRegistry, {
  description: "The response of a license request."
});
var zUserTaskCompletionRequest = z.object({
  variables: z.optional(z.union([
    z.record(z.string(), z.unknown()),
    z.null()
  ])),
  action: z.optional(z.union([
    z.string(),
    z.null()
  ]))
});
var zUserTaskAssignmentRequest = z.object({
  assignee: z.string().register(z.globalRegistry, {
    description: "The assignee for the user task. The assignee must not be empty or `null`."
  }),
  allowOverride: z.optional(z.union([
    z.boolean(),
    z.null()
  ])),
  action: z.optional(z.union([
    z.string(),
    z.null()
  ]))
});
var zChangeset = z.union([
  z.object({
    dueDate: z.optional(z.union([
      z.iso.datetime(),
      z.null()
    ])),
    followUpDate: z.optional(z.union([
      z.iso.datetime(),
      z.null()
    ])),
    candidateUsers: z.optional(z.union([
      z.array(z.string()),
      z.null()
    ])),
    candidateGroups: z.optional(z.union([
      z.array(z.string()),
      z.null()
    ])),
    priority: z.optional(z.union([
      z.int().gte(0).lte(100).default(50),
      z.null()
    ])).default(50)
  }),
  z.null()
]);
var zUserTaskUpdateRequest = z.object({
  changeset: z.optional(zChangeset),
  action: z.optional(z.union([
    z.string(),
    z.null()
  ]))
});
var zClockPinRequest = z.object({
  timestamp: z.coerce.bigint().register(z.globalRegistry, {
    description: "The exact time in epoch milliseconds to which the clock should be pinned."
  })
});
var zJobActivationRequest = z.object({
  type: z.string().register(z.globalRegistry, {
    description: 'The job type, as defined in the BPMN process (e.g. <zeebe:taskDefinition type="payment-service" />).\n'
  }),
  worker: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the worker activating the jobs, mostly used for logging purposes."
  })),
  timeout: z.coerce.bigint().register(z.globalRegistry, {
    description: "A job returned after this call will not be activated by another call until the timeout (in ms) has been reached.\n"
  }),
  maxJobsToActivate: z.int().register(z.globalRegistry, {
    description: "The maximum jobs to activate by this request."
  }),
  fetchVariable: z.optional(z.array(z.string()).register(z.globalRegistry, {
    description: "A list of variables to fetch as the job variables; if empty, all visible variables at the time of activation for the scope of the job will be returned.\n"
  })),
  requestTimeout: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "The request will be completed when at least one job is activated or after the requestTimeout (in ms). If the requestTimeout = 0, a default timeout is used. If the requestTimeout < 0, long polling is disabled and the request is completed immediately, even when no job is activated.\n"
  })).default(BigInt(0)),
  tenantIds: z.optional(z.array(zTenantId).register(z.globalRegistry, {
    description: "A list of IDs of tenants for which to activate jobs."
  }))
});
var zJobKindEnum = z.enum([
  "BPMN_ELEMENT",
  "EXECUTION_LISTENER",
  "TASK_LISTENER",
  "AD_HOC_SUB_PROCESS"
]).register(z.globalRegistry, {
  description: "The job kind."
});
var zJobListenerEventTypeEnum = z.enum([
  "ASSIGNING",
  "CANCELING",
  "COMPLETING",
  "CREATING",
  "END",
  "START",
  "UNSPECIFIED",
  "UPDATING"
]).register(z.globalRegistry, {
  description: "The listener event type of the job."
});
var zUserTaskProperties = z.object({
  action: z.optional(z.string().register(z.globalRegistry, {
    description: "The action performed on the user task."
  })),
  assignee: z.optional(z.union([
    z.string(),
    z.null()
  ])),
  candidateGroups: z.optional(z.array(z.string()).register(z.globalRegistry, {
    description: "The groups eligible to claim the task."
  })),
  candidateUsers: z.optional(z.array(z.string()).register(z.globalRegistry, {
    description: "The users eligible to claim the task."
  })),
  changedAttributes: z.optional(z.array(z.string()).register(z.globalRegistry, {
    description: "The attributes that were changed in the task."
  })),
  dueDate: z.optional(z.union([
    z.iso.datetime(),
    z.null()
  ])),
  followUpDate: z.optional(z.union([
    z.iso.datetime(),
    z.null()
  ])),
  formKey: z.optional(zFormKey),
  priority: z.optional(z.union([
    z.int().gte(0).lte(100),
    z.null()
  ])),
  userTaskKey: z.optional(z.union([
    zUserTaskKey,
    z.null()
  ]))
}).register(z.globalRegistry, {
  description: "Contains properties of a user task."
});
var zActivatedJobResult = z.object({
  type: z.string().register(z.globalRegistry, {
    description: "The type of the job (should match what was requested)."
  }),
  processDefinitionId: zProcessDefinitionId,
  processDefinitionVersion: z.int().register(z.globalRegistry, {
    description: "The version of the job's process definition."
  }),
  elementId: zElementId,
  customHeaders: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "A set of custom headers defined during modelling; returned as a serialized JSON document."
  }),
  worker: z.string().register(z.globalRegistry, {
    description: "The name of the worker which activated this job."
  }),
  retries: z.int().register(z.globalRegistry, {
    description: "The amount of retries left to this job (should always be positive)."
  }),
  deadline: z.coerce.bigint().register(z.globalRegistry, {
    description: "When the job can be activated again, sent as a UNIX epoch timestamp."
  }),
  variables: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "All variables visible to the task scope, computed at activation time."
  }),
  tenantId: zTenantId,
  jobKey: zJobKey,
  processInstanceKey: zProcessInstanceKey,
  processDefinitionKey: zProcessDefinitionKey,
  elementInstanceKey: zElementInstanceKey,
  kind: zJobKindEnum,
  listenerEventType: zJobListenerEventTypeEnum,
  userTask: z.optional(zUserTaskProperties),
  tags: z.optional(zTagSet)
});
var zJobActivationResult = z.object({
  jobs: z.array(zActivatedJobResult).register(z.globalRegistry, {
    description: "The activated jobs."
  })
}).register(z.globalRegistry, {
  description: "The list of activated jobs"
});
var zJobFailRequest = z.object({
  retries: z.optional(z.int().register(z.globalRegistry, {
    description: "The amount of retries the job should have left\n"
  })).default(0),
  errorMessage: z.optional(z.string().register(z.globalRegistry, {
    description: "An optional message describing why the job failed. This is particularly useful if a job runs out of retries and an incident is raised, as this message can help explain why an incident was raised.\n"
  })),
  retryBackOff: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "The backoff timeout (in ms) for the next retry.\n"
  })).default(BigInt(0)),
  variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "JSON object that will instantiate the variables at the local scope of the job's associated task.\n"
  }))
});
var zJobErrorRequest = z.object({
  errorCode: z.string().register(z.globalRegistry, {
    description: "The error code that will be matched with an error catch event.\n"
  }),
  errorMessage: z.optional(z.union([
    z.string(),
    z.null()
  ])),
  variables: z.optional(z.union([
    z.record(z.string(), z.unknown()),
    z.null()
  ]))
});
var zJobResultCorrections = z.union([
  z.object({
    assignee: z.optional(z.union([
      z.string(),
      z.null()
    ])),
    dueDate: z.optional(z.union([
      z.iso.datetime(),
      z.null()
    ])),
    followUpDate: z.optional(z.union([
      z.iso.datetime(),
      z.null()
    ])),
    candidateUsers: z.optional(z.union([
      z.array(z.string()),
      z.null()
    ])),
    candidateGroups: z.optional(z.union([
      z.array(z.string()),
      z.null()
    ])),
    priority: z.optional(z.union([
      z.int().gte(0).lte(100),
      z.null()
    ]))
  }),
  z.null()
]);
var zJobResultUserTask = z.union([
  z.object({
    denied: z.optional(z.union([
      z.boolean(),
      z.null()
    ])),
    deniedReason: z.optional(z.union([
      z.string(),
      z.null()
    ])),
    corrections: z.optional(zJobResultCorrections)
  }),
  z.null()
]);
var zJobResultActivateElement = z.object({
  elementId: z.optional(zElementId),
  variables: z.optional(z.union([
    z.record(z.string(), z.unknown()),
    z.null()
  ]))
});
var zJobResultAdHocSubProcess = z.union([
  z.object({
    activateElements: z.optional(z.array(zJobResultActivateElement).register(z.globalRegistry, {
      description: "Indicates which elements need to be activated in the ad-hoc subprocess."
    })),
    isCompletionConditionFulfilled: z.optional(z.boolean().register(z.globalRegistry, {
      description: "Indicates whether the completion condition of the ad-hoc subprocess is fulfilled."
    })).default(false),
    isCancelRemainingInstances: z.optional(z.boolean().register(z.globalRegistry, {
      description: "Indicates whether the remaining instances of the ad-hoc subprocess should be canceled."
    })).default(false)
  }),
  z.null()
]);
var zJobResult = z.intersection(z.union([
  z.object({
    type: z.literal("userTask")
  }).and(zJobResultUserTask),
  z.object({
    type: z.literal("adHocSubProcess")
  }).and(zJobResultAdHocSubProcess)
]), z.object({
  type: z.enum([
    "userTask",
    "adHocSubProcess"
  ]).register(z.globalRegistry, {
    description: "Used to distinguish between different types of job results."
  })
}).register(z.globalRegistry, {
  description: "The result of the completed job as determined by the worker.\n"
}));
var zJobCompletionRequest = z.object({
  variables: z.optional(z.union([
    z.record(z.string(), z.unknown()),
    z.null()
  ])),
  result: z.optional(zJobResult)
});
var zJobChangeset = z.object({
  retries: z.optional(z.union([
    z.int(),
    z.null()
  ])),
  timeout: z.optional(z.union([
    z.coerce.bigint(),
    z.null()
  ]))
}).register(z.globalRegistry, {
  description: "JSON object with changed job attribute values.\n\nThe following attributes can be adjusted with this endpoint, additional attributes\nwill be ignored:\n\n* `retries` - The new amount of retries for the job; must be a positive number.\n* `timeout` - The duration of the new timeout in ms, starting from the current moment.\n\nProviding any of those attributes with a null value or omitting it preserves the persisted attribute\u2019s value.\n\nThe job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.\n"
});
var zJobUpdateRequest = z.object({
  changeset: zJobChangeset,
  operationReference: z.optional(zOperationReference)
});
var zJobSearchQuerySortRequest = z.object({
  field: z.enum([
    "deadline",
    "deniedReason",
    "elementId",
    "elementInstanceKey",
    "endTime",
    "errorCode",
    "errorMessage",
    "hasFailedWithRetriesLeft",
    "isDenied",
    "jobKey",
    "kind",
    "listenerEventType",
    "processDefinitionId",
    "processDefinitionKey",
    "processInstanceKey",
    "retries",
    "state",
    "tenantId",
    "type",
    "worker"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zAdvancedJobKindFilter = z.object({
  "$eq": z.optional(zJobKindEnum),
  "$neq": z.optional(zJobKindEnum),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zJobKindEnum).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$like": z.optional(zLikeFilter)
}).register(z.globalRegistry, {
  description: "Advanced JobKindEnum filter."
});
var zJobKindFilterProperty = z.union([
  zJobKindEnum,
  zAdvancedJobKindFilter
]);
var zAdvancedJobListenerEventTypeFilter = z.object({
  "$eq": z.optional(zJobListenerEventTypeEnum),
  "$neq": z.optional(zJobListenerEventTypeEnum),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zJobListenerEventTypeEnum).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$like": z.optional(zLikeFilter)
}).register(z.globalRegistry, {
  description: "Advanced JobListenerEventTypeEnum filter."
});
var zJobListenerEventTypeFilterProperty = z.union([
  zJobListenerEventTypeEnum,
  zAdvancedJobListenerEventTypeFilter
]);
var zJobStateEnum = z.enum([
  "CANCELED",
  "COMPLETED",
  "CREATED",
  "ERROR_THROWN",
  "FAILED",
  "MIGRATED",
  "RETRIES_UPDATED",
  "TIMED_OUT"
]).register(z.globalRegistry, {
  description: "The state of the job."
});
var zAdvancedJobStateFilter = z.object({
  "$eq": z.optional(zJobStateEnum),
  "$neq": z.optional(zJobStateEnum),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zJobStateEnum).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$like": z.optional(zLikeFilter)
}).register(z.globalRegistry, {
  description: "Advanced JobStateEnum filter."
});
var zJobStateFilterProperty = z.union([
  zJobStateEnum,
  zAdvancedJobStateFilter
]);
var zJobFilter = z.object({
  deadline: z.optional(z.union([
    zDateTimeFilterProperty,
    z.null()
  ])),
  deniedReason: z.optional(zStringFilterProperty),
  elementId: z.optional(zStringFilterProperty),
  elementInstanceKey: z.optional(zElementInstanceKeyFilterProperty),
  endTime: z.optional(zDateTimeFilterProperty),
  errorCode: z.optional(zStringFilterProperty),
  errorMessage: z.optional(zStringFilterProperty),
  hasFailedWithRetriesLeft: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Indicates whether the job has failed with retries left."
  })),
  isDenied: z.optional(z.union([
    z.boolean(),
    z.null()
  ])),
  jobKey: z.optional(zJobKeyFilterProperty),
  kind: z.optional(zJobKindFilterProperty),
  listenerEventType: z.optional(zJobListenerEventTypeFilterProperty),
  processDefinitionId: z.optional(zStringFilterProperty),
  processDefinitionKey: z.optional(zProcessDefinitionKeyFilterProperty),
  processInstanceKey: z.optional(zProcessInstanceKeyFilterProperty),
  retries: z.optional(zIntegerFilterProperty),
  state: z.optional(zJobStateFilterProperty),
  tenantId: z.optional(zStringFilterProperty),
  type: z.optional(zStringFilterProperty),
  worker: z.optional(zStringFilterProperty)
}).register(z.globalRegistry, {
  description: "Job search filter."
});
var zJobSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zJobSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zJobFilter)
}).register(z.globalRegistry, {
  description: "Job search request."
}));
var zJobSearchResult = z.object({
  customHeaders: z.record(z.string(), z.string()).register(z.globalRegistry, {
    description: "A set of custom headers defined during modelling."
  }),
  deadline: z.optional(z.union([
    z.iso.datetime(),
    z.null()
  ])),
  deniedReason: z.optional(z.union([
    z.string(),
    z.null()
  ])),
  elementId: zElementId,
  elementInstanceKey: zElementInstanceKey,
  endTime: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "When the job ended."
  })),
  errorCode: z.optional(z.union([
    z.string(),
    z.null()
  ])),
  errorMessage: z.optional(z.union([
    z.string(),
    z.null()
  ])),
  hasFailedWithRetriesLeft: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Indicates whether the job has failed with retries left."
  })),
  isDenied: z.optional(z.union([
    z.boolean(),
    z.null()
  ])),
  jobKey: zJobKey,
  kind: zJobKindEnum,
  listenerEventType: zJobListenerEventTypeEnum,
  processDefinitionId: zProcessDefinitionId,
  processDefinitionKey: zProcessDefinitionKey,
  processInstanceKey: zProcessInstanceKey,
  retries: z.int().register(z.globalRegistry, {
    description: "The amount of retries left to this job."
  }),
  state: zJobStateEnum,
  tenantId: zTenantId,
  type: z.string().register(z.globalRegistry, {
    description: "The type of the job."
  }),
  worker: z.string().register(z.globalRegistry, {
    description: "The name of the worker of this job."
  })
});
var zJobSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.array(zJobSearchResult).register(z.globalRegistry, {
    description: "The matching jobs."
  })
}).register(z.globalRegistry, {
  description: "Job search response."
}));
var zProblemDetail = z.object({
  type: z.optional(z.url().register(z.globalRegistry, {
    description: "A URI identifying the problem type."
  })).default("about:blank"),
  title: z.optional(z.string().register(z.globalRegistry, {
    description: "A summary of the problem type."
  })),
  status: z.optional(z.int().gte(400).lte(600).register(z.globalRegistry, {
    description: "The HTTP status code for this problem."
  })),
  detail: z.optional(z.string().register(z.globalRegistry, {
    description: "An explanation of the problem in more detail."
  })),
  instance: z.optional(z.string().register(z.globalRegistry, {
    description: "A URI path identifying the origin of the problem."
  }))
}).register(z.globalRegistry, {
  description: "A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.\n"
});
var zDecisionRequirementsSearchQuerySortRequest = z.object({
  field: z.enum([
    "decisionRequirementsKey",
    "decisionRequirementsName",
    "version",
    "decisionRequirementsId",
    "tenantId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zDecisionRequirementsFilter = z.object({
  decisionRequirementsName: z.optional(z.string().register(z.globalRegistry, {
    description: "The DMN name of the decision requirements."
  })),
  version: z.optional(z.int().register(z.globalRegistry, {
    description: "The assigned version of the decision requirements."
  })),
  decisionRequirementsId: z.optional(z.string().register(z.globalRegistry, {
    description: "the DMN ID of the decision requirements."
  })),
  tenantId: z.optional(zTenantId),
  decisionRequirementsKey: z.optional(zDecisionRequirementsKey),
  resourceName: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the resource from which the decision requirements were parsed."
  }))
}).register(z.globalRegistry, {
  description: "Decision requirements search filter."
});
var zDecisionRequirementsSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zDecisionRequirementsSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zDecisionRequirementsFilter)
}));
var zDecisionRequirementsResult = z.object({
  decisionRequirementsName: z.optional(z.string().register(z.globalRegistry, {
    description: "The DMN name of the decision requirements."
  })),
  version: z.optional(z.int().register(z.globalRegistry, {
    description: "The assigned version of the decision requirements."
  })),
  decisionRequirementsId: z.optional(z.string().register(z.globalRegistry, {
    description: "The DMN ID of the decision requirements."
  })),
  resourceName: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the resource from which this decision requirements was parsed."
  })),
  tenantId: z.optional(zTenantId),
  decisionRequirementsKey: z.optional(zDecisionRequirementsKey)
});
var zDecisionRequirementsSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zDecisionRequirementsResult).register(z.globalRegistry, {
    description: "The matching decision requirements."
  }))
}));
var zDecisionEvaluationById = z.object({
  decisionDefinitionId: zDecisionDefinitionId,
  variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "The message variables as JSON document."
  })),
  tenantId: z.optional(zTenantId)
});
var zDecisionEvaluationByKey = z.object({
  decisionDefinitionKey: zDecisionDefinitionKey,
  variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "The message variables as JSON document."
  })),
  tenantId: z.optional(zTenantId)
});
var zDecisionEvaluationInstruction = z.union([
  zDecisionEvaluationById,
  zDecisionEvaluationByKey
]);
var zEvaluatedDecisionOutputItem = z.object({
  outputId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the evaluated decision output."
  })),
  outputName: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the evaluated decision output."
  })),
  outputValue: z.optional(z.string().register(z.globalRegistry, {
    description: "The value of the evaluated decision output."
  }))
}).register(z.globalRegistry, {
  description: "The evaluated decision outputs."
});
var zMatchedDecisionRuleItem = z.object({
  ruleId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the matched rule."
  })),
  ruleIndex: z.optional(z.int().register(z.globalRegistry, {
    description: "The index of the matched rule."
  })),
  evaluatedOutputs: z.optional(z.array(zEvaluatedDecisionOutputItem).register(z.globalRegistry, {
    description: "The evaluated decision outputs."
  }))
}).register(z.globalRegistry, {
  description: "A decision rule that matched within this decision evaluation."
});
var zEvaluatedDecisionInputItem = z.object({
  inputId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the evaluated decision input."
  })),
  inputName: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the evaluated decision input."
  })),
  inputValue: z.optional(z.string().register(z.globalRegistry, {
    description: "The value of the evaluated decision input."
  }))
}).register(z.globalRegistry, {
  description: "A decision input that was evaluated within this decision evaluation."
});
var zEvaluatedDecisionResult = z.object({
  decisionDefinitionId: z.optional(zDecisionDefinitionId),
  decisionDefinitionName: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the decision which was evaluated."
  })),
  decisionDefinitionVersion: z.optional(z.int().register(z.globalRegistry, {
    description: "The version of the decision which was evaluated."
  })),
  decisionDefinitionType: z.optional(z.string().register(z.globalRegistry, {
    description: "The type of the decision which was evaluated."
  })),
  output: z.optional(z.string().register(z.globalRegistry, {
    description: "JSON document that will instantiate the result of the decision which was evaluated.\n"
  })),
  tenantId: z.optional(zTenantId),
  matchedRules: z.optional(z.array(zMatchedDecisionRuleItem).register(z.globalRegistry, {
    description: "The decision rules that matched within this decision evaluation."
  })),
  evaluatedInputs: z.optional(z.array(zEvaluatedDecisionInputItem).register(z.globalRegistry, {
    description: "The decision inputs that were evaluated within this decision evaluation."
  })),
  decisionDefinitionKey: z.optional(zDecisionDefinitionKey),
  decisionEvaluationInstanceKey: z.optional(zDecisionEvaluationInstanceKey)
}).register(z.globalRegistry, {
  description: "A decision that was evaluated."
});
var zEvaluateDecisionResult = z.object({
  decisionDefinitionId: zDecisionDefinitionId,
  decisionDefinitionName: z.string().register(z.globalRegistry, {
    description: "The name of the decision which was evaluated."
  }),
  decisionDefinitionVersion: z.int().register(z.globalRegistry, {
    description: "The version of the decision which was evaluated."
  }),
  decisionRequirementsId: z.string().register(z.globalRegistry, {
    description: "The ID of the decision requirements graph that the decision which was evaluated is part of."
  }),
  output: z.string().register(z.globalRegistry, {
    description: "JSON document that will instantiate the result of the decision which was evaluated.\n"
  }),
  failedDecisionDefinitionId: zDecisionDefinitionId,
  failureMessage: z.string().register(z.globalRegistry, {
    description: "Message describing why the decision which was evaluated failed."
  }),
  tenantId: zTenantId,
  decisionDefinitionKey: zDecisionDefinitionKey,
  decisionRequirementsKey: zDecisionRequirementsKey,
  decisionInstanceKey: z.optional(zDecisionInstanceKey),
  decisionEvaluationKey: zDecisionEvaluationKey,
  evaluatedDecisions: z.array(zEvaluatedDecisionResult).register(z.globalRegistry, {
    description: "Decisions that were evaluated within the requested decision evaluation."
  })
});
var zDecisionInstanceSearchQuerySortRequest = z.object({
  field: z.enum([
    "decisionDefinitionId",
    "decisionDefinitionKey",
    "decisionDefinitionName",
    "decisionDefinitionType",
    "decisionDefinitionVersion",
    "decisionEvaluationInstanceKey",
    "decisionEvaluationKey",
    "elementInstanceKey",
    "evaluationDate",
    "evaluationFailure",
    "processDefinitionKey",
    "processInstanceKey",
    "state",
    "tenantId"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zDecisionInstanceStateEnum = z.enum([
  "EVALUATED",
  "FAILED",
  "UNSPECIFIED",
  "UNKNOWN"
]).register(z.globalRegistry, {
  description: "The state of the decision instance."
});
var zDecisionDefinitionTypeEnum = z.enum([
  "DECISION_TABLE",
  "LITERAL_EXPRESSION",
  "UNSPECIFIED",
  "UNKNOWN"
]).register(z.globalRegistry, {
  description: "The type of the decision."
});
var zDecisionInstanceFilter = z.object({
  decisionEvaluationInstanceKey: z.optional(zDecisionEvaluationInstanceKey),
  state: z.optional(zDecisionInstanceStateEnum),
  evaluationFailure: z.optional(z.string().register(z.globalRegistry, {
    description: "The evaluation failure of the decision instance."
  })),
  evaluationDate: z.optional(zDateTimeFilterProperty),
  decisionDefinitionId: z.optional(zDecisionDefinitionId),
  decisionDefinitionName: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the DMN decision."
  })),
  decisionDefinitionVersion: z.optional(z.int().register(z.globalRegistry, {
    description: "The version of the decision."
  })),
  decisionDefinitionType: z.optional(zDecisionDefinitionTypeEnum),
  tenantId: z.optional(zTenantId),
  decisionEvaluationKey: z.optional(zDecisionEvaluationKey),
  processDefinitionKey: z.optional(zProcessDefinitionKey),
  processInstanceKey: z.optional(zProcessInstanceKey),
  decisionDefinitionKey: z.optional(zDecisionDefinitionKeyFilterProperty),
  elementInstanceKey: z.optional(zElementInstanceKeyFilterProperty)
}).register(z.globalRegistry, {
  description: "Decision instance search filter."
});
var zDecisionInstanceSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zDecisionInstanceSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zDecisionInstanceFilter)
}));
var zDecisionInstanceResult = z.object({
  decisionEvaluationInstanceKey: z.optional(zDecisionEvaluationInstanceKey),
  state: z.optional(zDecisionInstanceStateEnum),
  evaluationDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "The evaluation date of the decision instance."
  })),
  evaluationFailure: z.optional(z.string().register(z.globalRegistry, {
    description: "The evaluation failure of the decision instance."
  })),
  decisionDefinitionId: z.optional(zDecisionDefinitionId),
  decisionDefinitionName: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the DMN decision."
  })),
  decisionDefinitionVersion: z.optional(z.int().register(z.globalRegistry, {
    description: "The version of the decision."
  })),
  decisionDefinitionType: z.optional(zDecisionDefinitionTypeEnum),
  result: z.optional(z.string().register(z.globalRegistry, {
    description: "The result of the decision instance."
  })),
  tenantId: z.optional(zTenantId),
  decisionEvaluationKey: z.optional(zDecisionEvaluationKey),
  processDefinitionKey: z.optional(zProcessDefinitionKey),
  processInstanceKey: z.optional(zProcessInstanceKey),
  decisionDefinitionKey: z.optional(zDecisionDefinitionKey),
  elementInstanceKey: z.optional(zElementInstanceKey)
});
var zDecisionInstanceSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zDecisionInstanceResult).register(z.globalRegistry, {
    description: "The matching decision instances."
  }))
}));
var zDecisionInstanceGetQueryResult = zDecisionInstanceResult.and(z.object({
  evaluatedInputs: z.optional(z.array(zEvaluatedDecisionInputItem).register(z.globalRegistry, {
    description: "The evaluated inputs of the decision instance.\n"
  })),
  matchedRules: z.optional(z.array(zMatchedDecisionRuleItem).register(z.globalRegistry, {
    description: "The matched rules of the decision instance.\n"
  }))
}));
var zMessageCorrelationRequest = z.object({
  name: z.string().register(z.globalRegistry, {
    description: "The message name as defined in the BPMN process\n"
  }),
  correlationKey: z.optional(z.string().register(z.globalRegistry, {
    description: "The correlation key of the message."
  })).default(""),
  variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "The message variables as JSON document"
  })),
  tenantId: z.optional(zTenantId)
});
var zMessageCorrelationResult = z.object({
  tenantId: z.optional(zTenantId),
  messageKey: z.optional(zMessageCorrelationKey),
  processInstanceKey: z.optional(zProcessInstanceKey)
}).register(z.globalRegistry, {
  description: "The message key of the correlated message, as well as the first process instance key it\ncorrelated with.\n"
});
var zMessagePublicationRequest = z.object({
  name: z.string().register(z.globalRegistry, {
    description: "The name of the message."
  }),
  correlationKey: z.optional(z.string().register(z.globalRegistry, {
    description: "The correlation key of the message."
  })).default(""),
  timeToLive: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "Timespan (in ms) to buffer the message on the broker."
  })).default(BigInt(0)),
  messageId: z.optional(z.string().register(z.globalRegistry, {
    description: "The unique ID of the message. This is used to ensure only one message with the given ID\nwill be published during the lifetime of the message (if `timeToLive` is set).\n"
  })),
  variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "The message variables as JSON document."
  })),
  tenantId: z.optional(zTenantId)
});
var zMessagePublicationResult = z.object({
  tenantId: z.optional(zTenantId),
  messageKey: z.optional(zMessageKey)
}).register(z.globalRegistry, {
  description: "The message key of the published message."
});
var zDocumentId = z.string().register(z.globalRegistry, {
  description: "Document Id that uniquely identifies a document."
});
var zDocumentMetadata = z.object({
  contentType: z.optional(z.string().register(z.globalRegistry, {
    description: "The content type of the document."
  })),
  fileName: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the file."
  })),
  expiresAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "The date and time when the document expires."
  })),
  size: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "The size of the document in bytes."
  })),
  processDefinitionId: z.optional(zProcessDefinitionId),
  processInstanceKey: z.optional(zProcessInstanceKey),
  customProperties: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "Custom properties of the document."
  }))
}).register(z.globalRegistry, {
  description: "Information about the document."
});
var zDocumentReference = z.object({
  "camunda.document.type": z.optional(z.enum([
    "camunda"
  ]).register(z.globalRegistry, {
    description: 'Document discriminator. Always set to "camunda".'
  })),
  storeId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the document store."
  })),
  documentId: z.optional(zDocumentId),
  contentHash: z.optional(z.string().register(z.globalRegistry, {
    description: "The hash of the document."
  })),
  metadata: z.optional(zDocumentMetadata)
});
var zDocumentCreationFailureDetail = z.object({
  fileName: z.optional(z.string().register(z.globalRegistry, {
    description: "The name of the file."
  })),
  detail: z.optional(z.string().register(z.globalRegistry, {
    description: "The detail of the failure."
  }))
});
var zDocumentCreationBatchResponse = z.object({
  createdDocuments: z.optional(z.array(zDocumentReference).register(z.globalRegistry, {
    description: "Documents that were successfully created."
  })),
  failedDocuments: z.optional(z.array(zDocumentCreationFailureDetail).register(z.globalRegistry, {
    description: "Documents that failed creation."
  }))
});
var zDocumentLinkRequest = z.object({
  timeToLive: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "The time-to-live of the document link in ms."
  })).default(BigInt(36e5))
});
var zDocumentLink = z.object({
  url: z.optional(z.string().register(z.globalRegistry, {
    description: "The link to the document."
  })),
  expiresAt: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "The date and time when the link expires."
  }))
});
var zDeploymentProcessResult = z.object({
  processDefinitionId: zProcessDefinitionId,
  processDefinitionVersion: z.int().register(z.globalRegistry, {
    description: "The assigned process version."
  }),
  resourceName: z.string().register(z.globalRegistry, {
    description: "The resource name from which this process was parsed."
  }),
  tenantId: zTenantId,
  processDefinitionKey: zProcessDefinitionKey
}).register(z.globalRegistry, {
  description: "A deployed process."
});
var zDeploymentDecisionResult = z.object({
  decisionDefinitionId: z.optional(zDecisionDefinitionId),
  version: z.optional(z.int().register(z.globalRegistry, {
    description: "The assigned decision version."
  })),
  name: z.optional(z.string().register(z.globalRegistry, {
    description: "The DMN name of the decision, as parsed during deployment."
  })),
  tenantId: z.optional(zTenantId),
  decisionRequirementsId: z.optional(z.string().register(z.globalRegistry, {
    description: "The dmn ID of the decision requirements graph that this decision is part of, as parsed during deployment.\n"
  })),
  decisionDefinitionKey: z.optional(zDecisionDefinitionKey),
  decisionRequirementsKey: z.optional(zDecisionRequirementsKey)
}).register(z.globalRegistry, {
  description: "A deployed decision."
});
var zDeploymentDecisionRequirementsResult = z.object({
  decisionRequirementsId: z.optional(z.string().register(z.globalRegistry, {
    description: "The dmn decision requirements ID, as parsed during deployment; together with the versions forms a unique identifier for a specific decision.\n"
  })),
  version: z.optional(z.int().register(z.globalRegistry, {
    description: "The assigned decision requirements version."
  })),
  decisionRequirementsName: z.optional(z.string().register(z.globalRegistry, {
    description: "The DMN name of the decision requirements, as parsed during deployment."
  })),
  tenantId: z.optional(zTenantId),
  resourceName: z.optional(z.string().register(z.globalRegistry, {
    description: "The resource name from which this decision requirements was parsed."
  })),
  decisionRequirementsKey: z.optional(zDecisionRequirementsKey)
}).register(z.globalRegistry, {
  description: "Deployed decision requirements."
});
var zDeploymentFormResult = z.object({
  formId: z.optional(zFormId),
  version: z.optional(z.int().register(z.globalRegistry, {
    description: "The assigned form version."
  })),
  resourceName: z.optional(z.string().register(z.globalRegistry, {
    description: "The resource name from which this form was parsed."
  })),
  tenantId: z.optional(zTenantId),
  formKey: z.optional(zFormKey)
}).register(z.globalRegistry, {
  description: "A deployed form."
});
var zDeploymentResourceResult = z.object({
  resourceId: z.optional(z.string().register(z.globalRegistry, {
    description: "The resource ID, as parsed during deployment, together with the version forms a\nunique identifier for a specific form.\n"
  })),
  version: z.optional(z.int().register(z.globalRegistry, {
    description: "The assigned resource version."
  })),
  resourceName: z.optional(z.string().register(z.globalRegistry, {
    description: "The resource name from which this resource was parsed."
  })),
  tenantId: z.optional(zTenantId),
  resourceKey: z.optional(zResourceKey)
}).register(z.globalRegistry, {
  description: "A deployed Resource."
});
var zDeploymentMetadataResult = z.object({
  processDefinition: z.optional(zDeploymentProcessResult),
  decisionDefinition: z.optional(zDeploymentDecisionResult),
  decisionRequirements: z.optional(zDeploymentDecisionRequirementsResult),
  form: z.optional(zDeploymentFormResult),
  resource: z.optional(zDeploymentResourceResult)
});
var zDeploymentResult = z.object({
  tenantId: zTenantId,
  deploymentKey: zDeploymentKey,
  deployments: z.array(zDeploymentMetadataResult).register(z.globalRegistry, {
    description: "Items deployed by the request."
  })
});
var zIncidentResolutionRequest = z.object({
  operationReference: z.optional(zOperationReference)
});
var zProcessInstanceCreationStartInstruction = z.object({
  elementId: zElementId
});
var zProcessInstanceCreationTerminateInstruction = z.object({
  afterElementId: zElementId
}).register(z.globalRegistry, {
  description: "Terminates the process instance after a specific BPMN element is completed or terminated.\n"
});
var zProcessInstanceCreationRuntimeInstruction = z.object({
  type: z.literal("TERMINATE_PROCESS_INSTANCE")
}).and(zProcessInstanceCreationTerminateInstruction).and(z.object({
  type: z.enum([
    "TERMINATE_PROCESS_INSTANCE"
  ]).register(z.globalRegistry, {
    description: "The type of the runtime instruction"
  })
}).register(z.globalRegistry, {
  description: "Runtime instructions"
}));
var zProcessInstanceCreationInstructionById = z.object({
  processDefinitionId: zProcessDefinitionId,
  processDefinitionVersion: z.optional(z.int().register(z.globalRegistry, {
    description: "The version of the process. By default, the latest version of the process is used.\n"
  })).default(-1),
  variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "JSON object that will instantiate the variables for the root variable scope\nof the process instance.\n"
  })),
  tenantId: z.optional(zTenantId),
  operationReference: z.optional(zOperationReference),
  startInstructions: z.optional(z.array(zProcessInstanceCreationStartInstruction).register(z.globalRegistry, {
    description: "List of start instructions. By default, the process instance will start at\nthe start event. If provided, the process instance will apply start instructions\nafter it has been created.\n"
  })),
  runtimeInstructions: z.optional(z.array(zProcessInstanceCreationRuntimeInstruction).register(z.globalRegistry, {
    description: "Runtime instructions (alpha). List of instructions that affect the runtime behavior of\nthe process instance. Refer to specific instruction types for more details.\n\nThis parameter is an alpha feature and may be subject to change\nin future releases.\n"
  })),
  awaitCompletion: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Wait for the process instance to complete. If the process instance completion does\nnot occur within the requestTimeout, the request will be closed. This can lead to a 504\nresponse status. Disabled by default.\n"
  })).default(false),
  fetchVariables: z.optional(z.array(z.string()).register(z.globalRegistry, {
    description: "List of variables by name to be included in the response when awaitCompletion is set to true.\nIf empty, all visible variables in the root scope will be returned.\n"
  })),
  requestTimeout: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "Timeout (in ms) the request waits for the process to complete. By default or\nwhen set to 0, the generic request timeout configured in the cluster is applied.\n"
  })).default(BigInt(0)),
  tags: z.optional(zTagSet)
});
var zProcessInstanceCreationInstructionByKey = z.object({
  processDefinitionKey: zProcessDefinitionKey,
  variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "JSON object that will instantiate the variables for the root variable scope\nof the process instance.\n"
  })),
  tenantId: z.optional(zTenantId),
  operationReference: z.optional(zOperationReference),
  startInstructions: z.optional(z.array(zProcessInstanceCreationStartInstruction).register(z.globalRegistry, {
    description: "List of start instructions. By default, the process instance will start at\nthe start event. If provided, the process instance will apply start instructions\nafter it has been created.\n"
  })),
  runtimeInstructions: z.optional(z.array(zProcessInstanceCreationRuntimeInstruction).register(z.globalRegistry, {
    description: "Runtime instructions (alpha). List of instructions that affect the runtime behavior of\nthe process instance. Refer to specific instruction types for more details.\n\nThis parameter is an alpha feature and may be subject to change\nin future releases.\n"
  })),
  awaitCompletion: z.optional(z.boolean().register(z.globalRegistry, {
    description: "Wait for the process instance to complete. If the process instance completion does\nnot occur within the requestTimeout, the request will be closed. This can lead to a 504\nresponse status. Disabled by default.\n"
  })).default(false),
  fetchVariables: z.optional(z.array(z.string()).register(z.globalRegistry, {
    description: "List of variables by name to be included in the response when awaitCompletion is set to true.\nIf empty, all visible variables in the root scope will be returned.\n"
  })),
  requestTimeout: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "Timeout (in ms) the request waits for the process to complete. By default or\nwhen set to 0, the generic request timeout configured in the cluster is applied.\n"
  })).default(BigInt(0)),
  tags: z.optional(zTagSet)
});
var zProcessInstanceCreationInstruction = z.union([
  zProcessInstanceCreationInstructionById,
  zProcessInstanceCreationInstructionByKey
]);
var zCreateProcessInstanceResult = z.object({
  processDefinitionId: zProcessDefinitionId,
  processDefinitionVersion: z.int().register(z.globalRegistry, {
    description: "The version of the process definition which was used to create the process instance.\n"
  }),
  tenantId: zTenantId,
  variables: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "All the variables visible in the root scope."
  }),
  processDefinitionKey: zProcessDefinitionKey,
  processInstanceKey: zProcessInstanceKey,
  tags: z.optional(zTagSet)
});
var zMigrateProcessInstanceMappingInstruction = z.object({
  sourceElementId: zElementId,
  targetElementId: zElementId
}).register(z.globalRegistry, {
  description: "The mapping instructions describe how to map elements from the source process definition to the target process definition.\n"
});
var zProcessInstanceMigrationBatchOperationPlan = z.object({
  mappingInstructions: z.array(zMigrateProcessInstanceMappingInstruction).register(z.globalRegistry, {
    description: "Element mappings from the source process instance to the target process instance."
  }),
  targetProcessDefinitionKey: zProcessDefinitionKey
}).register(z.globalRegistry, {
  description: "The migration instructions describe how to migrate a process instance from one process definition to another.\n"
});
var zProcessInstanceMigrationBatchOperationRequest = z.object({
  filter: zProcessInstanceFilter,
  migrationPlan: zProcessInstanceMigrationBatchOperationPlan
});
var zProcessInstanceMigrationInstruction = z.object({
  mappingInstructions: z.array(zMigrateProcessInstanceMappingInstruction).register(z.globalRegistry, {
    description: "Element mappings from the source process instance to the target process instance."
  }),
  operationReference: z.optional(zOperationReference),
  targetProcessDefinitionKey: zProcessDefinitionKey
}).register(z.globalRegistry, {
  description: "The migration instructions describe how to migrate a process instance from one process definition to another.\n"
});
var zModifyProcessInstanceVariableInstruction = z.object({
  variables: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "JSON document that will instantiate the variables for the root variable scope of the process instance.\nIt must be a JSON object, as variables will be mapped in a key-value fashion.\n"
  }),
  scopeId: z.optional(z.string().register(z.globalRegistry, {
    description: "The ID of the element in which scope the variables should be created.\nLeave empty to create the variables in the global scope of the process instance\n"
  })).default("")
}).register(z.globalRegistry, {
  description: "Instructions describing which variables should be created."
});
var zProcessInstanceModificationActivateInstruction = z.object({
  elementId: zElementId,
  variableInstructions: z.optional(z.array(zModifyProcessInstanceVariableInstruction).register(z.globalRegistry, {
    description: "Instructions describing which variables should be created."
  })),
  ancestorElementInstanceKey: z.optional(z.union([
    z.string().default("-1"),
    zElementInstanceKey
  ]))
}).register(z.globalRegistry, {
  description: "Instructions describing an element that should be activated."
});
var zProcessInstanceModificationTerminateInstruction = z.object({
  elementInstanceKey: zElementInstanceKey
}).register(z.globalRegistry, {
  description: "Instructions describing which elements should be terminated."
});
var zProcessInstanceModificationInstruction = z.object({
  operationReference: z.optional(zOperationReference),
  activateInstructions: z.optional(z.array(zProcessInstanceModificationActivateInstruction).register(z.globalRegistry, {
    description: "Instructions describing which elements should be activated in which scopes and which variables should be created."
  })),
  terminateInstructions: z.optional(z.array(zProcessInstanceModificationTerminateInstruction).register(z.globalRegistry, {
    description: "Instructions describing which elements should be terminated."
  }))
});
var zSetVariableRequest = z.object({
  variables: z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "JSON object representing the variables to set in the element\u2019s scope."
  }),
  local: z.optional(z.boolean().register(z.globalRegistry, {
    description: `If set to true, the variables are merged strictly into the local scope (as specified by the \`elementInstanceKey\`).
Otherwise, the variables are propagated to upper scopes and set at the outermost one.

Let\u2019s consider the following example:

There are two scopes '1' and '2'.
Scope '1' is the parent scope of '2'. The effective variables of the scopes are:
1 => { "foo" : 2 }
2 => { "bar" : 1 }

An update request with elementInstanceKey as '2', variables { "foo" : 5 }, and local set
to true leaves scope '1' unchanged and adjusts scope '2' to { "bar" : 1, "foo" 5 }.

By default, with local set to false, scope '1' will be { "foo": 5 }
and scope '2' will be { "bar" : 1 }.
`
  })).default(false),
  operationReference: z.optional(zOperationReference)
});
var zDeleteResourceRequest = z.union([
  z.object({
    operationReference: z.optional(zOperationReference)
  }),
  z.null()
]);
var zSignalBroadcastRequest = z.object({
  signalName: z.string().register(z.globalRegistry, {
    description: "The name of the signal to broadcast."
  }),
  variables: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "The signal variables as a JSON object."
  })),
  tenantId: z.optional(zTenantId)
});
var zSignalBroadcastResult = z.object({
  tenantId: zTenantId,
  signalKey: zSignalKey
});
var zFormResult = z.object({
  tenantId: z.optional(zTenantId),
  formId: z.optional(zFormId),
  schema: z.optional(z.record(z.string(), z.unknown()).register(z.globalRegistry, {
    description: "The form content."
  })),
  version: z.optional(z.coerce.bigint().register(z.globalRegistry, {
    description: "The version of the the deployed form."
  })),
  formKey: z.optional(zFormKey)
});
var zResourceResult = z.object({
  resourceName: z.optional(z.string().register(z.globalRegistry, {
    description: "The resource name from which this resource was parsed."
  })),
  version: z.optional(z.int().register(z.globalRegistry, {
    description: "The assigned resource version."
  })),
  versionTag: z.optional(z.string().register(z.globalRegistry, {
    description: "The version tag of this resource."
  })),
  resourceId: z.optional(z.string().register(z.globalRegistry, {
    description: "The resource ID of this resource."
  })),
  tenantId: z.optional(zTenantId),
  resourceKey: z.optional(zResourceKey)
});
var zBatchOperationTypeEnum = z.enum([
  "CANCEL_PROCESS_INSTANCE",
  "RESOLVE_INCIDENT",
  "MIGRATE_PROCESS_INSTANCE",
  "MODIFY_PROCESS_INSTANCE",
  "DELETE_PROCESS_INSTANCE",
  "ADD_VARIABLE",
  "UPDATE_VARIABLE",
  "DELETE_DECISION_DEFINITION",
  "DELETE_PROCESS_DEFINITION"
]).register(z.globalRegistry, {
  description: "The type of the batch operation."
});
var zBatchOperationCreatedResult = z.object({
  batchOperationKey: z.optional(zBatchOperationKey),
  batchOperationType: z.optional(zBatchOperationTypeEnum)
}).register(z.globalRegistry, {
  description: "The created batch operation."
});
var zBatchOperationSearchQuerySortRequest = z.object({
  field: z.enum([
    "batchOperationKey",
    "operationType",
    "state",
    "startDate",
    "endDate"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zAdvancedBatchOperationTypeFilter = z.object({
  "$eq": z.optional(zBatchOperationTypeEnum),
  "$neq": z.optional(zBatchOperationTypeEnum),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zBatchOperationTypeEnum).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$like": z.optional(zLikeFilter)
}).register(z.globalRegistry, {
  description: "Advanced BatchOperationTypeEnum filter."
});
var zBatchOperationTypeFilterProperty = z.union([
  zBatchOperationTypeEnum,
  zAdvancedBatchOperationTypeFilter
]);
var zBatchOperationStateEnum = z.enum([
  "ACTIVE",
  "CANCELED",
  "COMPLETED",
  "CREATED",
  "FAILED",
  "PARTIALLY_COMPLETED",
  "SUSPENDED"
]).register(z.globalRegistry, {
  description: "The batch operation state."
});
var zAdvancedBatchOperationStateFilter = z.object({
  "$eq": z.optional(zBatchOperationStateEnum),
  "$neq": z.optional(zBatchOperationStateEnum),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zBatchOperationStateEnum).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$like": z.optional(zLikeFilter)
}).register(z.globalRegistry, {
  description: "Advanced BatchOperationStateEnum filter."
});
var zBatchOperationStateFilterProperty = z.union([
  zBatchOperationStateEnum,
  zAdvancedBatchOperationStateFilter
]);
var zBatchOperationFilter = z.object({
  batchOperationKey: z.optional(zBasicStringFilterProperty),
  operationType: z.optional(zBatchOperationTypeFilterProperty),
  state: z.optional(zBatchOperationStateFilterProperty)
}).register(z.globalRegistry, {
  description: "Batch operation filter request."
});
var zBatchOperationSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zBatchOperationSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zBatchOperationFilter)
}).register(z.globalRegistry, {
  description: "Batch operation search request."
}));
var zBatchOperationItemSearchQuerySortRequest = z.object({
  field: z.enum([
    "batchOperationKey",
    "itemKey",
    "processInstanceKey",
    "state"
  ]).register(z.globalRegistry, {
    description: "The field to sort by."
  }),
  order: z.optional(zSortOrderEnum)
});
var zBatchOperationItemStateEnum = z.enum([
  "ACTIVE",
  "COMPLETED",
  "CANCELED",
  "FAILED"
]).register(z.globalRegistry, {
  description: "The state, one of ACTIVE, COMPLETED, TERMINATED."
});
var zAdvancedBatchOperationItemStateFilter = z.object({
  "$eq": z.optional(zBatchOperationItemStateEnum),
  "$neq": z.optional(zBatchOperationItemStateEnum),
  "$exists": z.optional(z.boolean().register(z.globalRegistry, {
    description: "Checks if the current property exists."
  })),
  "$in": z.optional(z.array(zBatchOperationItemStateEnum).register(z.globalRegistry, {
    description: "Checks if the property matches any of the provided values."
  })),
  "$like": z.optional(zLikeFilter)
}).register(z.globalRegistry, {
  description: "Advanced BatchOperationItemStateEnum filter."
});
var zBatchOperationItemStateFilterProperty = z.union([
  zBatchOperationItemStateEnum,
  zAdvancedBatchOperationItemStateFilter
]);
var zBatchOperationItemFilter = z.object({
  batchOperationKey: z.optional(zBasicStringFilterProperty),
  itemKey: z.optional(zBasicStringFilterProperty),
  processInstanceKey: z.optional(zProcessInstanceKeyFilterProperty),
  state: z.optional(zBatchOperationItemStateFilterProperty)
}).register(z.globalRegistry, {
  description: "Batch operation item filter request."
});
var zBatchOperationItemSearchQuery = zSearchQueryRequest.and(z.object({
  sort: z.optional(z.array(zBatchOperationItemSearchQuerySortRequest).register(z.globalRegistry, {
    description: "Sort field criteria."
  })),
  filter: z.optional(zBatchOperationItemFilter)
}).register(z.globalRegistry, {
  description: "Batch operation item search request."
}));
var zBatchOperationError = z.object({
  partitionId: z.optional(z.int().register(z.globalRegistry, {
    description: "The partition ID where the error occurred."
  })),
  type: z.optional(z.enum([
    "QUERY_FAILED",
    "RESULT_BUFFER_SIZE_EXCEEDED"
  ]).register(z.globalRegistry, {
    description: "The type of the error that occurred during the batch operation."
  })),
  message: z.optional(z.string().register(z.globalRegistry, {
    description: "The error message that occurred during the batch operation."
  }))
});
var zBatchOperationResponse = z.object({
  batchOperationKey: z.optional(zBatchOperationKey),
  state: z.optional(z.enum([
    "ACTIVE",
    "CANCELED",
    "COMPLETED",
    "CREATED",
    "FAILED",
    "PARTIALLY_COMPLETED",
    "SUSPENDED"
  ]).register(z.globalRegistry, {
    description: "The state of the batch operation."
  })),
  batchOperationType: z.optional(zBatchOperationTypeEnum),
  startDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "The start date of the batch operation."
  })),
  endDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "The end date of the batch operation."
  })),
  operationsTotalCount: z.optional(z.int().register(z.globalRegistry, {
    description: "The total number of items contained in this batch operation."
  })),
  operationsFailedCount: z.optional(z.int().register(z.globalRegistry, {
    description: "The number of items which failed during execution of the batch operation. (e.g. because they are rejected by the Zeebe engine)."
  })),
  operationsCompletedCount: z.optional(z.int().register(z.globalRegistry, {
    description: "The number of successfully completed tasks."
  })),
  errors: z.optional(z.array(zBatchOperationError).register(z.globalRegistry, {
    description: "The errors that occurred per partition during the batch operation."
  }))
});
var zBatchOperationSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zBatchOperationResponse).register(z.globalRegistry, {
    description: "The matching batch operations."
  }))
}).register(z.globalRegistry, {
  description: "The batch operation search query result."
}));
var zBatchOperationItemResponse = z.object({
  operationType: z.optional(zBatchOperationTypeEnum),
  batchOperationKey: z.optional(zBatchOperationKey),
  itemKey: z.optional(z.string().register(z.globalRegistry, {
    description: "Key of the item, e.g. a process instance key."
  })),
  processInstanceKey: z.optional(zProcessInstanceKey),
  state: z.optional(z.enum([
    "ACTIVE",
    "COMPLETED",
    "SKIPPED",
    "CANCELED",
    "FAILED"
  ]).register(z.globalRegistry, {
    description: "State of the item."
  })),
  processedDate: z.optional(z.iso.datetime().register(z.globalRegistry, {
    description: "the date this item was processed."
  })),
  errorMessage: z.optional(z.string().register(z.globalRegistry, {
    description: "the error message from the engine in case of a failed operation."
  }))
});
var zBatchOperationItemSearchQueryResult = zSearchQueryResponse.and(z.object({
  items: z.optional(z.array(zBatchOperationItemResponse).register(z.globalRegistry, {
    description: "The matching batch operations."
  }))
}));
var zProcessInstanceCancellationBatchOperationRequest = z.object({
  filter: zProcessInstanceFilter
}).register(z.globalRegistry, {
  description: "The process instance filter that defines which process instances should be canceled."
});
var zProcessInstanceIncidentResolutionBatchOperationRequest = z.object({
  filter: zProcessInstanceFilter
}).register(z.globalRegistry, {
  description: "The process instance filter that defines which process instances should have their incidents resolved."
});
var zProcessInstanceModificationMoveBatchOperationInstruction = z.object({
  sourceElementId: zElementId,
  targetElementId: zElementId
}).register(z.globalRegistry, {
  description: "Instructions describing a move operation. This instruction will terminate all active elementInstance\nat sourceElementId and activate a new element instance for each terminated one at targetElementId."
});
var zProcessInstanceModificationBatchOperationRequest = z.object({
  filter: zProcessInstanceFilter,
  moveInstructions: z.array(zProcessInstanceModificationMoveBatchOperationInstruction).register(z.globalRegistry, {
    description: "Instructions describing which elements should be activated in which scopes and which variables should be created."
  })
}).register(z.globalRegistry, {
  description: "The process instance filter to define on which process instances tokens should be moved,\nas well as mapping instructions which active element instances should be terminated and which\nnew element instances should be activated\n"
});
var zGetTopologyData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zGetTopologyResponse = zTopologyResponse;
var zGetStatusData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zGetStatusResponse = z.void().register(z.globalRegistry, {
  description: "The cluster is UP and has at least one partition with a healthy leader."
});
var zGetLicenseData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zGetLicenseResponse = zLicenseResponse;
var zGetAuthenticationData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zGetAuthenticationResponse = zCamundaUserResult;
var zActivateJobsData = z.object({
  body: zJobActivationRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zActivateJobsResponse = zJobActivationResult;
var zSearchJobsData = z.object({
  body: z.optional(zJobSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchJobsResponse = zJobSearchQueryResult;
var zFailJobData = z.object({
  body: z.optional(zJobFailRequest),
  path: z.object({
    jobKey: zJobKey
  }),
  query: z.optional(z.never())
});
var zFailJobResponse = z.void().register(z.globalRegistry, {
  description: "The job is failed."
});
var zThrowJobErrorData = z.object({
  body: zJobErrorRequest,
  path: z.object({
    jobKey: zJobKey
  }),
  query: z.optional(z.never())
});
var zThrowJobErrorResponse = z.void().register(z.globalRegistry, {
  description: "An error is thrown for the job."
});
var zCompleteJobData = z.object({
  body: z.optional(zJobCompletionRequest),
  path: z.object({
    jobKey: zJobKey
  }),
  query: z.optional(z.never())
});
var zCompleteJobResponse = z.void().register(z.globalRegistry, {
  description: "The job was completed successfully."
});
var zUpdateJobData = z.object({
  body: zJobUpdateRequest,
  path: z.object({
    jobKey: zJobKey
  }),
  query: z.optional(z.never())
});
var zUpdateJobResponse = z.void().register(z.globalRegistry, {
  description: "The job was updated successfully."
});
var zResolveIncidentData = z.object({
  body: z.optional(zIncidentResolutionRequest),
  path: z.object({
    incidentKey: zIncidentKey
  }),
  query: z.optional(z.never())
});
var zResolveIncidentResponse = z.void().register(z.globalRegistry, {
  description: "The incident is marked as resolved."
});
var zCreateTenantData = z.object({
  body: zTenantCreateRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zCreateTenantResponse = zTenantCreateResult;
var zDeleteTenantData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: zTenantId
  }),
  query: z.optional(z.never())
});
var zDeleteTenantResponse = z.void().register(z.globalRegistry, {
  description: "The tenant was deleted successfully."
});
var zGetTenantData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: zTenantId
  }),
  query: z.optional(z.never())
});
var zGetTenantResponse = zTenantResult;
var zUpdateTenantData = z.object({
  body: zTenantUpdateRequest,
  path: z.object({
    tenantId: zTenantId
  }),
  query: z.optional(z.never())
});
var zUpdateTenantResponse = zTenantUpdateResult;
var zUnassignUserFromTenantData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: zTenantId,
    username: zUsername
  }),
  query: z.optional(z.never())
});
var zUnassignUserFromTenantResponse = z.void().register(z.globalRegistry, {
  description: "The user was successfully unassigned from the tenant."
});
var zAssignUserToTenantData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: zTenantId,
    username: zUsername
  }),
  query: z.optional(z.never())
});
var zAssignUserToTenantResponse = z.void().register(z.globalRegistry, {
  description: "The user was successfully assigned to the tenant."
});
var zSearchUsersForTenantData = z.object({
  body: z.optional(zTenantUserSearchQueryRequest),
  path: z.object({
    tenantId: zTenantId
  }),
  query: z.optional(z.never())
});
var zSearchUsersForTenantResponse = zTenantUserSearchResult;
var zSearchClientsForTenantData = z.object({
  body: z.optional(zTenantClientSearchQueryRequest),
  path: z.object({
    tenantId: zTenantId
  }),
  query: z.optional(z.never())
});
var zSearchClientsForTenantResponse = zTenantClientSearchResult;
var zSearchGroupIdsForTenantData = z.object({
  body: z.optional(zTenantGroupSearchQueryRequest),
  path: z.object({
    tenantId: zTenantId
  }),
  query: z.optional(z.never())
});
var zSearchGroupIdsForTenantResponse = zTenantGroupSearchResult;
var zSearchRolesForTenantData = z.object({
  body: z.optional(zRoleSearchQueryRequest),
  path: z.object({
    tenantId: zTenantId
  }),
  query: z.optional(z.never())
});
var zSearchRolesForTenantResponse = zRoleSearchQueryResult;
var zUnassignClientFromTenantData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: zTenantId,
    clientId: z.string().register(z.globalRegistry, {
      description: "The unique identifier of the application."
    })
  }),
  query: z.optional(z.never())
});
var zUnassignClientFromTenantResponse = z.void().register(z.globalRegistry, {
  description: "The client was successfully unassigned from the tenant."
});
var zAssignClientToTenantData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: zTenantId,
    clientId: z.string().register(z.globalRegistry, {
      description: "The ID of the client to assign."
    })
  }),
  query: z.optional(z.never())
});
var zAssignClientToTenantResponse = z.void().register(z.globalRegistry, {
  description: "The client was successfully assigned to the tenant."
});
var zUnassignMappingRuleFromTenantData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: zTenantId,
    mappingRuleId: z.string().register(z.globalRegistry, {
      description: "The unique identifier of the mapping rule."
    })
  }),
  query: z.optional(z.never())
});
var zUnassignMappingRuleFromTenantResponse = z.void().register(z.globalRegistry, {
  description: "The mapping rule was successfully unassigned from the tenant."
});
var zAssignMappingRuleToTenantData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: zTenantId,
    mappingRuleId: z.string().register(z.globalRegistry, {
      description: "The unique identifier of the mapping rule."
    })
  }),
  query: z.optional(z.never())
});
var zAssignMappingRuleToTenantResponse = z.void().register(z.globalRegistry, {
  description: "The mapping rule was successfully assigned to the tenant."
});
var zSearchMappingRulesForTenantData = z.object({
  body: z.optional(zMappingRuleSearchQueryRequest),
  path: z.object({
    tenantId: zTenantId
  }),
  query: z.optional(z.never())
});
var zSearchMappingRulesForTenantResponse = zMappingRuleSearchQueryResult;
var zUnassignGroupFromTenantData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: zTenantId,
    groupId: z.string().register(z.globalRegistry, {
      description: "The unique identifier of the group."
    })
  }),
  query: z.optional(z.never())
});
var zUnassignGroupFromTenantResponse = z.void().register(z.globalRegistry, {
  description: "The group was successfully unassigned from the tenant."
});
var zAssignGroupToTenantData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: zTenantId,
    groupId: z.string().register(z.globalRegistry, {
      description: "The unique identifier of the group."
    })
  }),
  query: z.optional(z.never())
});
var zAssignGroupToTenantResponse = z.void().register(z.globalRegistry, {
  description: "The group was successfully assigned to the tenant."
});
var zUnassignRoleFromTenantData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: zTenantId,
    roleId: z.string().register(z.globalRegistry, {
      description: "The unique identifier of the role."
    })
  }),
  query: z.optional(z.never())
});
var zUnassignRoleFromTenantResponse = z.void().register(z.globalRegistry, {
  description: "The role was successfully unassigned from the tenant."
});
var zAssignRoleToTenantData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: zTenantId,
    roleId: z.string().register(z.globalRegistry, {
      description: "The unique identifier of the role."
    })
  }),
  query: z.optional(z.never())
});
var zAssignRoleToTenantResponse = z.void().register(z.globalRegistry, {
  description: "The role was successfully assigned to the tenant."
});
var zSearchTenantsData = z.object({
  body: z.optional(zTenantSearchQueryRequest),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchTenantsResponse = zTenantSearchQueryResult;
var zCompleteUserTaskData = z.object({
  body: z.optional(zUserTaskCompletionRequest),
  path: z.object({
    userTaskKey: zUserTaskKey
  }),
  query: z.optional(z.never())
});
var zCompleteUserTaskResponse = z.void().register(z.globalRegistry, {
  description: "The user task was completed successfully."
});
var zAssignUserTaskData = z.object({
  body: zUserTaskAssignmentRequest,
  path: z.object({
    userTaskKey: zUserTaskKey
  }),
  query: z.optional(z.never())
});
var zAssignUserTaskResponse = z.void().register(z.globalRegistry, {
  description: "The user task's assignment was adjusted."
});
var zGetUserTaskData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    userTaskKey: zUserTaskKey
  }),
  query: z.optional(z.never())
});
var zGetUserTaskResponse = zUserTaskResult;
var zUpdateUserTaskData = z.object({
  body: z.optional(zUserTaskUpdateRequest),
  path: z.object({
    userTaskKey: zUserTaskKey
  }),
  query: z.optional(z.never())
});
var zUpdateUserTaskResponse = z.void().register(z.globalRegistry, {
  description: "The user task was updated successfully."
});
var zGetUserTaskFormData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    userTaskKey: zUserTaskKey
  }),
  query: z.optional(z.never())
});
var zGetUserTaskFormResponse = z.union([
  zFormResult,
  z.void().register(z.globalRegistry, {
    description: "The user task was found, but no form is associated with it."
  })
]);
var zUnassignUserTaskData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    userTaskKey: zUserTaskKey
  }),
  query: z.optional(z.never())
});
var zUnassignUserTaskResponse = z.void().register(z.globalRegistry, {
  description: "The user task was unassigned successfully."
});
var zSearchUserTasksData = z.object({
  body: z.optional(zUserTaskSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchUserTasksResponse = zUserTaskSearchQueryResult;
var zSearchUserTaskVariablesData = z.object({
  body: z.optional(zUserTaskVariableSearchQueryRequest),
  path: z.object({
    userTaskKey: zUserTaskKey
  }),
  query: z.optional(z.never())
});
var zSearchUserTaskVariablesResponse = zVariableSearchQueryResult;
var zSearchVariablesData = z.object({
  body: z.optional(zVariableSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchVariablesResponse = zVariableSearchQueryResult;
var zGetVariableData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    variableKey: zVariableKey
  }),
  query: z.optional(z.never())
});
var zGetVariableResponse = zVariableResult;
var zPinClockData = z.object({
  body: zClockPinRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zPinClockResponse = z.void().register(z.globalRegistry, {
  description: "The clock was successfully pinned to the specified time in epoch milliseconds.\n"
});
var zResetClockData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zResetClockResponse = z.void().register(z.globalRegistry, {
  description: "The clock was successfully reset to the system time."
});
var zSearchProcessDefinitionsData = z.object({
  body: z.optional(zProcessDefinitionSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchProcessDefinitionsResponse = zProcessDefinitionSearchQueryResult;
var zGetProcessDefinitionData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    processDefinitionKey: zProcessDefinitionKey
  }),
  query: z.optional(z.never())
});
var zGetProcessDefinitionResponse = zProcessDefinitionResult;
var zGetProcessDefinitionXmlData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    processDefinitionKey: zProcessDefinitionKey
  }),
  query: z.optional(z.never())
});
var zGetProcessDefinitionXmlResponse = z.string().register(z.globalRegistry, {
  description: "The XML of the process definition is successfully returned."
});
var zGetStartProcessFormData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    processDefinitionKey: zProcessDefinitionKey
  }),
  query: z.optional(z.never())
});
var zGetStartProcessFormResponse = z.union([
  zFormResult,
  z.void().register(z.globalRegistry, {
    description: "The process was found, but no form is associated with it."
  })
]);
var zGetProcessDefinitionStatisticsData = z.object({
  body: z.optional(zProcessDefinitionElementStatisticsQuery),
  path: z.object({
    processDefinitionKey: zProcessDefinitionKey
  }),
  query: z.optional(z.never())
});
var zGetProcessDefinitionStatisticsResponse = zProcessDefinitionElementStatisticsQueryResult;
var zCreateProcessInstanceData = z.object({
  body: zProcessInstanceCreationInstruction,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zCreateProcessInstanceResponse = zCreateProcessInstanceResult;
var zGetProcessInstanceData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    processInstanceKey: zProcessInstanceKey
  }),
  query: z.optional(z.never())
});
var zGetProcessInstanceResponse = zProcessInstanceResult;
var zGetProcessInstanceSequenceFlowsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    processInstanceKey: zProcessInstanceKey
  }),
  query: z.optional(z.never())
});
var zGetProcessInstanceSequenceFlowsResponse = zProcessInstanceSequenceFlowsQueryResult;
var zGetProcessInstanceStatisticsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    processInstanceKey: zProcessInstanceKey
  }),
  query: z.optional(z.never())
});
var zGetProcessInstanceStatisticsResponse = zProcessInstanceElementStatisticsQueryResult;
var zSearchProcessInstancesData = z.object({
  body: z.optional(zProcessInstanceSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchProcessInstancesResponse = zProcessInstanceSearchQueryResult;
var zSearchProcessInstanceIncidentsData = z.object({
  body: z.optional(zProcessInstanceIncidentSearchQuery),
  path: z.object({
    processInstanceKey: zProcessInstanceKey
  }),
  query: z.optional(z.never())
});
var zSearchProcessInstanceIncidentsResponse = zIncidentSearchQueryResult;
var zCancelProcessInstanceData = z.object({
  body: z.optional(zCancelProcessInstanceRequest),
  path: z.object({
    processInstanceKey: zProcessInstanceKey
  }),
  query: z.optional(z.never())
});
var zCancelProcessInstanceResponse = z.void().register(z.globalRegistry, {
  description: "The process instance is canceled."
});
var zCancelProcessInstancesBatchOperationData = z.object({
  body: zProcessInstanceCancellationBatchOperationRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zCancelProcessInstancesBatchOperationResponse = zBatchOperationCreatedResult;
var zResolveIncidentsBatchOperationData = z.object({
  body: z.optional(zProcessInstanceIncidentResolutionBatchOperationRequest),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zResolveIncidentsBatchOperationResponse = zBatchOperationCreatedResult;
var zMigrateProcessInstancesBatchOperationData = z.object({
  body: zProcessInstanceMigrationBatchOperationRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zMigrateProcessInstancesBatchOperationResponse = zBatchOperationCreatedResult;
var zModifyProcessInstancesBatchOperationData = z.object({
  body: zProcessInstanceModificationBatchOperationRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zModifyProcessInstancesBatchOperationResponse = zBatchOperationCreatedResult;
var zMigrateProcessInstanceData = z.object({
  body: zProcessInstanceMigrationInstruction,
  path: z.object({
    processInstanceKey: zProcessInstanceKey
  }),
  query: z.optional(z.never())
});
var zMigrateProcessInstanceResponse = z.void().register(z.globalRegistry, {
  description: "The process instance is migrated."
});
var zModifyProcessInstanceData = z.object({
  body: zProcessInstanceModificationInstruction,
  path: z.object({
    processInstanceKey: zProcessInstanceKey
  }),
  query: z.optional(z.never())
});
var zModifyProcessInstanceResponse = z.void().register(z.globalRegistry, {
  description: "The process instance is modified."
});
var zGetProcessInstanceCallHierarchyData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    processInstanceKey: zProcessInstanceKey
  }),
  query: z.optional(z.never())
});
var zGetProcessInstanceCallHierarchyResponse = z.array(zProcessInstanceCallHierarchyEntry).register(z.globalRegistry, {
  description: "The call hierarchy is successfully returned."
});
var zSearchElementInstancesData = z.object({
  body: z.optional(zElementInstanceSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchElementInstancesResponse = zElementInstanceSearchQueryResult;
var zGetElementInstanceData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    elementInstanceKey: zElementInstanceKey
  }),
  query: z.optional(z.never())
});
var zGetElementInstanceResponse = zElementInstanceResult;
var zSearchDecisionDefinitionsData = z.object({
  body: z.optional(zDecisionDefinitionSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchDecisionDefinitionsResponse = zDecisionDefinitionSearchQueryResult;
var zGetDecisionDefinitionData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    decisionDefinitionKey: zDecisionDefinitionKey
  }),
  query: z.optional(z.never())
});
var zGetDecisionDefinitionResponse = zDecisionDefinitionResult;
var zGetDecisionDefinitionXmlData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    decisionDefinitionKey: zDecisionDefinitionKey
  }),
  query: z.optional(z.never())
});
var zGetDecisionDefinitionXmlResponse = z.string().register(z.globalRegistry, {
  description: "The XML of the decision definition is successfully returned."
});
var zSearchDecisionRequirementsData = z.object({
  body: z.optional(zDecisionRequirementsSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchDecisionRequirementsResponse = zDecisionRequirementsSearchQueryResult;
var zGetDecisionRequirementsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    decisionRequirementsKey: zDecisionRequirementsKey
  }),
  query: z.optional(z.never())
});
var zGetDecisionRequirementsResponse = zDecisionRequirementsResult;
var zGetDecisionRequirementsXmlData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    decisionRequirementsKey: zDecisionRequirementsKey
  }),
  query: z.optional(z.never())
});
var zGetDecisionRequirementsXmlResponse = z.string().register(z.globalRegistry, {
  description: "The XML of the decision requirements is successfully returned."
});
var zSearchDecisionInstancesData = z.object({
  body: z.optional(zDecisionInstanceSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchDecisionInstancesResponse = zDecisionInstanceSearchQueryResult;
var zGetDecisionInstanceData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    decisionEvaluationInstanceKey: zDecisionEvaluationInstanceKey
  }),
  query: z.optional(z.never())
});
var zGetDecisionInstanceResponse = zDecisionInstanceGetQueryResult;
var zEvaluateDecisionData = z.object({
  body: zDecisionEvaluationInstruction,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zEvaluateDecisionResponse = zEvaluateDecisionResult;
var zCreateAuthorizationData = z.object({
  body: zAuthorizationRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zCreateAuthorizationResponse = zAuthorizationCreateResult;
var zDeleteAuthorizationData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    authorizationKey: zAuthorizationKey
  }),
  query: z.optional(z.never())
});
var zDeleteAuthorizationResponse = z.void().register(z.globalRegistry, {
  description: "The authorization was deleted successfully."
});
var zGetAuthorizationData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    authorizationKey: zAuthorizationKey
  }),
  query: z.optional(z.never())
});
var zGetAuthorizationResponse = zAuthorizationResult;
var zUpdateAuthorizationData = z.object({
  body: zAuthorizationRequest,
  path: z.object({
    authorizationKey: zAuthorizationKey
  }),
  query: z.optional(z.never())
});
var zUpdateAuthorizationResponse = z.void().register(z.globalRegistry, {
  description: "The authorization was updated successfully."
});
var zSearchAuthorizationsData = z.object({
  body: z.optional(zAuthorizationSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchAuthorizationsResponse = zAuthorizationSearchResult;
var zCreateRoleData = z.object({
  body: z.optional(zRoleCreateRequest),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zCreateRoleResponse = zRoleCreateResult;
var zDeleteRoleData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The ID of the role to delete."
    })
  }),
  query: z.optional(z.never())
});
var zDeleteRoleResponse = z.void().register(z.globalRegistry, {
  description: "The role was deleted successfully."
});
var zGetRoleData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The role ID."
    })
  }),
  query: z.optional(z.never())
});
var zGetRoleResponse = zRoleResult;
var zUpdateRoleData = z.object({
  body: zRoleUpdateRequest,
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The ID of the role to update."
    })
  }),
  query: z.optional(z.never())
});
var zUpdateRoleResponse = zRoleUpdateResult;
var zSearchUsersForRoleData = z.object({
  body: z.optional(zRoleUserSearchQueryRequest),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The role ID."
    })
  }),
  query: z.optional(z.never())
});
var zSearchUsersForRoleResponse = zRoleUserSearchResult;
var zSearchClientsForRoleData = z.object({
  body: z.optional(zRoleClientSearchQueryRequest),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The role ID."
    })
  }),
  query: z.optional(z.never())
});
var zSearchClientsForRoleResponse = zRoleClientSearchResult;
var zUnassignRoleFromUserData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The role ID."
    }),
    username: zUsername
  }),
  query: z.optional(z.never())
});
var zUnassignRoleFromUserResponse = z.void().register(z.globalRegistry, {
  description: "The role was unassigned successfully from the user."
});
var zAssignRoleToUserData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The role ID."
    }),
    username: zUsername
  }),
  query: z.optional(z.never())
});
var zAssignRoleToUserResponse = z.void().register(z.globalRegistry, {
  description: "The role was assigned successfully to the user."
});
var zUnassignRoleFromClientData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The role ID."
    }),
    clientId: z.string().register(z.globalRegistry, {
      description: "The client ID."
    })
  }),
  query: z.optional(z.never())
});
var zUnassignRoleFromClientResponse = z.void().register(z.globalRegistry, {
  description: "The role was unassigned successfully from the client."
});
var zAssignRoleToClientData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The role ID."
    }),
    clientId: z.string().register(z.globalRegistry, {
      description: "The client ID."
    })
  }),
  query: z.optional(z.never())
});
var zAssignRoleToClientResponse = z.void().register(z.globalRegistry, {
  description: "The role was assigned successfully to the client."
});
var zSearchRolesData = z.object({
  body: z.optional(zRoleSearchQueryRequest),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchRolesResponse = zRoleSearchQueryResult;
var zUnassignRoleFromGroupData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The role ID."
    }),
    groupId: z.string().register(z.globalRegistry, {
      description: "The group ID."
    })
  }),
  query: z.optional(z.never())
});
var zUnassignRoleFromGroupResponse = z.void().register(z.globalRegistry, {
  description: "The role was unassigned successfully from the group."
});
var zAssignRoleToGroupData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The role ID."
    }),
    groupId: z.string().register(z.globalRegistry, {
      description: "The group ID."
    })
  }),
  query: z.optional(z.never())
});
var zAssignRoleToGroupResponse = z.void().register(z.globalRegistry, {
  description: "The role was assigned successfully to the group."
});
var zSearchGroupsForRoleData = z.object({
  body: z.optional(zRoleGroupSearchQueryRequest),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The role ID."
    })
  }),
  query: z.optional(z.never())
});
var zSearchGroupsForRoleResponse = zRoleGroupSearchResult;
var zUnassignRoleFromMappingRuleData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The role ID."
    }),
    mappingRuleId: z.string().register(z.globalRegistry, {
      description: "The mapping rule ID."
    })
  }),
  query: z.optional(z.never())
});
var zUnassignRoleFromMappingRuleResponse = z.void().register(z.globalRegistry, {
  description: "The role was unassigned successfully from the mapping rule."
});
var zAssignRoleToMappingRuleData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The role ID."
    }),
    mappingRuleId: z.string().register(z.globalRegistry, {
      description: "The mapping rule ID."
    })
  }),
  query: z.optional(z.never())
});
var zAssignRoleToMappingRuleResponse = z.void().register(z.globalRegistry, {
  description: "The role was assigned successfully to the mapping rule."
});
var zSearchMappingRulesForRoleData = z.object({
  body: z.optional(zMappingRuleSearchQueryRequest),
  path: z.object({
    roleId: z.string().register(z.globalRegistry, {
      description: "The role ID."
    })
  }),
  query: z.optional(z.never())
});
var zSearchMappingRulesForRoleResponse = zMappingRuleSearchQueryResult;
var zCreateGroupData = z.object({
  body: z.optional(zGroupCreateRequest),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zCreateGroupResponse = zGroupCreateResult;
var zDeleteGroupData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    groupId: z.string().register(z.globalRegistry, {
      description: "The ID of the group to delete."
    })
  }),
  query: z.optional(z.never())
});
var zDeleteGroupResponse = z.void().register(z.globalRegistry, {
  description: "The group was deleted successfully."
});
var zGetGroupData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    groupId: z.string().register(z.globalRegistry, {
      description: "The group ID."
    })
  }),
  query: z.optional(z.never())
});
var zGetGroupResponse = zGroupResult;
var zUpdateGroupData = z.object({
  body: zGroupUpdateRequest,
  path: z.object({
    groupId: z.string().register(z.globalRegistry, {
      description: "The ID of the group to update."
    })
  }),
  query: z.optional(z.never())
});
var zUpdateGroupResponse = zGroupUpdateResult;
var zSearchUsersForGroupData = z.object({
  body: z.optional(zGroupUserSearchQueryRequest),
  path: z.object({
    groupId: z.string().register(z.globalRegistry, {
      description: "The group ID."
    })
  }),
  query: z.optional(z.never())
});
var zSearchUsersForGroupResponse = zGroupUserSearchResult;
var zSearchMappingRulesForGroupData = z.object({
  body: z.optional(zMappingRuleSearchQueryRequest),
  path: z.object({
    groupId: z.string().register(z.globalRegistry, {
      description: "The group ID."
    })
  }),
  query: z.optional(z.never())
});
var zSearchMappingRulesForGroupResponse = zMappingRuleSearchQueryResult;
var zSearchRolesForGroupData = z.object({
  body: z.optional(zRoleSearchQueryRequest),
  path: z.object({
    groupId: z.string().register(z.globalRegistry, {
      description: "The group ID."
    })
  }),
  query: z.optional(z.never())
});
var zSearchRolesForGroupResponse = zRoleSearchQueryResult;
var zSearchClientsForGroupData = z.object({
  body: z.optional(zGroupClientSearchQueryRequest),
  path: z.object({
    groupId: z.string().register(z.globalRegistry, {
      description: "The group ID."
    })
  }),
  query: z.optional(z.never())
});
var zSearchClientsForGroupResponse = zGroupClientSearchResult;
var zUnassignUserFromGroupData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    groupId: z.string().register(z.globalRegistry, {
      description: "The group ID."
    }),
    username: zUsername
  }),
  query: z.optional(z.never())
});
var zUnassignUserFromGroupResponse = z.void().register(z.globalRegistry, {
  description: "The user was unassigned successfully from the group."
});
var zAssignUserToGroupData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    groupId: z.string().register(z.globalRegistry, {
      description: "The group ID."
    }),
    username: zUsername
  }),
  query: z.optional(z.never())
});
var zAssignUserToGroupResponse = z.void().register(z.globalRegistry, {
  description: "The user was assigned successfully to the group."
});
var zUnassignClientFromGroupData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    groupId: z.string().register(z.globalRegistry, {
      description: "The group ID."
    }),
    clientId: z.string().register(z.globalRegistry, {
      description: "The client ID."
    })
  }),
  query: z.optional(z.never())
});
var zUnassignClientFromGroupResponse = z.void().register(z.globalRegistry, {
  description: "The client was unassigned successfully from the group."
});
var zAssignClientToGroupData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    groupId: z.string().register(z.globalRegistry, {
      description: "The group ID."
    }),
    clientId: z.string().register(z.globalRegistry, {
      description: "The client ID."
    })
  }),
  query: z.optional(z.never())
});
var zAssignClientToGroupResponse = z.void().register(z.globalRegistry, {
  description: "The client was assigned successfully to the group."
});
var zUnassignMappingRuleFromGroupData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    groupId: z.string().register(z.globalRegistry, {
      description: "The group ID."
    }),
    mappingRuleId: z.string().register(z.globalRegistry, {
      description: "The mapping rule ID."
    })
  }),
  query: z.optional(z.never())
});
var zUnassignMappingRuleFromGroupResponse = z.void().register(z.globalRegistry, {
  description: "The mapping rule was unassigned successfully from the group."
});
var zAssignMappingRuleToGroupData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    groupId: z.string().register(z.globalRegistry, {
      description: "The group ID."
    }),
    mappingRuleId: z.string().register(z.globalRegistry, {
      description: "The mapping rule ID."
    })
  }),
  query: z.optional(z.never())
});
var zAssignMappingRuleToGroupResponse = z.void().register(z.globalRegistry, {
  description: "The mapping rule was assigned successfully to the group."
});
var zSearchGroupsData = z.object({
  body: z.optional(zGroupSearchQueryRequest),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchGroupsResponse = zGroupSearchQueryResult;
var zCreateMappingRuleData = z.object({
  body: z.optional(zMappingRuleCreateRequest),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zCreateMappingRuleResponse = zMappingRuleCreateResult;
var zDeleteMappingRuleData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    mappingRuleId: z.string().register(z.globalRegistry, {
      description: "The ID of the mapping rule to delete."
    })
  }),
  query: z.optional(z.never())
});
var zDeleteMappingRuleResponse = z.void().register(z.globalRegistry, {
  description: "The mapping rule was deleted successfully."
});
var zGetMappingRuleData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    mappingRuleId: z.string().register(z.globalRegistry, {
      description: "The ID of the mapping rule to get."
    })
  }),
  query: z.optional(z.never())
});
var zGetMappingRuleResponse = zMappingRuleResult;
var zUpdateMappingRuleData = z.object({
  body: z.optional(zMappingRuleUpdateRequest),
  path: z.object({
    mappingRuleId: z.string().register(z.globalRegistry, {
      description: "The ID of the mapping rule to update."
    })
  }),
  query: z.optional(z.never())
});
var zUpdateMappingRuleResponse = zMappingRuleUpdateResult;
var zSearchMappingRuleData = z.object({
  body: z.optional(zMappingRuleSearchQueryRequest),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchMappingRuleResponse = zMappingRuleSearchQueryResult;
var zPublishMessageData = z.object({
  body: zMessagePublicationRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zPublishMessageResponse = zMessagePublicationResult;
var zCorrelateMessageData = z.object({
  body: zMessageCorrelationRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zCorrelateMessageResponse = zMessageCorrelationResult;
var zSearchCorrelatedMessageSubscriptionsData = z.object({
  body: z.optional(zCorrelatedMessageSubscriptionSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchCorrelatedMessageSubscriptionsResponse = zCorrelatedMessageSubscriptionSearchQueryResult;
var zSearchMessageSubscriptionsData = z.object({
  body: z.optional(zMessageSubscriptionSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchMessageSubscriptionsResponse = zMessageSubscriptionSearchQueryResult;
var zCreateDocumentData = z.object({
  body: z.object({
    file: z.string(),
    metadata: z.optional(zDocumentMetadata)
  }),
  path: z.optional(z.never()),
  query: z.optional(z.object({
    storeId: z.optional(z.string().register(z.globalRegistry, {
      description: "The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores."
    })),
    documentId: z.optional(z.string().register(z.globalRegistry, {
      description: "The ID of the document to upload. If not provided, a new ID will be generated. Specifying an existing ID will result in an error if the document already exists.\n"
    }))
  }))
});
var zCreateDocumentResponse = zDocumentReference;
var zCreateDocumentsData = z.object({
  body: z.object({
    files: z.array(z.string()).min(1).register(z.globalRegistry, {
      description: "The documents to upload."
    }),
    metadataList: z.optional(z.array(zDocumentMetadata).register(z.globalRegistry, {
      description: "Optional JSON array of metadata object whose index aligns with each file entry. The metadata array must have the same length as the files array.\n"
    }))
  }),
  path: z.optional(z.never()),
  query: z.optional(z.object({
    storeId: z.optional(z.string().register(z.globalRegistry, {
      description: "The ID of the document store to upload the documents to. Currently, only a single document store is supported per cluster. However, this attribute is included to allow for potential future support of multiple document stores."
    }))
  }))
});
var zCreateDocumentsResponse = zDocumentCreationBatchResponse;
var zDeleteDocumentData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    documentId: zDocumentId
  }),
  query: z.optional(z.object({
    storeId: z.optional(z.string().register(z.globalRegistry, {
      description: "The ID of the document store to delete the document from."
    }))
  }))
});
var zDeleteDocumentResponse = z.void().register(z.globalRegistry, {
  description: "The document was deleted successfully."
});
var zGetDocumentData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    documentId: zDocumentId
  }),
  query: z.object({
    storeId: z.optional(z.string().register(z.globalRegistry, {
      description: "The ID of the document store to download the document from."
    })),
    contentHash: z.string().register(z.globalRegistry, {
      description: "The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.\n"
    })
  })
});
var zGetDocumentResponse = z.string().register(z.globalRegistry, {
  description: "The document was downloaded successfully."
});
var zCreateDocumentLinkData = z.object({
  body: z.optional(zDocumentLinkRequest),
  path: z.object({
    documentId: zDocumentId
  }),
  query: z.object({
    storeId: z.optional(z.string().register(z.globalRegistry, {
      description: "The ID of the document store to link the document from."
    })),
    contentHash: z.string().register(z.globalRegistry, {
      description: "The hash of the document content that was computed by the document store during upload. The hash is part of the document reference that is returned when uploading a document. If the client fails to provide the correct hash, the request will be rejected.\n"
    })
  })
});
var zCreateDocumentLinkResponse = zDocumentLink;
var zCreateUserData = z.object({
  body: zUserRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zCreateUserResponse = zUserCreateResult;
var zSearchUsersData = z.object({
  body: z.optional(zUserSearchQueryRequest),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchUsersResponse = zUserSearchResult;
var zDeleteUserData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    username: zUsername
  }),
  query: z.optional(z.never())
});
var zDeleteUserResponse = z.void().register(z.globalRegistry, {
  description: "The user was deleted successfully."
});
var zGetUserData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    username: zUsername
  }),
  query: z.optional(z.never())
});
var zGetUserResponse = zUserResult;
var zUpdateUserData = z.object({
  body: zUserUpdateRequest,
  path: z.object({
    username: zUsername
  }),
  query: z.optional(z.never())
});
var zUpdateUserResponse = zUserUpdateResult;
var zCreateAdminUserData = z.object({
  body: zUserRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zCreateAdminUserResponse = zUserCreateResult;
var zSearchIncidentsData = z.object({
  body: z.optional(zIncidentSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchIncidentsResponse = zIncidentSearchQueryResult;
var zGetIncidentData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    incidentKey: zIncidentKey
  }),
  query: z.optional(z.never())
});
var zGetIncidentResponse = zIncidentResult;
var zGetUsageMetricsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    startTime: z.iso.datetime().register(z.globalRegistry, {
      description: "The start date for usage metrics, including this date. Value in ISO 8601 format."
    }),
    endTime: z.iso.datetime().register(z.globalRegistry, {
      description: "The end date for usage metrics, including this date. Value in ISO 8601 format."
    }),
    tenantId: z.optional(zTenantId),
    withTenants: z.optional(z.boolean().register(z.globalRegistry, {
      description: "Whether to return tenant metrics in addition to the total metrics or not. Default false."
    })).default(false)
  })
});
var zGetUsageMetricsResponse = zUsageMetricsResponse;
var zCreateDeploymentData = z.object({
  body: z.object({
    resources: z.array(
      z.any().refine(
        (v) => typeof File !== "undefined" && v instanceof File,
        { message: "Expected File (with a filename & extension)" }
      )
    ).nonempty().register(z.globalRegistry, {}),
    tenantId: z.optional(z.string().register(z.globalRegistry, {
      description: "The tenant to deploy the resources to."
    }))
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zCreateDeploymentResponse = zDeploymentResult;
var zDeleteResourceData = z.object({
  body: z.optional(zDeleteResourceRequest),
  path: z.object({
    resourceKey: zResourceKey
  }),
  query: z.optional(z.never())
});
var zGetResourceData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    resourceKey: zResourceKey
  }),
  query: z.optional(z.never())
});
var zGetResourceResponse = zResourceResult;
var zGetResourceContentData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    resourceKey: zResourceKey
  }),
  query: z.optional(z.never())
});
var zGetResourceContentResponse = z.string().register(z.globalRegistry, {
  description: "The resource content is successfully returned."
});
var zCreateElementInstanceVariablesData = z.object({
  body: zSetVariableRequest,
  path: z.object({
    elementInstanceKey: zElementInstanceKey
  }),
  query: z.optional(z.never())
});
var zCreateElementInstanceVariablesResponse = z.void().register(z.globalRegistry, {
  description: "The variables were updated."
});
var zActivateAdHocSubProcessActivitiesData = z.object({
  body: zAdHocSubProcessActivateActivitiesInstruction,
  path: z.object({
    adHocSubProcessInstanceKey: zElementInstanceKey
  }),
  query: z.optional(z.never())
});
var zActivateAdHocSubProcessActivitiesResponse = z.void().register(z.globalRegistry, {
  description: "The ad-hoc sub-process instance is modified."
});
var zBroadcastSignalData = z.object({
  body: zSignalBroadcastRequest,
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zBroadcastSignalResponse = zSignalBroadcastResult;
var zGetBatchOperationData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    batchOperationKey: zBatchOperationKey
  }),
  query: z.optional(z.never())
});
var zGetBatchOperationResponse = zBatchOperationResponse;
var zSearchBatchOperationsData = z.object({
  body: z.optional(zBatchOperationSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchBatchOperationsResponse = zBatchOperationSearchQueryResult;
var zCancelBatchOperationData = z.object({
  body: z.optional(z.unknown()),
  path: z.object({
    batchOperationKey: zBatchOperationKey
  }),
  query: z.optional(z.never())
});
var zCancelBatchOperationResponse = z.void().register(z.globalRegistry, {
  description: "The batch operation cancel request was created."
});
var zSuspendBatchOperationData = z.object({
  body: z.optional(z.unknown()),
  path: z.object({
    batchOperationKey: zBatchOperationKey
  }),
  query: z.optional(z.never())
});
var zSuspendBatchOperationResponse = z.void().register(z.globalRegistry, {
  description: "The batch operation pause request was created."
});
var zResumeBatchOperationData = z.object({
  body: z.optional(z.unknown()),
  path: z.object({
    batchOperationKey: zBatchOperationKey
  }),
  query: z.optional(z.never())
});
var zResumeBatchOperationResponse = z.void().register(z.globalRegistry, {
  description: "The batch operation resume request was created."
});
var zSearchBatchOperationItemsData = z.object({
  body: z.optional(zBatchOperationItemSearchQuery),
  path: z.optional(z.never()),
  query: z.optional(z.never())
});
var zSearchBatchOperationItemsResponse = zBatchOperationItemSearchQueryResult;

// src/runtime/auth.ts
var CamundaAuthError = class extends Error {
  constructor(code, message, cause) {
    super(`${code}: ${message}`);
    this.code = code;
    this.cause = cause;
    this.name = "CamundaAuthError";
  }
};
var OAuthManager = class {
  constructor(cfg, logger, tHooks, correlationProvider) {
    this.cfg = cfg;
    this.logger = logger;
    this.tHooks = tHooks;
    this.correlationProvider = correlationProvider;
    const hashBase = `${cfg.oauth.oauthUrl}|${cfg.oauth.clientId || ""}|${cfg.tokenAudience}|${cfg.oauth.scope || ""}`;
    this.storageKey = "camunda_oauth_token_cache_" + this.simpleHash(hashBase);
    this.session = this.isBrowser && typeof window.sessionStorage !== "undefined" ? window.sessionStorage : null;
    this.loadPersisted();
  }
  refreshing = null;
  token = null;
  storageKey;
  isBrowser = typeof window !== "undefined";
  session;
  simpleHash(s) {
    let h = 0;
    for (let i = 0; i < s.length; i++) {
      h = Math.imul(31, h) + s.charCodeAt(i) | 0;
    }
    return (h >>> 0).toString(16);
  }
  log(...args) {
    this.logger.debug(...args);
  }
  now() {
    return Date.now();
  }
  loadPersisted() {
    if (this.session) {
      try {
        const raw = this.session.getItem(this.storageKey);
        if (raw) {
          this.token = JSON.parse(raw);
        }
      } catch {
      }
    }
    if (!this.session && this.cfg.oauth.cacheDir && this.isNode()) {
      try {
        const fs = __require("fs");
        const path2 = __require("path");
        const file = path2.join(this.cfg.oauth.cacheDir, this.storageKey + ".json");
        if (fs.existsSync(file)) {
          const raw = fs.readFileSync(file, "utf8");
          this.token = JSON.parse(raw);
        }
      } catch {
      }
    }
  }
  persist() {
    if (this.token) {
      if (this.session) {
        try {
          this.session.setItem(this.storageKey, JSON.stringify(this.token));
        } catch {
        }
      } else if (this.cfg.oauth.cacheDir && this.isNode()) {
        try {
          const fs = __require("fs");
          const path2 = __require("path");
          if (!fs.existsSync(this.cfg.oauth.cacheDir))
            fs.mkdirSync(this.cfg.oauth.cacheDir, { recursive: true });
          const file = path2.join(this.cfg.oauth.cacheDir, this.storageKey + ".json");
          const tmp = file + ".tmp";
          fs.writeFileSync(tmp, JSON.stringify(this.token), { mode: 384 });
          fs.renameSync(tmp, file);
        } catch {
        }
      }
    }
  }
  isNode() {
    return typeof process !== "undefined" && !!process.versions?.node;
  }
  effectiveExpiry(t) {
    return t.expires_at_epoch_ms;
  }
  shouldRefresh(t) {
    const now2 = this.now();
    if (now2 < t.obtained_at_epoch_ms - 3e4) {
      this.log("Clock skew backwards detected; invalidating token");
      return true;
    }
    const refreshLead = 5e3;
    return now2 >= this.effectiveExpiry(t) - refreshLead;
  }
  async getToken(fetcher) {
    if (this.token && !this.shouldRefresh(this.token)) return this.token.access_token;
    if (this.refreshing) {
      try {
        return await this.refreshing;
      } catch (e) {
        if (this.token && !this.shouldRefresh(this.token)) return this.token.access_token;
        throw e;
      }
    }
    this.refreshing = this.fetchAndStore(fetcher).finally(() => {
      this.refreshing = null;
    });
    return this.refreshing;
  }
  async forceRefresh(fetcher) {
    this.refreshing = this.fetchAndStore(fetcher).finally(() => {
      this.refreshing = null;
    });
    return this.refreshing;
  }
  clearCache(opts = { disk: true, memory: true }) {
    if (opts.memory) this.token = null;
    if (opts.disk) {
      if (this.session) {
        this.session.removeItem(this.storageKey);
      } else if (this.cfg.oauth.cacheDir && this.isNode()) {
        try {
          const fs = __require("fs");
          const path2 = __require("path");
          const file = path2.join(this.cfg.oauth.cacheDir, this.storageKey + ".json");
          if (fs.existsSync(file)) fs.unlinkSync(file);
        } catch {
        }
      }
    }
  }
  async fetchAndStore(fetcher) {
    if (!this.cfg.oauth.clientId || !this.cfg.oauth.clientSecret)
      throw new CamundaAuthError(
        "OAUTH_CONFIG_MISSING" /* OAUTH_CONFIG_MISSING */,
        "Missing OAuth client credentials"
      );
    const body = new URLSearchParams();
    body.set("grant_type", this.cfg.oauth.grantType || "client_credentials");
    body.set("client_id", this.cfg.oauth.clientId);
    body.set("client_secret", this.cfg.oauth.clientSecret);
    body.set("audience", this.cfg.tokenAudience);
    if (this.cfg.oauth.scope) body.set("scope", this.cfg.oauth.scope);
    const max = this.cfg.oauth.retry.max || 5;
    const base = this.cfg.oauth.retry.baseDelayMs || 1e3;
    let attempt = 0;
    let lastErr;
    while (attempt < max) {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), this.cfg.oauth.timeoutMs);
      try {
        if (attempt === 0) {
          const evt = {
            type: "auth.start",
            ts: Date.now(),
            audience: this.cfg.tokenAudience,
            endpoint: this.cfg.oauth.oauthUrl,
            cache: !!this.token,
            correlationId: this.correlationProvider?.()
          };
          try {
            this.tHooks?.authStart?.(evt);
          } catch {
          }
        }
        this.logger.debug(`OAuth token attempt ${attempt + 1}/${max}`);
        const res = await fetcher(this.cfg.oauth.oauthUrl, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: body.toString(),
          signal: controller.signal
        });
        clearTimeout(timeout);
        if (!res.ok) {
          lastErr = new Error(`HTTP ${res.status}`);
          throw lastErr;
        }
        const json = await res.json();
        if (!json.access_token || !json.expires_in)
          throw new CamundaAuthError(
            "TOKEN_PARSE_FAILED" /* TOKEN_PARSE_FAILED */,
            "Missing access_token or expires_in in response"
          );
        const now2 = this.now();
        const lifetimeMs = json.expires_in * 1e3;
        const skewBuffer = Math.max(3e4, Math.floor(lifetimeMs * 0.05));
        const entry = {
          access_token: json.access_token,
          token_type: json.token_type,
          scope: json.scope,
          obtained_at_epoch_ms: now2,
          expires_at_epoch_ms: now2 + lifetimeMs - skewBuffer,
          oauth_url: this.cfg.oauth.oauthUrl,
          client_id: this.cfg.oauth.clientId,
          audience: this.cfg.tokenAudience
        };
        this.token = entry;
        this.persist();
        this.logger.info(
          "Token fetched; effective expiry (s)=",
          Math.round((entry.expires_at_epoch_ms - now2) / 1e3)
        );
        try {
          const evt = {
            type: "auth.success",
            ts: Date.now(),
            audience: this.cfg.tokenAudience,
            endpoint: this.cfg.oauth.oauthUrl,
            cached: false,
            durationMs: Date.now() - now2,
            expiresInSec: Math.round((entry.expires_at_epoch_ms - now2) / 1e3),
            scopes: entry.scope ? String(entry.scope).split(/\s+/) : void 0,
            correlationId: this.correlationProvider?.()
          };
          this.tHooks?.authSuccess?.(evt);
        } catch {
        }
        return entry.access_token;
      } catch (e) {
        clearTimeout(timeout);
        lastErr = e;
        attempt++;
        if (attempt >= max) break;
        const delay = base * Math.pow(2, attempt - 1);
        const jitter = delay * 0.2 * (Math.random() - 0.5);
        const sleep2 = delay + jitter;
        try {
          this.tHooks?.retry?.({
            type: "retry",
            ts: Date.now(),
            attempt,
            nextDelayMs: Math.round(sleep2),
            reason: lastErr?.message || "error",
            domain: "auth",
            correlationId: this.correlationProvider?.()
          });
        } catch {
        }
        await new Promise((r) => setTimeout(r, sleep2));
      }
    }
    try {
      const evt = {
        type: "auth.error",
        ts: Date.now(),
        audience: this.cfg.tokenAudience,
        endpoint: this.cfg.oauth.oauthUrl,
        durationMs: 0,
        status: lastErr?.message?.match(/HTTP (\d+)/)?.[1] ? parseInt(RegExp.$1, 10) : void 0,
        message: lastErr?.message || String(lastErr),
        correlationId: this.correlationProvider?.()
      };
      this.tHooks?.authError?.(evt);
    } catch {
    }
    throw new CamundaAuthError(
      "TOKEN_FETCH_FAILED" /* TOKEN_FETCH_FAILED */,
      `Failed to fetch token after ${max} attempts: ${lastErr?.message || lastErr}`,
      lastErr
    );
  }
};
var BasicAuthManager = class {
  constructor(cfg) {
    this.cfg = cfg;
    const u = cfg.auth.basic?.username?.trim();
    const p = cfg.auth.basic?.password?.trim();
    if (!u || !p)
      throw new CamundaAuthError(
        "BASIC_CREDENTIALS_MISSING" /* BASIC_CREDENTIALS_MISSING */,
        "Missing basic auth username or password"
      );
    if (typeof Buffer !== "undefined") {
      this.token = Buffer.from(`${u}:${p}`).toString("base64");
    } else {
      this.token = btoa(`${u}:${p}`);
    }
  }
  token;
  getHeader() {
    return `Basic ${this.token}`;
  }
};
function createAuthFacade(config, opts) {
  const cfg = config;
  const noop = {
    level: () => "silent",
    setLevel: () => {
    },
    setTransport: () => {
    },
    error: () => {
    },
    warn: () => {
    },
    info: () => {
    },
    debug: () => {
    },
    trace: () => {
    },
    code: () => {
    },
    scope: () => noop
  };
  const authLogger = (opts?.logger || noop).scope("auth");
  const tHooks = opts?.telemetryHooks;
  const hooks = [];
  let oauth = null;
  let basic = null;
  if (cfg.auth.strategy === "OAUTH")
    oauth = new OAuthManager(cfg, authLogger.scope("oauth"), tHooks, opts?.correlationProvider);
  else if (cfg.auth.strategy === "BASIC") basic = new BasicAuthManager(cfg);
  const fetcher = (input, init) => opts?.fetch ? opts.fetch(input, init) : fetch(input, init);
  let nodeAgent = null;
  if (cfg.mtls && typeof process !== "undefined" && process.versions?.node) {
    try {
      const fs = __require("fs");
      const https = __require("https");
      const material = {};
      if (cfg.mtls.cert || cfg.mtls.certPath)
        material.cert = cfg.mtls.cert || fs.readFileSync(cfg.mtls.certPath, "utf8");
      if (cfg.mtls.key || cfg.mtls.keyPath)
        material.key = cfg.mtls.key || fs.readFileSync(cfg.mtls.keyPath, "utf8");
      if (cfg.mtls.ca || cfg.mtls.caPath)
        material.ca = cfg.mtls.ca || fs.readFileSync(cfg.mtls.caPath, "utf8");
      if (cfg.mtls.keyPassphrase) material.passphrase = cfg.mtls.keyPassphrase;
      nodeAgent = new https.Agent(material);
      try {
        globalThis.__CAMUNDA_MTLS_AGENT = nodeAgent;
      } catch {
      }
    } catch (e) {
      authLogger.warn(
        "Failed to create mTLS agent \u2013 proceeding without mTLS",
        e?.message || e
      );
    }
  }
  const withAgent = async (input, init) => {
    if (nodeAgent) {
      return fetcher(input, { ...init || {}, agent: nodeAgent });
    }
    return fetcher(input, init);
  };
  return {
    async getAuthHeaders() {
      const h = {};
      if (oauth) h["Authorization"] = "Bearer " + await oauth.getToken(withAgent);
      else if (basic) h["Authorization"] = basic.getHeader();
      let acc = h;
      for (const hook of hooks) {
        acc = await hook(acc);
      }
      return acc;
    },
    async forceRefresh() {
      if (oauth) return oauth.forceRefresh(withAgent);
      return void 0;
    },
    clearCache(opts2) {
      if (oauth) oauth.clearCache(opts2);
    },
    registerHeadersHook(h) {
      hooks.push(h);
    },
    debug__setTokenExpiry(epochMs) {
      if (oauth && oauth["token"]) {
        oauth.token.expires_at_epoch_ms = epochMs;
      }
    }
  };
}

// src/runtime/unifiedConfiguration.ts
import path from "path";
import { createEnv } from "typed-env";

// src/runtime/configSchema.ts
var SCHEMA = {
  CAMUNDA_REST_ADDRESS: {
    type: "string",
    default: "http://localhost:8080/v2",
    doc: "Base REST endpoint address."
  },
  CAMUNDA_SDK_HTTP_RETRY_MAX_ATTEMPTS: {
    desc: "Maximum total HTTP attempts (including the initial attempt) for transient failures (429,503, network).",
    type: "int",
    default: 3
  },
  CAMUNDA_SDK_HTTP_RETRY_BASE_DELAY_MS: {
    desc: "Base delay in milliseconds for exponential backoff (full jitter) for HTTP retries.",
    type: "int",
    default: 100
  },
  CAMUNDA_SDK_HTTP_RETRY_MAX_DELAY_MS: {
    desc: "Maximum delay cap in milliseconds for HTTP retry backoff.",
    type: "int",
    default: 2e3
  },
  CAMUNDA_TOKEN_AUDIENCE: {
    type: "string",
    default: "zeebe.camunda.io",
    doc: "Token audience for OAuth flows."
  },
  CAMUNDA_CLIENT_ID: {
    type: "string",
    doc: "OAuth client id (required when CAMUNDA_AUTH_STRATEGY=OAUTH).",
    requiredWhen: { key: "CAMUNDA_AUTH_STRATEGY", equals: "OAUTH" }
  },
  CAMUNDA_CLIENT_SECRET: {
    type: "string",
    secret: true,
    doc: "OAuth client secret (required when CAMUNDA_AUTH_STRATEGY=OAUTH).",
    requiredWhen: { key: "CAMUNDA_AUTH_STRATEGY", equals: "OAUTH" }
  },
  CAMUNDA_OAUTH_URL: {
    type: "string",
    default: "https://login.cloud.camunda.io/oauth/token",
    doc: "OAuth token URL."
  },
  CAMUNDA_OAUTH_GRANT_TYPE: {
    type: "string",
    default: "client_credentials",
    doc: "OAuth grant type."
  },
  CAMUNDA_OAUTH_SCOPE: {
    type: "string",
    doc: "Optional OAuth scope (space-separated)."
  },
  CAMUNDA_OAUTH_TIMEOUT_MS: {
    type: "int",
    default: 5e3,
    doc: "Timeout in ms for OAuth token fetch."
  },
  CAMUNDA_OAUTH_RETRY_MAX: {
    type: "int",
    default: 5,
    doc: "Maximum OAuth token fetch attempts (including initial)."
  },
  CAMUNDA_OAUTH_RETRY_BASE_DELAY_MS: {
    type: "int",
    default: 1e3,
    doc: "Base delay (ms) for first retry (exponential backoff)."
  },
  CAMUNDA_OAUTH_CACHE_DIR: {
    type: "string",
    doc: "Directory for disk caching OAuth tokens (Node only)."
  },
  CAMUNDA_AUTH_STRATEGY: {
    type: "enum",
    choices: ["NONE", "OAUTH", "BASIC"],
    default: "NONE",
    doc: "Authentication strategy."
  },
  CAMUNDA_BASIC_AUTH_USERNAME: {
    type: "string",
    doc: "Basic auth username (required when CAMUNDA_AUTH_STRATEGY=BASIC).",
    requiredWhen: { key: "CAMUNDA_AUTH_STRATEGY", equals: "BASIC" }
  },
  CAMUNDA_BASIC_AUTH_PASSWORD: {
    type: "string",
    secret: true,
    doc: "Basic auth password (required when CAMUNDA_AUTH_STRATEGY=BASIC).",
    requiredWhen: { key: "CAMUNDA_AUTH_STRATEGY", equals: "BASIC" }
  },
  CAMUNDA_SDK_VALIDATION: {
    type: "string",
    default: "req:none,res:none",
    doc: "Validation mini-language controlling req/res modes."
  },
  CAMUNDA_SDK_LOG_LEVEL: {
    type: "enum",
    choices: ["silent", "error", "warn", "info", "debug", "trace", "silly"],
    default: "error",
    doc: 'SDK log level. "silly" adds unsafe deep diagnostics including HTTP request and response bodies.'
  },
  CAMUNDA_SDK_TELEMETRY_LOG: {
    type: "boolean",
    default: false,
    doc: "Emit telemetry (auth/http/retry) events to the SDK logger automatically (no code)."
  },
  CAMUNDA_SDK_TELEMETRY_CORRELATION: {
    type: "boolean",
    default: false,
    doc: "Enable correlation context (withCorrelation helper) when auto telemetry logging is on."
  },
  CAMUNDA_MTLS_CERT_PATH: { type: "string", doc: "Path to client certificate (PEM) for mTLS." },
  CAMUNDA_MTLS_KEY_PATH: { type: "string", doc: "Path to client private key (PEM) for mTLS." },
  CAMUNDA_MTLS_CA_PATH: { type: "string", doc: "Path to CA certificate bundle (PEM) for mTLS." },
  CAMUNDA_MTLS_KEY_PASSPHRASE: {
    type: "string",
    secret: true,
    doc: "Optional passphrase for encrypted private key."
  },
  CAMUNDA_MTLS_CERT: { type: "string", doc: "Inline PEM client certificate." },
  CAMUNDA_MTLS_KEY: { type: "string", secret: true, doc: "Inline PEM client private key." },
  CAMUNDA_MTLS_CA: { type: "string", doc: "Inline PEM CA bundle." },
  CAMUNDA_SDK_EVENTUAL_POLL_DEFAULT_MS: {
    type: "int",
    default: 500,
    doc: "Default poll interval (ms) for eventually consistent endpoint polling."
  },
  CAMUNDA_DEFAULT_TENANT_ID: {
    type: "string",
    default: "<default>",
    doc: "Default tenant id applied to operations when an explicit tenantId is not provided (branded TenantId)."
  },
  // CAMUNDA_SDK_BACKPRESSURE_ENABLED removed in favor of profile LEGACY (observe-only) vs others (active gating)
  CAMUNDA_SDK_BACKPRESSURE_INITIAL_MAX: {
    type: "int",
    default: 16,
    doc: "Initial bootstrap concurrency cap once first backpressure signal occurs."
  },
  CAMUNDA_SDK_BACKPRESSURE_SOFT_FACTOR: {
    type: "int",
    default: 70,
    doc: "Percentage (integer) multiplier applied to permits on soft backpressure event (e.g. 70 => 0.7x)."
  },
  CAMUNDA_SDK_BACKPRESSURE_SEVERE_FACTOR: {
    type: "int",
    default: 50,
    doc: "Percentage multiplier applied when escalating to severe (e.g. 50 => 0.5x)."
  },
  CAMUNDA_SDK_BACKPRESSURE_RECOVERY_INTERVAL_MS: {
    type: "int",
    default: 1e3,
    doc: "Interval in ms between passive recovery checks while healthy hints observed."
  },
  CAMUNDA_SDK_BACKPRESSURE_RECOVERY_STEP: {
    type: "int",
    default: 1,
    doc: "Permits regained per recovery interval until reaching bootstrap cap."
  },
  CAMUNDA_SDK_BACKPRESSURE_DECAY_QUIET_MS: {
    type: "int",
    default: 2e3,
    doc: "Quiet period (ms) without backpressure signals required to downgrade severity."
  },
  CAMUNDA_SDK_BACKPRESSURE_FLOOR: {
    type: "int",
    default: 1,
    doc: "Minimum floor concurrency when degraded."
  },
  CAMUNDA_SDK_BACKPRESSURE_SEVERE_THRESHOLD: {
    type: "int",
    default: 3,
    doc: "Consecutive backpressure events required to enter severe state."
  },
  CAMUNDA_SDK_BACKPRESSURE_PROFILE: {
    type: "enum",
    choices: ["BALANCED", "CONSERVATIVE", "AGGRESSIVE", "LEGACY"],
    default: "BALANCED",
    doc: "Preset profile for backpressure tuning (LEGACY = observe-only, no gating; other profiles enable adaptive global concurrency control)."
  },
  // Support logging (optional diagnostic file emission; Node-only)
  CAMUNDA_SUPPORT_LOG_ENABLED: {
    type: "boolean",
    default: false,
    doc: "Enable creation of a support log file with environment & configuration diagnostics (Node-only)."
  },
  CAMUNDA_SUPPORT_LOG_FILE_PATH: {
    type: "string",
    doc: "Override support log output file path (default: ./camunda-support.log in current working directory)."
  },
  // Backward-compatible alias (boolean) if users set CAMUNDA_SUPPORT_LOGGER=true by mistake
  CAMUNDA_SUPPORT_LOGGER: {
    type: "boolean",
    default: false,
    doc: "Alias for CAMUNDA_SUPPORT_LOG_ENABLED (deprecated)."
  }
};
function isSecret(key) {
  return !!SCHEMA[key].secret;
}
function requiredWhen(key) {
  return SCHEMA[key].requiredWhen;
}
function schemaEntry(key) {
  return SCHEMA[key];
}
function allKeys() {
  return Object.keys(SCHEMA);
}

// src/runtime/unifiedConfiguration.ts
var CamundaConfigurationError = class extends Error {
  errors;
  constructor(errors) {
    const msg = errors.map((e) => `${e.code}${e.key ? `(${e.key})` : ""}: ${e.message}`).join("\n");
    super(msg);
    this.name = "CamundaConfigurationError";
    this.errors = errors;
  }
};
function deepFreeze(o) {
  if (o && typeof o === "object" && !Object.isFrozen(o)) {
    Object.freeze(o);
    for (const k of Object.keys(o)) {
      deepFreeze(o[k]);
    }
  }
  return o;
}
function redactSecret(v) {
  const len = v.length;
  if (len <= 4) return "*".repeat(len);
  const tail = v.slice(-4);
  return "*".repeat(len - 4) + tail;
}
function parseBoolean(raw, key, errors) {
  const v = raw.trim().toLowerCase();
  if (v === "") return void 0;
  if (["true", "yes", "1", "on"].includes(v)) return true;
  if (["false", "no", "0", "off"].includes(v)) return false;
  errors.push({
    code: "CONFIG_INVALID_BOOLEAN" /* CONFIG_INVALID_BOOLEAN */,
    key,
    message: `Invalid boolean value '${raw}'. Expected one of true,false,yes,no,1,0,on,off.`
  });
  return void 0;
}
function parseInteger(raw, key, errors) {
  const v = raw.trim();
  if (v === "") return void 0;
  if (/^[0-9]+$/.test(v)) return parseInt(v, 10);
  errors.push({
    code: "CONFIG_INVALID_INTEGER" /* CONFIG_INVALID_INTEGER */,
    key,
    message: `Invalid integer '${raw}'. Only unsigned base-10 integers allowed.`
  });
  return void 0;
}
function parseValidation(raw, errors) {
  const val = raw.trim();
  if (val === "") return { req: "none", res: "none", raw: "req:none,res:none" };
  const lower = val.toLowerCase();
  if (["none", "warn", "strict", "fanatical"].includes(lower)) {
    return {
      req: lower,
      res: lower,
      raw: `req:${lower},res:${lower}`
    };
  }
  const parts = val.split(",").map((p) => p.trim()).filter(Boolean);
  const seen = {};
  let req = "none";
  let res = "none";
  for (const part of parts) {
    const [lhs, rhs] = part.split(":").map((s) => s?.trim().toLowerCase());
    if (!lhs || !rhs) {
      errors.push({
        code: "CONFIG_INVALID_VALIDATION_SYNTAX" /* CONFIG_INVALID_VALIDATION_SYNTAX */,
        key: "CAMUNDA_SDK_VALIDATION",
        message: `Malformed segment '${part}'`
      });
      continue;
    }
    if (lhs !== "req" && lhs !== "res") {
      errors.push({
        code: "CONFIG_INVALID_VALIDATION_SYNTAX" /* CONFIG_INVALID_VALIDATION_SYNTAX */,
        key: "CAMUNDA_SDK_VALIDATION",
        message: `Unknown scope '${lhs}'`
      });
      continue;
    }
    if (!["none", "warn", "strict", "fanatical"].includes(rhs)) {
      errors.push({
        code: "CONFIG_INVALID_VALIDATION_SYNTAX" /* CONFIG_INVALID_VALIDATION_SYNTAX */,
        key: "CAMUNDA_SDK_VALIDATION",
        message: `Unknown mode '${rhs}'`
      });
      continue;
    }
    if (seen[lhs]) {
      errors.push({
        code: "CONFIG_INVALID_VALIDATION_SYNTAX" /* CONFIG_INVALID_VALIDATION_SYNTAX */,
        key: "CAMUNDA_SDK_VALIDATION",
        message: `Duplicate scope '${lhs}'`
      });
      continue;
    }
    seen[lhs] = true;
    if (lhs === "req") req = rhs;
    else res = rhs;
  }
  return { req, res, raw: `req:${req},res:${res}` };
}
function hydrateConfig(options = {}) {
  const baseEnv = options.env || (typeof process !== "undefined" ? process.env : {});
  const overrides = options.overrides || {};
  const errors = [];
  const warnings = [];
  const provided = {};
  const effective = {};
  const rawMap = {};
  for (const k of allKeys()) {
    if (overrides[k] !== void 0) {
      provided[k] = String(overrides[k]).trim();
    } else if (baseEnv[k] !== void 0 && baseEnv[k].trim() !== "") {
      provided[k] = baseEnv[k].trim();
    }
  }
  const userSetStrategy = provided["CAMUNDA_AUTH_STRATEGY"] !== void 0 && provided["CAMUNDA_AUTH_STRATEGY"].trim() !== "";
  const parseErrors = [];
  function boolParserFactory(key) {
    return (v) => {
      const parsed = parseBoolean(v, key, parseErrors);
      if (parsed === void 0) return void 0;
      return parsed;
    };
  }
  function intParserFactory(key) {
    return (v) => {
      const parsed = parseInteger(v, key, parseErrors);
      if (parsed === void 0) return void 0;
      return parsed;
    };
  }
  function enumParserFactory(key, choices) {
    const lowered = choices.map((c) => c.toLowerCase());
    const allLower = choices.every((c) => c === c.toLowerCase());
    const allUpper = choices.every((c) => c === c.toUpperCase());
    return (v) => {
      const raw = v.trim();
      const candidateLower = raw.toLowerCase();
      const idx = lowered.indexOf(candidateLower);
      if (idx === -1) {
        parseErrors.push({
          code: "CONFIG_INVALID_ENUM" /* CONFIG_INVALID_ENUM */,
          key,
          message: `Invalid value '${v}' (expected one of ${choices.join("|")}).`
        });
        return void 0;
      }
      if (allLower) return lowered[idx];
      if (allUpper) return choices[idx];
      return choices[idx];
    };
  }
  const typedEnvSchema = {};
  for (const k of allKeys()) {
    const entry = schemaEntry(k);
    const baseOpt = { optional: true };
    if (entry.type === "string") {
      typedEnvSchema[k] = entry.default !== void 0 ? { type: "string", default: entry.default, ...baseOpt } : { type: "string", ...baseOpt };
    } else if (entry.type === "boolean") {
      const base = { parser: boolParserFactory(k), ...baseOpt };
      if (entry.default !== void 0) base.default = !!entry.default;
      typedEnvSchema[k] = base;
    } else if (entry.type === "int") {
      const base = { parser: intParserFactory(k), ...baseOpt };
      if (entry.default !== void 0) base.default = entry.default;
      typedEnvSchema[k] = base;
    } else if (entry.type === "enum") {
      const base = { parser: enumParserFactory(k, entry.choices || []), ...baseOpt };
      if (entry.default !== void 0) base.default = entry.default;
      typedEnvSchema[k] = base;
    }
  }
  const envInput = {};
  for (const k of allKeys()) {
    if (overrides[k] !== void 0) envInput[k] = String(overrides[k]);
    else if (baseEnv[k] !== void 0) envInput[k] = baseEnv[k];
  }
  if (envInput["CAMUNDA_SUPPORT_LOG_ENABLED"] === void 0 && envInput["CAMUNDA_SUPPORT_LOGGER"] !== void 0) {
    envInput["CAMUNDA_SUPPORT_LOG_ENABLED"] = envInput["CAMUNDA_SUPPORT_LOGGER"];
  }
  if (envInput["CAMUNDA_REST_ADDRESS"] === void 0 && baseEnv["ZEEBE_REST_ADDRESS"] !== void 0 && baseEnv["ZEEBE_REST_ADDRESS"].trim() !== "") {
    envInput["CAMUNDA_REST_ADDRESS"] = baseEnv["ZEEBE_REST_ADDRESS"].trim();
  }
  if ((envInput["CAMUNDA_AUTH_STRATEGY"] === void 0 || envInput["CAMUNDA_AUTH_STRATEGY"].trim() === "") && envInput["CAMUNDA_OAUTH_URL"] !== void 0 && envInput["CAMUNDA_OAUTH_URL"].trim() !== "" && envInput["CAMUNDA_CLIENT_ID"] !== void 0 && envInput["CAMUNDA_CLIENT_ID"].trim() !== "" && envInput["CAMUNDA_CLIENT_SECRET"] !== void 0 && envInput["CAMUNDA_CLIENT_SECRET"].trim() !== "") {
    envInput["CAMUNDA_AUTH_STRATEGY"] = "OAUTH";
  }
  let envTyped = {};
  envTyped = createEnv(typedEnvSchema, { env: envInput });
  for (const k of allKeys()) {
    const entry = schemaEntry(k);
    const rawProvided = envInput[k];
    const val = envTyped[k];
    if (val !== void 0 && val !== null) {
      rawMap[k] = typeof val === "string" ? val : String(val);
    } else if (rawProvided !== void 0) {
    } else if (entry.default !== void 0) {
      rawMap[k] = String(entry.default);
    }
  }
  if (!userSetStrategy && rawMap["CAMUNDA_AUTH_STRATEGY"] === "NONE" && rawMap["CAMUNDA_OAUTH_URL"] && rawMap["CAMUNDA_OAUTH_URL"].trim() !== "" && rawMap["CAMUNDA_CLIENT_ID"] && rawMap["CAMUNDA_CLIENT_ID"].trim() !== "" && rawMap["CAMUNDA_CLIENT_SECRET"] && rawMap["CAMUNDA_CLIENT_SECRET"].trim() !== "") {
    rawMap["CAMUNDA_AUTH_STRATEGY"] = "OAUTH";
  }
  const authStrategyRaw = (rawMap["CAMUNDA_AUTH_STRATEGY"] || "NONE").toString();
  const authStrategy = authStrategyRaw.trim().toUpperCase();
  if (!["NONE", "OAUTH", "BASIC"].includes(authStrategy)) {
    errors.push({
      code: "CONFIG_INVALID_ENUM" /* CONFIG_INVALID_ENUM */,
      key: "CAMUNDA_AUTH_STRATEGY",
      message: `Invalid auth strategy '${authStrategyRaw}'. Expected NONE|OAUTH|BASIC.`
    });
  }
  const missingByCondition = {};
  for (const k of allKeys()) {
    const req = requiredWhen(k);
    if (req) {
      const condValue = rawMap[req.key]?.trim().toUpperCase();
      if (condValue === req.equals) {
        const origin = (baseEnv[k] ?? overrides[k] ?? "").toString().trim();
        if (origin === "") {
          const list = missingByCondition[req.equals] || (missingByCondition[req.equals] = []);
          list.push(k);
        }
      }
    }
  }
  for (const pe of parseErrors) errors.push(pe);
  for (let i = errors.length - 1; i >= 0; i--) {
    if (!errors[i].key) errors.splice(i, 1);
  }
  for (const cond of Object.keys(missingByCondition)) {
    const keys = Array.from(new Set(missingByCondition[cond])).sort();
    errors.push({
      code: "CONFIG_MISSING_REQUIRED" /* CONFIG_MISSING_REQUIRED */,
      message: `Missing required configuration for ${cond}: ${keys.join(", ")}`,
      details: { strategy: cond, keys }
    });
  }
  const mtlsCertProvided = !!(rawMap["CAMUNDA_MTLS_CERT"] || rawMap["CAMUNDA_MTLS_CERT_PATH"]);
  const mtlsKeyProvided = !!(rawMap["CAMUNDA_MTLS_KEY"] || rawMap["CAMUNDA_MTLS_KEY_PATH"]);
  const mtlsAny = mtlsCertProvided || mtlsKeyProvided || rawMap["CAMUNDA_MTLS_CA"] || rawMap["CAMUNDA_MTLS_CA_PATH"] || rawMap["CAMUNDA_MTLS_KEY_PASSPHRASE"];
  if (mtlsAny && (!mtlsCertProvided || !mtlsKeyProvided)) {
    errors.push({
      code: "CONFIG_MISSING_REQUIRED" /* CONFIG_MISSING_REQUIRED */,
      message: "Incomplete mTLS configuration; both certificate (CAMUNDA_MTLS_CERT|_PATH) and key (CAMUNDA_MTLS_KEY|_PATH) must be provided."
    });
  }
  const validationRaw = rawMap["CAMUNDA_SDK_VALIDATION"] || "req:none,res:none";
  const validation = parseValidation(validationRaw, errors);
  if (errors.length) {
    errors.sort((a, b) => (a.key || "").localeCompare(b.key || "") || a.code.localeCompare(b.code));
    throw new CamundaConfigurationError(errors);
  }
  for (const k of allKeys()) {
    const val = rawMap[k];
    if (val !== void 0) effective[k] = val;
  }
  const redacted = {};
  for (const [k, v] of Object.entries(effective)) {
    if (isSecret(k) && v) redacted[k] = redactSecret(v);
    else redacted[k] = v;
  }
  let _restAddress = rawMap["CAMUNDA_REST_ADDRESS"];
  if (_restAddress) {
    _restAddress = _restAddress.trim();
    if (!/\/v2\/?$/i.test(_restAddress)) {
      _restAddress = _restAddress.replace(/\/+$/, "") + "/v2";
    } else {
    }
  }
  const profile = (rawMap["CAMUNDA_SDK_BACKPRESSURE_PROFILE"] || "BALANCED").toString().toUpperCase();
  const PRESETS = {
    BALANCED: {
      initialMax: 16,
      soft: 70,
      severe: 50,
      recoveryInterval: 1e3,
      recoveryStep: 1,
      quietMs: 2e3,
      floor: 1,
      severeThreshold: 3
    },
    CONSERVATIVE: {
      initialMax: 12,
      soft: 60,
      severe: 40,
      recoveryInterval: 1200,
      recoveryStep: 1,
      quietMs: 2500,
      floor: 1,
      severeThreshold: 2
    },
    AGGRESSIVE: {
      initialMax: 24,
      soft: 80,
      severe: 60,
      recoveryInterval: 800,
      recoveryStep: 2,
      quietMs: 1500,
      floor: 2,
      severeThreshold: 4
    },
    LEGACY: {
      // observe-only: we still need plausible defaults if user overrides individual knobs
      initialMax: 16,
      soft: 70,
      severe: 50,
      recoveryInterval: 1e3,
      recoveryStep: 1,
      quietMs: 2e3,
      floor: 1,
      severeThreshold: 3
    }
  };
  const preset = PRESETS[profile] || PRESETS.BALANCED;
  function ensure(k, val) {
    if (!provided[k]) rawMap[k] = String(val);
  }
  ensure("CAMUNDA_SDK_BACKPRESSURE_INITIAL_MAX", preset.initialMax);
  ensure("CAMUNDA_SDK_BACKPRESSURE_SOFT_FACTOR", preset.soft);
  ensure("CAMUNDA_SDK_BACKPRESSURE_SEVERE_FACTOR", preset.severe);
  ensure("CAMUNDA_SDK_BACKPRESSURE_RECOVERY_INTERVAL_MS", preset.recoveryInterval);
  ensure("CAMUNDA_SDK_BACKPRESSURE_RECOVERY_STEP", preset.recoveryStep);
  ensure("CAMUNDA_SDK_BACKPRESSURE_DECAY_QUIET_MS", preset.quietMs);
  ensure("CAMUNDA_SDK_BACKPRESSURE_FLOOR", preset.floor);
  ensure("CAMUNDA_SDK_BACKPRESSURE_SEVERE_THRESHOLD", preset.severeThreshold);
  const config = {
    restAddress: _restAddress,
    tokenAudience: rawMap["CAMUNDA_TOKEN_AUDIENCE"],
    defaultTenantId: rawMap["CAMUNDA_DEFAULT_TENANT_ID"] || "<default>",
    httpRetry: {
      maxAttempts: parseInt(rawMap["CAMUNDA_SDK_HTTP_RETRY_MAX_ATTEMPTS"] || "3", 10),
      baseDelayMs: parseInt(rawMap["CAMUNDA_SDK_HTTP_RETRY_BASE_DELAY_MS"] || "100", 10),
      maxDelayMs: parseInt(rawMap["CAMUNDA_SDK_HTTP_RETRY_MAX_DELAY_MS"] || "2000", 10)
    },
    backpressure: {
      enabled: profile !== "LEGACY",
      profile,
      observeOnly: profile === "LEGACY",
      initialMax: parseInt(rawMap["CAMUNDA_SDK_BACKPRESSURE_INITIAL_MAX"] || "16", 10),
      softFactor: Math.min(
        1,
        Math.max(
          0.01,
          (parseInt(rawMap["CAMUNDA_SDK_BACKPRESSURE_SOFT_FACTOR"] || "70", 10) || 70) / 100
        )
      ),
      severeFactor: Math.min(
        1,
        Math.max(
          0.01,
          (parseInt(rawMap["CAMUNDA_SDK_BACKPRESSURE_SEVERE_FACTOR"] || "50", 10) || 50) / 100
        )
      ),
      recoveryIntervalMs: parseInt(
        rawMap["CAMUNDA_SDK_BACKPRESSURE_RECOVERY_INTERVAL_MS"] || "1000",
        10
      ),
      recoveryStep: parseInt(rawMap["CAMUNDA_SDK_BACKPRESSURE_RECOVERY_STEP"] || "1", 10),
      decayQuietMs: parseInt(rawMap["CAMUNDA_SDK_BACKPRESSURE_DECAY_QUIET_MS"] || "2000", 10),
      floor: parseInt(rawMap["CAMUNDA_SDK_BACKPRESSURE_FLOOR"] || "1", 10),
      severeThreshold: parseInt(rawMap["CAMUNDA_SDK_BACKPRESSURE_SEVERE_THRESHOLD"] || "3", 10)
    },
    oauth: {
      clientId: rawMap["CAMUNDA_CLIENT_ID"]?.trim() || void 0,
      clientSecret: rawMap["CAMUNDA_CLIENT_SECRET"]?.trim() || void 0,
      oauthUrl: rawMap["CAMUNDA_OAUTH_URL"],
      grantType: rawMap["CAMUNDA_OAUTH_GRANT_TYPE"],
      scope: rawMap["CAMUNDA_OAUTH_SCOPE"]?.trim() || void 0,
      timeoutMs: parseInt(rawMap["CAMUNDA_OAUTH_TIMEOUT_MS"], 10),
      retry: {
        max: parseInt(rawMap["CAMUNDA_OAUTH_RETRY_MAX"], 10),
        baseDelayMs: parseInt(rawMap["CAMUNDA_OAUTH_RETRY_BASE_DELAY_MS"], 10)
      },
      cacheDir: rawMap["CAMUNDA_OAUTH_CACHE_DIR"]?.trim() || void 0
    },
    auth: {
      strategy: authStrategy,
      basic: authStrategy === "BASIC" ? {
        username: rawMap["CAMUNDA_BASIC_AUTH_USERNAME"]?.trim(),
        password: rawMap["CAMUNDA_BASIC_AUTH_PASSWORD"]?.trim()
      } : void 0
    },
    validation: { req: validation.req, res: validation.res, raw: validation.raw },
    logLevel: rawMap["CAMUNDA_SDK_LOG_LEVEL"] || "error",
    eventual: {
      pollDefaultMs: parseInt(rawMap["CAMUNDA_SDK_EVENTUAL_POLL_DEFAULT_MS"] || "500", 10)
    },
    mtls: rawMap["CAMUNDA_MTLS_CERT_PATH"] || rawMap["CAMUNDA_MTLS_KEY_PATH"] || rawMap["CAMUNDA_MTLS_CA_PATH"] || rawMap["CAMUNDA_MTLS_CERT"] || rawMap["CAMUNDA_MTLS_KEY"] || rawMap["CAMUNDA_MTLS_CA"] || rawMap["CAMUNDA_MTLS_KEY_PASSPHRASE"] ? {
      cert: rawMap["CAMUNDA_MTLS_CERT"] || void 0,
      key: rawMap["CAMUNDA_MTLS_KEY"] || void 0,
      ca: rawMap["CAMUNDA_MTLS_CA"] || void 0,
      keyPassphrase: rawMap["CAMUNDA_MTLS_KEY_PASSPHRASE"] || void 0,
      certPath: rawMap["CAMUNDA_MTLS_CERT_PATH"] || void 0,
      keyPath: rawMap["CAMUNDA_MTLS_KEY_PATH"] || void 0,
      caPath: rawMap["CAMUNDA_MTLS_CA_PATH"] || void 0
    } : void 0,
    telemetry: {
      log: (rawMap["CAMUNDA_SDK_TELEMETRY_LOG"] || "false").toString().toLowerCase() === "true",
      correlation: (rawMap["CAMUNDA_SDK_TELEMETRY_CORRELATION"] || "false").toString().toLowerCase() === "true"
    },
    supportLog: {
      enabled: (rawMap["CAMUNDA_SUPPORT_LOG_ENABLED"] || "false").toString().toLowerCase() === "true",
      filePath: rawMap["CAMUNDA_SUPPORT_LOG_FILE_PATH"] || (typeof process !== "undefined" && typeof process.cwd === "function" ? path.join(process.cwd(), "camunda-support.log") : "camunda-support.log")
    },
    __raw: { ...rawMap }
  };
  deepFreeze(config);
  const api = {
    config,
    warnings,
    provided: Object.keys(provided).sort().reduce((acc, k) => {
      acc[k] = provided[k];
      return acc;
    }, {}),
    effective: Object.keys(effective).sort().reduce((acc, k) => {
      acc[k] = effective[k];
      return acc;
    }, {}),
    redacted: Object.keys(redacted).sort().reduce((acc, k) => {
      acc[k] = redacted[k];
      return acc;
    }, {}),
    toProvidedObject() {
      return { ...this.provided };
    },
    toEffectiveObject() {
      return { ...this.effective };
    },
    toRedactedObject() {
      return { ...this.redacted };
    },
    toDisplayString() {
      return Object.entries(this.redacted).map(([k, v]) => `${k}=${v}`).join("\n");
    }
  };
  try {
    globalThis.__CAMUNDA_SDK_LAST_CONFIG = api;
  } catch {
  }
  return api;
}

// src/runtime/eventual.ts
function toCancelable(factory) {
  const ac = new AbortController();
  let rejectFn = () => {
  };
  const p = new Promise((resolve, reject) => {
    rejectFn = reject;
    const r = factory(ac.signal);
    if (r && typeof r.then === "function") {
      r.then(resolve, reject);
    }
  });
  p.cancel = () => {
    ac.abort();
    rejectFn(new Error("Cancelled"));
  };
  return p;
}
function now() {
  return Date.now();
}
function eventualPoll(operationId, isGet, invoke, options) {
  const { waitUpToMs, predicate, onAttempt, onComplete, abortSignal, trace } = options;
  const elog = options.logger?.scope("eventual");
  const pollDefaultMs = hydrateConfig().config.eventual?.pollDefaultMs || 500;
  const userInterval = options.pollIntervalMs;
  const baseInterval = userInterval != null ? userInterval : pollDefaultMs;
  const pollInterval = Math.max(10, baseInterval);
  if (waitUpToMs === 0) {
    const base = invoke();
    if (options.errorMode === "result") {
      return toCancelable((signal) => {
        signal.addEventListener("abort", () => base.cancel?.());
        return base.then((v) => ({ ok: true, value: v })).catch((e) => ({ ok: false, error: e }));
      });
    }
    return base;
  }
  return toCancelable((outerSignal) => {
    let attempts = 0;
    const started = now();
    let cancelled = false;
    const abortImmediateStatuses = /* @__PURE__ */ new Set([400, 401, 403, 409, 422]);
    const externalAbort = () => {
      cancelled = true;
    };
    if (abortSignal) {
      if (abortSignal.aborted) externalAbort();
      else abortSignal.addEventListener("abort", externalAbort);
    }
    const loop = (resolve, reject) => {
      if (cancelled || outerSignal.aborted) return reject(new Error("Cancelled"));
      attempts++;
      let settled = false;
      const settleOk = (val) => {
        if (settled) return;
        settled = true;
        if (options.errorMode === "result") resolve({ ok: true, value: val });
        else resolve(val);
      };
      const settleErr = (err) => {
        if (settled) return;
        settled = true;
        if (options.errorMode === "result")
          resolve({ ok: false, error: err });
        else reject(err);
      };
      const req = invoke();
      req.then(async (res) => {
        if (cancelled || outerSignal.aborted) return settleErr(new Error("Cancelled"));
        if (trace) {
          try {
            const preview = typeof res === "object" ? JSON.stringify(res).slice(0, 1e3) : String(res);
            elog?.debug?.(() => [`op=${operationId} attempt=${attempts} trace body=${preview}`]);
          } catch {
          }
        }
        let ok = true;
        try {
          if (predicate) ok = await predicate(res);
          else if (!isGet && res && typeof res === "object" && Array.isArray(res.items))
            ok = res.items.length > 0;
        } catch (e) {
          return settleErr(e);
        }
        const elapsed = now() - started;
        const remaining = waitUpToMs - elapsed;
        if (ok) {
          onAttempt?.({
            attempt: attempts,
            elapsedMs: elapsed,
            remainingMs: Math.max(0, remaining),
            status: 200,
            predicateResult: ok,
            nextDelayMs: 0
          });
          if (trace) {
            elog?.debug?.(() => [
              `op=${operationId} attempt=${attempts} status=200 predicate=true elapsed=${elapsed}ms totalAttempts=${attempts}`
            ]);
          }
          onComplete?.({ attempts, elapsedMs: elapsed });
          return settleOk(res);
        }
        if (remaining <= 0) {
          return settleErr(
            new EventualConsistencyTimeoutError({
              attempts,
              elapsedMs: elapsed,
              lastStatus: 200,
              lastResponse: res,
              operationId
            })
          );
        }
        const delay = Math.min(pollInterval, remaining);
        onAttempt?.({
          attempt: attempts,
          elapsedMs: elapsed,
          remainingMs: Math.max(0, remaining),
          status: 200,
          predicateResult: ok,
          nextDelayMs: delay
        });
        elog?.debug?.(() => [
          `op=${operationId} attempt=${attempts} status=200 predicate=false nextDelay=${delay}ms remaining=${remaining}`
        ]);
        setTimeout(() => loop(resolve, reject), delay);
      }).catch((err) => {
        if (cancelled || outerSignal.aborted) return settleErr(new Error("Cancelled"));
        const status = err?.status;
        const elapsed = now() - started;
        const remaining = waitUpToMs - elapsed;
        if (status === 404 && isGet && remaining > 0) {
          const delay = Math.min(pollInterval, remaining);
          onAttempt?.({
            attempt: attempts,
            elapsedMs: elapsed,
            remainingMs: Math.max(0, remaining),
            status,
            predicateResult: false,
            nextDelayMs: delay
          });
          return setTimeout(() => loop(resolve, reject), delay);
        }
        if (status === 429 && remaining > 0) {
          let delay = pollInterval * 2;
          const ra = err?.headers?.["retry-after"] || err?.headers?.["Retry-After"] || err?.body?.["retryAfter"] || err?.body?.["Retry-After"];
          if (ra) {
            const parsed = parseInt(ra, 10);
            if (!isNaN(parsed)) delay = parsed < 1e3 ? parsed * 1e3 : parsed;
          }
          delay = Math.min(delay, pollInterval * 5, 2e3, remaining);
          const jitter = 0.9 + Math.random() * 0.2;
          delay = Math.floor(delay * jitter);
          onAttempt?.({
            attempt: attempts,
            elapsedMs: elapsed,
            remainingMs: Math.max(0, remaining),
            status,
            predicateResult: false,
            nextDelayMs: delay
          });
          return setTimeout(() => loop(resolve, reject), delay);
        }
        if (status && (abortImmediateStatuses.has(status) || status >= 500))
          return settleErr(err);
        if (remaining <= 0)
          return settleErr(
            new EventualConsistencyTimeoutError({
              attempts,
              elapsedMs: elapsed,
              lastStatus: status,
              lastResponse: err?.body,
              operationId
            })
          );
        return settleErr(err);
      });
    };
    return new Promise((resolve, reject) => loop(resolve, reject));
  });
}

// src/runtime/installAuthInterceptor.ts
function installAuthInterceptor(client2, getStrategy, getAuthHeaders) {
  client2.interceptors.request.use(async (request) => {
    try {
      if (getStrategy() === "NONE") return request;
      const hdrs = await getAuthHeaders();
      const auth = hdrs?.["Authorization"];
      if (auth && !request.headers.get("Authorization")) {
        const h = new Headers(request.headers);
        h.set("Authorization", auth);
        return new Request(request, { headers: h });
      }
    } catch {
    }
    return request;
  });
}

// src/runtime/version.ts
var packageVersion = "1.2.0";

// src/runtime/supportLogger.ts
var NoopSupportLogger = class {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  log(_message, _addTimestamp = true) {
  }
};
function safeStringifyReplacer(seen) {
  return function(_, value) {
    if (value && typeof value?.toJSON === "function") {
      try {
        value = value.toJSON();
      } catch {
      }
    }
    if (!(value !== null && typeof value === "object")) return value;
    if (seen.has(value)) return "[Circular]";
    seen.add(value);
    const out = Array.isArray(value) ? [] : {};
    for (const [k, v] of Object.entries(value)) {
      out[k] = safeStringifyReplacer(seen)(k, v);
    }
    seen.delete(value);
    return out;
  };
}
function safeStringify(obj, indentation = 2) {
  try {
    return JSON.stringify(obj, safeStringifyReplacer(/* @__PURE__ */ new WeakSet()), indentation);
  } catch (e) {
    return `"[StringifyFailed ${e?.message || "error"}]"`;
  }
}
var SENSITIVE_KEYS = [
  "CAMUNDA_BASIC_AUTH_PASSWORD",
  "CAMUNDA_CLIENT_SECRET",
  "CAMUNDA_MTLS_KEY_PASSPHRASE"
];
function obscureSensitiveInfo(raw) {
  const redacted = {};
  for (const [k, v] of Object.entries(raw)) {
    if (v && SENSITIVE_KEYS.includes(k)) {
      const prefix = v.slice(0, 4);
      const omitted = Math.max(0, v.length - 4);
      redacted[k] = `${prefix}...[${omitted} chars omitted]`;
    } else redacted[k] = v;
  }
  return redacted;
}
var CamundaSupportLogger = class {
  enabled;
  filepath;
  /** marker used by writeSupportLogPreamble to avoid duplicate emission */
  __preambleEmitted = false;
  constructor(config) {
    const enabled = !!config.supportLog?.enabled;
    this.enabled = enabled;
    this.filepath = config.supportLog?.filePath || (typeof process !== "undefined" ? __require("path").join(process.cwd(), "camunda-support.log") : "camunda-support.log");
    if (!this.enabled || !isNode()) return;
    const fs = __require("fs");
    if (fs.existsSync(this.filepath)) {
      let n = 1;
      const base = this.filepath;
      const MAX_SUFFIX = 1e3;
      while (fs.existsSync(this.filepath) && n < MAX_SUFFIX) {
        this.filepath = `${base}-${n++}`;
      }
      if (fs.existsSync(this.filepath)) {
        throw new Error(
          `Unable to find unique support log filename after ${MAX_SUFFIX} attempts. Please clean up old log files or specify a different filePath in supportLog config.`
        );
      }
    }
    writeSupportLogPreamble(this, config);
  }
  log(message, addTimestamp = true) {
    if (!this.enabled || !isNode()) return;
    const fs = __require("fs");
    const msg = typeof message === "object" ? safeStringify(message) : String(message);
    const line = addTimestamp ? `[${(/* @__PURE__ */ new Date()).toISOString()}]: ${msg}
` : `${msg}
`;
    try {
      fs.appendFileSync(this.filepath, line);
    } catch (err) {
      console.error(`Failed to write support log to ${this.filepath}:`, err);
    }
  }
};
function isNode() {
  return typeof process !== "undefined" && !!process.versions?.node;
}
function createSupportLogger(config, injected) {
  if (injected) return injected;
  if (!isNode()) return new NoopSupportLogger();
  if (!config.supportLog?.enabled) return new NoopSupportLogger();
  return new CamundaSupportLogger(config);
}
function writeSupportLogPreamble(logger, config) {
  const anyLogger = logger;
  if (anyLogger.__preambleEmitted) return;
  anyLogger.__preambleEmitted = true;
  try {
    logger.log("********************************************************", false);
    logger.log(
      "Camunda Support Debugging log. Supply this to Camunda Technical Support to assist in troubleshooting issues",
      false
    );
    logger.log("* https://camunda.com/services/camunda-success/", false);
    logger.log("* https://github.com/camunda/orchestration-cluster-api-js/issues", false);
    logger.log(
      "**WARNING**: This log may contain sensitive secrets. Review before sharing publicly.",
      false
    );
    logger.log("********************************************************", false);
    logger.log(
      `CamundaSupportLogger active. Target path: ${config.supportLog?.filePath || "camunda-support.log"}`
    );
    logger.log(`Camunda SDK version: ${packageVersion}`, false);
    try {
      const os = __require("os");
      const osInfo = {
        platform: os.platform(),
        release: os.release(),
        type: os.type(),
        arch: os.arch(),
        version: os.version?.(),
        hostname: os.hostname(),
        totalmem: os.totalmem(),
        freemem: os.freemem(),
        cpus: os.cpus().length,
        uptime: os.uptime()
      };
      logger.log("/** OS Information */\n" + safeStringify(osInfo) + "\n", false);
    } catch {
    }
    const raw = config.__raw || {};
    const obscured = obscureSensitiveInfo(raw);
    logger.log("/** Configuration */\n" + safeStringify(obscured) + "\n", false);
  } catch {
  }
}

// src/runtime/telemetry.ts
function redactUrl(u) {
  try {
    const url = new URL(u);
    if (url.searchParams && Array.from(url.searchParams.keys()).length) {
      const keys = Array.from(new Set(Array.from(url.searchParams.keys())));
      url.search = keys.length ? "?" + keys.map((k) => k).join("&") : "";
    }
    return url.toString();
  } catch {
    return u;
  }
}
var globalRequestCounter = 0;
function wrapFetch(orig, opts) {
  if (!opts || !opts.hooks && !opts.correlation && !opts.mirrorToLog) return orig;
  const hooks = opts.hooks;
  const logger = opts.logger?.scope("telemetry");
  const mirror = !!opts.mirrorToLog && !!logger;
  function mirrorLog(evt) {
    if (!mirror) return;
    const opName = `${evt.method} ${evt.url}`;
    if (evt.type === "http.end") {
      logger.trace(() => [
        `op=${opName} http.end method=${evt.method} status=${evt.status} url=${evt.url} attempt=${evt.attempt} duration=${evt.durationMs}ms requestId=${evt.requestId}`
      ]);
    } else if (evt.type === "http.error") {
      const e = evt;
      logger.trace(() => [
        `op=${opName} http.error method=${e.method} url=${e.url} attempt=${e.attempt} kind=${e.errorKind} msg=${sanitize(e.message)} duration=${e.durationMs}ms requestId=${e.requestId}`
      ]);
    } else if (evt.type === "http.start") {
      logger.trace(() => [
        `op=${opName} http.start method=${evt.method} url=${evt.url} attempt=${evt.attempt} requestId=${evt.requestId}`
      ]);
    }
  }
  function sanitize(msg) {
    if (!msg) return "";
    return msg.replace(/\s+/g, " ").slice(0, 300);
  }
  return async function wrapped(input, init) {
    const attempt = init?.__camundaAttempt || 1;
    let method = "GET";
    if (init?.method) method = init.method;
    else if (typeof Request !== "undefined" && input instanceof Request && input.method)
      method = input.method;
    method = method.toUpperCase();
    let origUrl;
    if (typeof input === "string") origUrl = input;
    else if (typeof URL !== "undefined" && input instanceof URL) origUrl = input.toString();
    else if (typeof Request !== "undefined" && input instanceof Request) origUrl = input.url;
    else origUrl = input?.url || input?.toString?.() || String(input);
    const redactedUrl = redactUrl(origUrl);
    const requestId = "r" + (++globalRequestCounter).toString(36);
    const correlationId = opts.correlation ? opts.correlation() : void 0;
    const start = Date.now();
    let bodyPreview;
    try {
      const lvl = logger?.level?.();
      if (lvl === "silly" && (method === "POST" || method === "PUT" || method === "PATCH")) {
        let body = init?.body;
        if (body === void 0 && typeof Request !== "undefined" && input instanceof Request) {
          try {
            body = await input.clone().text();
          } catch {
            body = void 0;
          }
        }
        if (body !== void 0 && body !== null) {
          if (typeof body === "string") bodyPreview = body;
          else if (body instanceof URLSearchParams) bodyPreview = body.toString();
          else if (typeof FormData !== "undefined" && body instanceof FormData) {
            const entries = [];
            for (const [k, v] of body.entries()) {
              entries.push(`${k}=${typeof v === "string" ? v.slice(0, 200) : "[File]"}`);
            }
            bodyPreview = entries.join("&");
          } else if (body instanceof Blob) {
            bodyPreview = `[Blob size=${body.size}]`;
          } else if (body instanceof ArrayBuffer) {
            bodyPreview = `[ArrayBuffer byteLength=${body.byteLength}]`;
          } else if (body instanceof Uint8Array) {
            bodyPreview = `[Uint8Array length=${body.length}]`;
          } else if (typeof body === "object") {
            try {
              bodyPreview = JSON.stringify(body).slice(0, 4e3);
            } catch {
              bodyPreview = "[Unstringifiable object body]";
            }
          }
          if (bodyPreview && bodyPreview.length > 4e3)
            bodyPreview = bodyPreview.slice(0, 4e3) + "\u2026";
        }
      }
    } catch {
    }
    const startEvt = {
      type: "http.start",
      ts: start,
      method,
      url: redactedUrl,
      attempt,
      requestId,
      correlationId
    };
    try {
      hooks?.beforeRequest?.(startEvt);
      mirrorLog(startEvt);
      if (bodyPreview && logger?.level?.() === "silly") {
        logger.silly(() => [
          `op=${method} ${redactedUrl} http.body requestId=${requestId} size=${bodyPreview.length} preview=${bodyPreview}`
        ]);
      }
    } catch {
    }
    try {
      const res = await orig(input, init);
      const end = Date.now();
      const endEvt = {
        type: "http.end",
        ts: end,
        method,
        url: redactedUrl,
        attempt,
        status: res.status,
        durationMs: end - start,
        requestId,
        correlationId
      };
      try {
        hooks?.afterResponse?.(endEvt);
        mirrorLog(endEvt);
      } catch {
      }
      try {
        if (logger?.level?.() === "silly") {
          let respPreview;
          const cloned = res.clone();
          const ctype = cloned.headers.get("Content-Type") || "";
          let originalSize;
          if (/^(application\/json|text\/)/i.test(ctype)) {
            try {
              const text = await cloned.text();
              originalSize = text.length;
              respPreview = text.slice(0, 4e3);
              if (text.length > 4e3) respPreview += "\u2026";
            } catch {
              respPreview = void 0;
            }
          } else if (/multipart\//i.test(ctype)) {
            respPreview = "[multipart body omitted]";
          } else if (/octet-stream|binary/i.test(ctype)) {
            respPreview = "[binary body omitted]";
          } else {
            try {
              const text = await cloned.text();
              if (text) {
                originalSize = text.length;
                respPreview = text.slice(0, 200);
                if (text.length > 200) respPreview += "\u2026";
              }
            } catch {
            }
          }
          if (respPreview) {
            logger.silly(() => [
              `op=${method} ${redactedUrl} http.response requestId=${requestId} status=${res.status} size=${originalSize} preview=${respPreview}`
            ]);
          }
        }
      } catch {
      }
      try {
        const opName = `${endEvt.method} ${endEvt.url}`;
        opts.supportLogger?.log(
          `op=${opName} http.end method=${endEvt.method} status=${endEvt.status} url=${endEvt.url} attempt=${endEvt.attempt} durationMs=${endEvt.durationMs} requestId=${endEvt.requestId}`
        );
      } catch {
      }
      return res;
    } catch (e) {
      const end = Date.now();
      const errEvt = {
        type: "http.error",
        ts: end,
        method,
        url: redactedUrl,
        attempt,
        errorKind: e?.name === "AbortError" ? "abort" : "network",
        message: e?.message || String(e),
        durationMs: end - start,
        requestId,
        correlationId
      };
      try {
        hooks?.requestError?.(errEvt);
        mirrorLog(errEvt);
      } catch {
      }
      try {
        const opName = `${errEvt.method} ${errEvt.url}`;
        opts.supportLogger?.log(
          `op=${opName} http.error method=${errEvt.method} url=${errEvt.url} attempt=${errEvt.attempt} kind=${errEvt.errorKind} msg=${sanitize(errEvt.message)} durationMs=${errEvt.durationMs} requestId=${errEvt.requestId}`
        );
      } catch {
      }
      throw e;
    }
  };
}
var store = {};
function getCorrelation() {
  return store.current;
}
async function withCorrelation(id, fn) {
  const prev = store.current;
  store.current = id;
  try {
    return await fn();
  } finally {
    store.current = prev;
  }
}

// src/runtime/validationCore.ts
import { ZodError as ZodError2 } from "zod";

// src/runtime/formatValidation.ts
import { ZodObject } from "zod";
function identity(v) {
  return v;
}
function describeObjectShape(obj) {
  const shapeObj = obj.shape;
  const required = [];
  const optional = [];
  for (const k of Object.keys(shapeObj)) {
    const { optional: isOpt } = unwrapAndDetectOptional(shapeObj[k]);
    (isOpt ? optional : required).push(k);
  }
  return { required: required.sort(), optional: optional.sort() };
}
function unwrapAndDetectOptional(s) {
  let cur = s;
  let optional = false;
  const seen = /* @__PURE__ */ new Set();
  while (cur && !seen.has(cur)) {
    seen.add(cur);
    const t = cur?._def?.typeName;
    if (t === "ZodOptional") {
      optional = true;
      cur = cur._def.innerType;
      continue;
    }
    if (t === "ZodDefault") {
      optional = true;
      cur = cur._def.innerType;
      continue;
    }
    if (t === "ZodNullable") {
      cur = cur._def.innerType;
      continue;
    }
    if (t === "ZodBranded") {
      cur = cur._def.type;
      continue;
    }
    if (t === "ZodEffects") {
      cur = cur._def.schema;
      continue;
    }
    if (t === "ZodLazy") {
      try {
        cur = cur._def.getter();
        continue;
      } catch {
        break;
      }
    }
    if (t === "ZodIntersection") {
      cur = cur._def.left;
      continue;
    }
    break;
  }
  return { schema: cur, optional };
}
function unwrapForInspection(s) {
  let cur = s;
  const seen = /* @__PURE__ */ new Set();
  while (cur && !seen.has(cur)) {
    seen.add(cur);
    const t = cur?._def?.typeName;
    if (t === "ZodLazy") {
      try {
        cur = cur._def.getter();
        continue;
      } catch {
        break;
      }
    }
    if (t === "ZodEffects") {
      cur = cur._def.schema || cur;
      continue;
    }
    if (t === "ZodBranded") {
      cur = cur._def.type || cur;
      continue;
    }
    if (t === "ZodIntersection") {
      const left2 = cur._def.left;
      const right2 = cur._def.right;
      if (left2?._def?.typeName === "ZodObject" && right2?._def?.typeName === "ZodObject") {
        try {
          const leftShapeFn = left2._def.shape;
          const rightShapeFn = right2._def.shape;
          const merged = { ...leftShapeFn(), ...rightShapeFn() };
          return ZodObject.create(merged);
        } catch {
        }
      }
      cur = left2;
      continue;
    }
    break;
  }
  return cur;
}
function formatUnion(schema) {
  if (!(schema?._def?.typeName === "ZodUnion")) return void 0;
  const u = schema;
  const variants = u._def.options;
  const requiredSets = [];
  const variantLines = variants.map((v, i) => {
    const resolved = unwrapForInspection(v);
    const label = v.description || resolved.description || `Variant ${i + 1}`;
    if (resolved?._def?.typeName === "ZodObject") {
      const { required, optional } = describeObjectShape(resolved);
      requiredSets.push(required.slice());
      let line = `${label}: required { ${required.join(", ") || "(none)"} } optional { ${optional.slice(0, 6).join(", ")}${optional.length > 6 ? "\u2026" : ""} }`;
      const example = {};
      required.forEach((k) => example[k] = "<value>");
      line += ` example ${JSON.stringify(example)}`;
      return line;
    }
    requiredSets.push([]);
    return `${label}: ${resolved?._def?.typeName || "unknown"} schema`;
  });
  const lines = [];
  if (variants.length > 1) {
    const signatures = requiredSets.map((s) => s.length ? s.join("+") : "(none)").join(" | ");
    lines.push(`Exactly one of the variant required-key sets must match: ${signatures}`);
  }
  lines.push(...variantLines);
  return { lines, variantCount: variants.length };
}
function formatValidationError(params) {
  const { side, operationId, schemaName, schema, value, error } = params;
  const prefix = `Invalid ${operationId ? operationId + " " : ""}${side}`.trim();
  const providedKeys = value && typeof value === "object" && !Array.isArray(value) ? Object.keys(value) : [];
  let union;
  const firstIssue = error.issues[0];
  if (firstIssue?.code === "invalid_union") {
    union = formatUnion(schema);
  }
  const allIssueLines = error.issues.map(formatIssue);
  const issueLines = identity(allIssueLines);
  const summaryParts = [
    union ? `${union.variantCount} variant(s) defined; none matched.` : void 0,
    providedKeys.length ? `provided keys: { ${providedKeys.join(", ")} }` : void 0
  ].filter(Boolean);
  const summary = summaryParts.join(" ");
  const message = `${prefix}${schemaName ? " (" + schemaName + ")" : ""}: ${union ? "no union variant matched" : "validation failed"}`;
  const issues = [...union?.lines || [], ...issueLines];
  return { message, summary, issues };
}
function formatIssue(issue) {
  const i = issue;
  const p = i.path?.length ? i.path.join(".") : "(root)";
  switch (i.code) {
    case "invalid_type":
      return `${p}: expected ${i.expected} got ${i.received}`;
    case "invalid_literal":
      return `${p}: expected literal ${JSON.stringify(i.expected)}`;
    case "invalid_union":
      return `${p}: union mismatch`;
    case "too_small":
    case "too_big":
      return `${p}: ${i.message}`;
    case "unrecognized_keys":
      return `${p}: unrecognized keys ${i.keys.join(", ")}`;
    case "invalid_enum_value":
      return `${p}: expected one of ${i.options.join(", ")}`;
    default:
      return `${p}: ${i.message}`;
  }
}
function logFormattedValidation(kind, formatted, logger) {
  const vLogger = logger.scope("validation");
  if (kind === "warn") {
    vLogger.warn(
      () => `${formatted.message}
  ${formatted.summary}
  Issues:
   - ${formatted.issues.join("\n   - ")}`
    );
    return;
  }
  vLogger.error(() => `${formatted.message}
  ${formatted.summary}`);
  const err = new Error(formatted.message);
  err.issues = formatted.issues;
  throw err;
}

// src/runtime/validationCore.ts
async function applySchemaValidation(opts) {
  const { side, operationId, mode, schema, value, logger } = opts;
  if (mode === "none" || !schema) return value;
  try {
    const parsed = schema.parseAsync ? await schema.parseAsync(value) : schema.parse(value);
    return mode === "warn" ? value : parsed;
  } catch (err) {
    if (err instanceof ZodError2) {
      const formatted = formatValidationError({ side, operationId, schema, value, error: err });
      if (mode === "warn") {
        if (logger) logFormattedValidation("warn", formatted, logger);
        return value;
      }
      if (logger) logFormattedValidation("throw", formatted, logger);
      throw new CamundaValidationError({
        side,
        operationId,
        message: formatted.message,
        summary: formatted.summary,
        issues: formatted.issues
      });
    }
    throw err;
  }
}

// src/runtime/validationExtras.ts
import { ZodObject as ZodObject2 } from "zod";
var seenCaptures = /* @__PURE__ */ new Set();
function hash(str) {
  let h = 0, i = 0;
  const len = str.length;
  while (i < len) h = Math.imul(31, h) + str.charCodeAt(i++) | 0;
  return (h >>> 0).toString(16);
}
function detectExtrasAndMaybeThrow(opts) {
  const { value, schema, settings, fanatical, operationId, logger } = opts;
  if (!value || typeof value !== "object") return;
  if (!schema || !(schema instanceof ZodObject2)) return;
  const extras = {};
  const visit = (val, sch, path2) => {
    if (!val || typeof val !== "object") return;
    if (sch instanceof ZodObject2) {
      const shape = sch.shape;
      const expected = new Set(Object.keys(shape));
      const keys = Object.keys(val);
      const unknown = keys.filter((k) => !expected.has(k));
      if (unknown.length) {
        extras[path2 || "/"] = unknown;
      }
      if (settings.deep) {
        for (const k of keys) {
          if (expected.has(k)) {
            visit(val[k], shape[k], path2 ? `${path2}.${k}` : k);
          }
        }
      }
    }
  };
  visit(value, schema, "");
  const entries = Object.entries(extras);
  if (!entries.length) return;
  const flatIssues = [];
  for (const [p, keys] of entries) {
    flatIssues.push(`${p || "/"}: ${keys.join(", ")}`);
  }
  const summary = `Unknown properties in response: ${flatIssues.join("; ")}`;
  if (settings.policy === "warn" || fanatical && settings.policy !== "error") {
    logger?.warn("validation.extra", summary);
  }
  if (settings.captureDir) {
    try {
      const fs = __require("fs");
      const pathMod = __require("path");
      if (!fs.existsSync(settings.captureDir))
        fs.mkdirSync(settings.captureDir, { recursive: true, mode: 448 });
      const sig = operationId + "|" + flatIssues.sort().join("|");
      const h = hash(sig);
      if (!seenCaptures.has(h)) {
        seenCaptures.add(h);
        const file = pathMod.join(settings.captureDir, `${operationId}-${Date.now()}-${h}.json`);
        const payload = {
          operationId,
          extras,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          sample: value
        };
        fs.writeFileSync(file, JSON.stringify(payload, null, 2), { mode: 384 });
        logger?.debug?.("validation.capture", file);
      }
    } catch {
    }
  }
  if (fanatical || settings.policy === "error") {
    throw new CamundaValidationError({
      side: "response",
      operationId,
      message: summary,
      summary,
      issues: flatIssues
    });
  }
}

// src/runtime/validationManager.ts
var ValidationManager = class {
  constructor(settings, _logger) {
    this._logger = _logger;
    this._settings = { ...settings };
  }
  _settings;
  update(settings) {
    this._settings = { ...settings };
  }
  attachLogger(logger) {
    this._logger = logger;
  }
  get settings() {
    return this._settings;
  }
  requestMode() {
    return this._settings.req;
  }
  responseMode() {
    return this._settings.res;
  }
  async gateRequest(opId, schema, data) {
    return this._gate("request", opId, this._settings.req, schema, data);
  }
  async gateResponse(opId, schema, data) {
    return this._gate("response", opId, this._settings.res, schema, data);
  }
  async _gate(side, opId, mode, schema, value) {
    const effectiveMode = mode === "fanatical" ? "strict" : mode;
    const validated = await applySchemaValidation({
      side,
      operationId: opId,
      mode: effectiveMode,
      schema,
      value,
      logger: this._logger
    });
    if (side === "response" && mode === "fanatical") {
      this._logger?.debug?.("validation.fanatical.extras", { operationId: opId });
      detectExtrasAndMaybeThrow({
        operationId: opId,
        value,
        schema,
        settings: {
          // Hard-coded fanatical semantics
          policy: "error",
          deep: true,
          captureDir: typeof process !== "undefined" && process?.env?.CAMUNDA_SDK_VALIDATION_CAPTURE_DIR || ".camunda-sdk-captures"
        },
        logger: this._logger,
        fanatical: true
      });
    }
    return validated;
  }
};

// src/runtime/retry.ts
async function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}
function createRetryExecutor(opts) {
  const rand = opts.random || Math.random;
  return async function execute(op, classify) {
    const { maxAttempts, baseDelayMs, maxDelayMs } = opts.policy;
    let attempt = 0;
    let lastErr;
    while (attempt < maxAttempts) {
      attempt++;
      try {
        return await op();
      } catch (e) {
        lastErr = e;
        if (attempt >= maxAttempts) break;
        const decision = classify ? classify(e) : defaultHttpClassifier(e);
        if (!decision.retryable) break;
        const exp = baseDelayMs * 2 ** (attempt - 1);
        const cap = Math.min(exp, maxDelayMs);
        const delay = Math.floor(rand() * cap);
        try {
          opts.onAttempt?.({ attempt, nextDelayMs: delay, reason: decision.reason });
          opts.logger?.trace(() => [
            "http.retry.scheduled",
            { attempt: attempt + 1, max: maxAttempts, delayMs: delay, reason: decision.reason }
          ]);
        } catch {
        }
        await sleep(delay);
      }
    }
    throw lastErr;
  };
}
function defaultHttpClassifier(err) {
  if (err) {
    if (err.nonRetryable) {
      const status2 = err.status || err.response?.status;
      const title2 = err.title || err.response?.data?.title;
      const detail2 = err.detail || err.response?.data?.detail;
      if (status2 === 500 && (typeof title2 === "string" && /RESOURCE_EXHAUSTED/.test(title2) || typeof detail2 === "string" && /RESOURCE_EXHAUSTED/.test(detail2))) {
        return { retryable: true, reason: "backpressure-500-title" };
      }
      return { retryable: false, reason: "explicit-non-retryable" };
    }
    const msg = (err.message || "").toLowerCase();
    if (err.name === "TypeError" && (msg.includes("fetch") || msg.includes("network"))) {
      return { retryable: true, reason: "network-error" };
    }
    const status = err.status || err.response?.status;
    if (status === 429) return { retryable: true, reason: "http-429" };
    const title = err.title || err.response?.data?.title;
    const detail = err.detail || err.response?.data?.detail;
    if (status === 503) {
      if (title === "RESOURCE_EXHAUSTED") return { retryable: true, reason: "backpressure-503" };
      return { retryable: false, reason: "http-503-non-backpressure" };
    }
    if (status === 500) {
      if (typeof detail === "string" && /RESOURCE_EXHAUSTED/.test(detail) || typeof title === "string" && /RESOURCE_EXHAUSTED/.test(title)) {
        return { retryable: true, reason: "backpressure-500-detail" };
      }
      return { retryable: false, reason: "http-500" };
    }
  }
  return { retryable: false, reason: "non-retryable" };
}
async function executeWithHttpRetry(fn, policy, logger, classify = defaultHttpClassifier, onAttempt) {
  const exec = createRetryExecutor({ policy, logger, onAttempt });
  return exec(fn, classify);
}

// src/runtime/backpressure.ts
var BackpressureManager = class {
  logger;
  now;
  cfg;
  severity = "healthy";
  consecutive = 0;
  lastEventAt = 0;
  permitsCurrent = 0;
  permitsMax;
  // null => unlimited
  waiters = [];
  lastRecoverCheck = 0;
  observeOnly = false;
  constructor(opts = {}) {
    this.logger = opts.logger;
    this.now = opts.now || (() => Date.now());
    this.cfg = {
      enabled: true,
      initialMaxConcurrency: null,
      floorConcurrency: 1,
      reduceFactor: 0.7,
      severeReduceFactor: 0.5,
      recoveryIntervalMs: 1e3,
      recoveryStep: 1,
      severeThreshold: 3,
      decayQuietMs: 2e3,
      ...opts.config
    };
    this.observeOnly = !!this.cfg.observeOnly;
    this.permitsMax = this.cfg.enabled === false || this.observeOnly ? null : this.cfg.initialMaxConcurrency;
  }
  isEnabled() {
    return this.cfg.enabled !== false && !this.observeOnly;
  }
  getState() {
    return {
      severity: this.severity,
      consecutive: this.consecutive,
      // When disabled, report unlimited semantics explicitly
      permitsMax: this.cfg.enabled === false ? null : this.permitsMax,
      permitsCurrent: this.cfg.enabled === false ? 0 : this.permitsCurrent,
      waiters: this.waiters.length
    };
  }
  log(evt, data, prevSeverity) {
    this.logger?.trace?.(() => ["backpressure." + evt, data]);
    if (evt === "severity") {
      const curr = data.severity;
      const enteringUnhealthy = prevSeverity === "healthy" && curr !== "healthy";
      const recoveringHealthy = prevSeverity !== "healthy" && curr === "healthy";
      const level = enteringUnhealthy || recoveringHealthy ? "info" : "debug";
      this.logger?.[level]?.(() => [
        "bp.state.change",
        { event: evt, from: prevSeverity, to: curr }
      ]);
    } else if (evt.startsWith("permits.")) {
      this.logger?.debug?.(() => ["bp.state.change", { event: evt, ...data }]);
    }
  }
  async acquire(signal) {
    if (this.observeOnly) return;
    if (!this.isEnabled()) return;
    if (this.permitsMax === null) return;
    if (this.permitsCurrent < (this.permitsMax || 0)) {
      this.permitsCurrent++;
      return;
    }
    return new Promise((resolve, reject) => {
      const waiter = { resolve: () => resolve(), reject, signal };
      if (signal) {
        if (signal.aborted) {
          reject(signal.reason || new Error("aborted"));
          return;
        }
        const onAbort = () => {
          this.waiters = this.waiters.filter((w) => w !== waiter);
          reject(signal.reason || new Error("aborted"));
        };
        signal.addEventListener("abort", onAbort, { once: true });
      }
      this.waiters.push(waiter);
    });
  }
  release() {
    if (!this.isEnabled()) return;
    if (this.permitsMax === null) return;
    if (this.permitsCurrent > 0) this.permitsCurrent--;
    while (this.waiters.length && this.permitsCurrent < (this.permitsMax || 0)) {
      const next = this.waiters.shift();
      if (!next) break;
      this.permitsCurrent++;
      try {
        next.resolve();
      } catch {
      }
    }
  }
  recordBackpressure() {
    if (!this.cfg.enabled && !this.observeOnly) return;
    const now2 = this.now();
    this.lastEventAt = now2;
    this.consecutive++;
    if (!this.observeOnly) {
      if (this.permitsMax === null) {
        this.permitsMax = 16;
        this.permitsCurrent = Math.min(this.permitsCurrent, this.permitsMax);
      }
    }
    const prevSeverity = this.severity;
    if (this.consecutive >= this.cfg.severeThreshold) {
      this.severity = "severe";
      if (!this.observeOnly) this.scalePermits(this.cfg.severeReduceFactor);
    } else if (this.severity === "healthy") {
      this.severity = "soft";
      if (!this.observeOnly) this.scalePermits(this.cfg.reduceFactor);
    } else if (this.severity === "soft") {
      if (!this.observeOnly) this.scalePermits(this.cfg.reduceFactor);
    }
    if (this.severity !== prevSeverity)
      this.log("severity", { severity: this.severity }, prevSeverity);
  }
  recordHealthyHint() {
    if (!this.cfg.enabled && !this.observeOnly) return;
    const now2 = this.now();
    this.maybeRecover(now2);
  }
  scalePermits(factor) {
    if (this.permitsMax === null) return;
    const next = Math.max(this.cfg.floorConcurrency, Math.ceil(this.permitsMax * factor));
    if (next < this.permitsMax) {
      this.permitsMax = next;
      this.log("permits.scale", { max: this.permitsMax });
    }
  }
  maybeRecover(now2 = this.now()) {
    if (this.permitsMax === null || this.observeOnly) return;
    if (now2 - this.lastRecoverCheck < this.cfg.recoveryIntervalMs) return;
    this.lastRecoverCheck = now2;
    if (now2 - this.lastEventAt > this.cfg.decayQuietMs) {
      const prev = this.severity;
      if (this.severity === "severe") this.severity = "soft";
      else if (this.severity === "soft") this.severity = "healthy";
      if (this.severity === "healthy") this.consecutive = 0;
      if (prev !== this.severity) this.log("severity", { severity: this.severity }, prev);
    }
    if (this.permitsMax !== null) {
      const bootstrapCap = this.cfg.initialMaxConcurrency ?? 16;
      if (this.permitsMax < bootstrapCap) {
        this.permitsMax = Math.min(bootstrapCap, this.permitsMax + this.cfg.recoveryStep);
        this.log("permits.recover", { max: this.permitsMax }, this.severity);
        this.release();
      }
    }
  }
};

// src/runtime/jobActions.ts
function enrichActivatedJob(raw, client2, log) {
  let acknowledged = false;
  const ack = () => {
    if (!acknowledged) {
      acknowledged = true;
      job.acknowledged = true;
    }
  };
  const job = { ...raw, log };
  job.complete = async (variables = {}) => {
    try {
      await client2.completeJob({ variables, jobKey: raw.jobKey });
    } finally {
      ack();
    }
    return JobActionReceipt;
  };
  job.fail = async (reason) => {
    try {
      await client2.failJob({ ...reason, jobKey: raw.jobKey });
    } finally {
      ack();
    }
    return JobActionReceipt;
  };
  job.cancelWorkflow = async () => {
    try {
      await client2.cancelProcessInstance({
        processInstanceKey: raw.processInstanceKey
      });
    } finally {
      ack();
    }
    return JobActionReceipt;
  };
  job.ignore = async () => {
    ack();
    return JobActionReceipt;
  };
  job.modifyJobTimeout = ({ newTimeoutMs }) => client2.updateJob({ changeset: { timeout: newTimeoutMs }, jobKey: raw.jobKey });
  job.modifyRetries = ({ retries }) => client2.updateJob({ changeset: { retries }, jobKey: raw.jobKey });
  return job;
}

// src/runtime/responseEvaluation.ts
function evaluateSdkResponse(raw, opts) {
  if (!raw || typeof raw !== "object") return raw;
  const status = raw.status || raw.response?.status || raw.error?.status;
  if (!status) {
    return raw.data !== void 0 ? raw.data : raw;
  }
  const isCandidate = status === 429 || status === 503 || status === 500;
  if (isCandidate) {
    const err = opts.buildBackpressureError?.(raw);
    if (err) throw err;
  } else if (status >= 400) {
    const prob = raw.error && typeof raw.error === "object" ? raw.error : raw;
    const msg = prob.title || prob.detail || prob.message || `HTTP ${status}`;
    const err = new Error(msg);
    err.name = "HttpSdkError";
    err.status = status;
    err.operationId = opts.opId;
    for (const k of ["type", "title", "detail", "instance"])
      if (prob[k] !== void 0) err[k] = prob[k];
    err.nonRetryable = true;
    throw err;
  }
  return raw.data !== void 0 ? raw.data : raw;
}

// src/gen/CamundaClient.ts
function deepFreeze2(obj) {
  if (obj && typeof obj === "object" && !Object.isFrozen(obj)) {
    Object.freeze(obj);
    for (const v of Object.values(obj)) {
      if (v && typeof v === "object") deepFreeze2(v);
    }
  }
  return obj;
}
function toCancelable2(factory) {
  const ac = new AbortController();
  let settled = false;
  let rejectRef = () => {
  };
  const p = new Promise((resolve, reject) => {
    rejectRef = reject;
    factory(ac.signal).then((v) => {
      settled = true;
      resolve(v);
    }).catch((e) => {
      if (ac.signal.aborted && (e?.name === "AbortError" || /abort|cancel/i.test(e?.message || ""))) {
        const c = new Error("Cancelled");
        c.name = "CancelSdkError";
        return reject(c);
      }
      reject(e);
    });
  });
  p.cancel = () => {
    if (ac.signal.aborted) return;
    ac.abort();
    if (!settled) {
      const c = new Error("Cancelled");
      c.name = "CancelSdkError";
      rejectRef(c);
    }
  };
  return p;
}
function createCamundaClient(options) {
  return new CamundaClient(options);
}
var CamundaClient = class {
  _client;
  _config;
  _auth = createAuthFacade({
    restAddress: "",
    auth: { strategy: "NONE", basic: { username: "", password: "" } },
    validation: { req: "none", res: "none", raw: "req:none,res:none" },
    oauth: { oauthUrl: "", timeoutMs: 0, retry: { max: 0, baseDelayMs: 0 } },
    tokenAudience: ""
  });
  _fetch;
  _validation = new ValidationManager({ req: "none", res: "none" });
  _log = createLogger();
  _bp;
  /** Registered job workers created via createJobWorker (lifecycle managed by user). */
  _workers = [];
  /** Support logger (Node-only; no-op in browser). */
  _supportLogger = new class {
    log() {
    }
  }();
  // Internal fixed error mode for eventual consistency ('throw' | 'result'). Not user mutable after construction.
  _errorMode;
  _overrides = {};
  constructor(opts = {}) {
    if (opts.config) this._overrides = { ...opts.config };
    const { config } = hydrateConfig({ overrides: this._overrides, env: opts.env });
    this._config = deepFreeze2(config);
    this._log = createLogger({
      level: opts.log?.level || this._config.logLevel,
      transport: opts.log?.transport
    });
    const baseFetch = opts.fetch;
    this._fetch = baseFetch;
    if (opts.telemetry) {
      this._fetch = wrapFetch(this._fetch || fetch, {
        hooks: opts.telemetry.hooks,
        correlation: opts.telemetry.correlation ? () => getCorrelation() : void 0,
        logger: this._log,
        supportLogger: this._supportLogger,
        mirrorToLog: opts.telemetry.mirrorToLog
      });
    } else if (this._config.telemetry?.log) {
      this._fetch = wrapFetch(this._fetch || fetch, {
        hooks: void 0,
        correlation: this._config.telemetry.correlation ? () => getCorrelation() : void 0,
        logger: this._log,
        supportLogger: this._supportLogger,
        mirrorToLog: true
      });
    } else if (
      // Auto-enable mirror telemetry when trace level and user did not explicitly set CAMUNDA_SDK_TELEMETRY_LOG to a disabling value.
      /^(trace|silly)$/.test(this._log.level()) && !this._config.telemetry?.log && // No explicit override provided
      this._overrides["CAMUNDA_SDK_TELEMETRY_LOG"] === void 0 && // And env var either absent or truthy enabling value
      (typeof process === "undefined" || process.env["CAMUNDA_SDK_TELEMETRY_LOG"] === void 0 || /^(1|true|yes|on)$/i.test(process.env["CAMUNDA_SDK_TELEMETRY_LOG"] || ""))
    ) {
      this._fetch = wrapFetch(this._fetch || fetch, {
        hooks: void 0,
        correlation: this._config.telemetry?.correlation ? () => getCorrelation() : void 0,
        logger: this._log,
        supportLogger: this._supportLogger,
        mirrorToLog: true
      });
    }
    this._client = createClient({
      baseUrl: this._config.restAddress,
      fetch: this._fetch,
      throwOnError: opts.throwOnError !== false
    });
    if (this._log.level() === "silly") {
      this._log.warn(
        "log.level.silly.enabled",
        "HTTP request and response bodies will be logged; this may leak sensitive information. Use only for local debugging."
      );
    }
    installAuthInterceptor(
      this._client,
      () => this._config.auth.strategy,
      () => this._auth.getAuthHeaders()
    );
    this._auth = createAuthFacade(this._config, {
      fetch: this._fetch,
      logger: this._log,
      telemetryHooks: opts.telemetry?.hooks,
      correlationProvider: opts.telemetry?.correlation || !opts.telemetry && this._config.telemetry?.correlation ? () => getCorrelation() : void 0
    });
    this._validation.update(this._config.validation);
    this._validation.attachLogger(this._log);
    this._errorMode = opts.errorMode === "result" ? "result" : "throw";
    this._supportLogger = createSupportLogger(this._config, opts.supportLogger);
    try {
      this._supportLogger.log("CamundaClient constructed");
    } catch {
    }
    this.emitSupportLogPreamble();
    this._bp = new BackpressureManager({
      logger: this._log.scope("bp"),
      config: {
        enabled: this._config.backpressure.enabled,
        observeOnly: this._config.backpressure.observeOnly,
        // In observe-only or disabled modes we keep permitsMax null.
        initialMaxConcurrency: this._config.backpressure.enabled && !this._config.backpressure.observeOnly ? this._config.backpressure.initialMax || null : null,
        reduceFactor: this._config.backpressure.softFactor,
        severeReduceFactor: this._config.backpressure.severeFactor,
        recoveryIntervalMs: this._config.backpressure.recoveryIntervalMs,
        recoveryStep: this._config.backpressure.recoveryStep,
        decayQuietMs: this._config.backpressure.decayQuietMs,
        floorConcurrency: this._config.backpressure.floor,
        severeThreshold: this._config.backpressure.severeThreshold
      }
    });
    this._log.debug(() => {
      try {
        const last = globalThis.__CAMUNDA_SDK_LAST_CONFIG;
        const redacted = last?.toRedactedObject ? last.toRedactedObject() : void 0;
        return redacted ? ["config.hydrated", { config: redacted }] : ["config.hydrated"];
      } catch {
        return ["config.hydrated"];
      }
    });
  }
  get config() {
    return this._config;
  }
  /**
   * Read-only snapshot of current hydrated configuration (do not mutate directly).
   * Use configure(...) to apply changes.
   */
  getConfig() {
    return this._config;
  }
  // Merge new overrides and re-hydrate.
  configure(next) {
    if (next.config) this._overrides = { ...this._overrides, ...next.config };
    if (next.fetch) this._fetch = next.fetch;
    const { config } = hydrateConfig({ overrides: this._overrides, env: next.env });
    this._config = deepFreeze2(config);
    if (next.telemetry) {
      this._fetch = wrapFetch(this._fetch || fetch, {
        hooks: next.telemetry.hooks,
        correlation: next.telemetry.correlation ? () => getCorrelation() : void 0,
        logger: this._log,
        supportLogger: this._supportLogger,
        mirrorToLog: next.telemetry.mirrorToLog
      });
    } else if (this._config.telemetry?.log) {
      this._fetch = wrapFetch(this._fetch || fetch, {
        hooks: void 0,
        correlation: this._config.telemetry.correlation ? () => getCorrelation() : void 0,
        logger: this._log,
        supportLogger: this._supportLogger,
        mirrorToLog: true
      });
    } else if (/^(trace|silly)$/.test(this._log.level()) && !this._config.telemetry?.log && this._overrides["CAMUNDA_SDK_TELEMETRY_LOG"] === void 0 && (typeof process === "undefined" || process.env["CAMUNDA_SDK_TELEMETRY_LOG"] === void 0 || /^(1|true|yes|on)$/i.test(process.env["CAMUNDA_SDK_TELEMETRY_LOG"] || ""))) {
      this._fetch = wrapFetch(this._fetch || fetch, {
        hooks: void 0,
        correlation: this._config.telemetry?.correlation ? () => getCorrelation() : void 0,
        logger: this._log,
        supportLogger: this._supportLogger,
        mirrorToLog: true
      });
    }
    this._client = createClient({
      baseUrl: this._config.restAddress,
      fetch: this._fetch,
      throwOnError: next.throwOnError !== false
    });
    installAuthInterceptor(
      this._client,
      () => this._config.auth.strategy,
      () => this._auth.getAuthHeaders()
    );
    if (next.log?.level) this._log.setLevel(next.log.level);
    else this._log.setLevel(this._config.logLevel);
    if (next.log?.transport !== void 0) this._log.setTransport(next.log.transport);
    this._auth = createAuthFacade(this._config, {
      fetch: this._fetch,
      logger: this._log,
      telemetryHooks: next.telemetry?.hooks,
      correlationProvider: next.telemetry?.correlation || !next.telemetry && this._config.telemetry?.correlation ? () => getCorrelation() : void 0
    });
    this._validation.update(this._config.validation);
    this._validation.attachLogger(this._log);
    if (!next.supportLogger && !("supportLogger" in next)) {
      const shouldEnable = this._config.supportLog?.enabled;
      const previouslyEnabled = this._supportLogger.enabled === true;
      if (shouldEnable && !previouslyEnabled) {
        this._supportLogger = createSupportLogger(this._config);
        this._supportLogger.log("Support logger enabled via reconfigure");
      }
    } else if (next.supportLogger) {
      this._supportLogger = next.supportLogger;
      this._supportLogger.log("Support logger injected via reconfigure");
    }
    this._log.debug(() => {
      try {
        const last = globalThis.__CAMUNDA_SDK_LAST_CONFIG;
        const redacted = last?.toRedactedObject ? last.toRedactedObject() : void 0;
        return redacted ? ["config.reconfigured", { config: redacted }] : ["config.reconfigured"];
      } catch {
        return ["config.reconfigured"];
      }
    });
  }
  // Auth helpers
  async getAuthHeaders() {
    return this._auth.getAuthHeaders();
  }
  async forceAuthRefresh() {
    return this._auth.forceRefresh();
  }
  clearAuthCache(opts) {
    this._auth.clearCache(opts);
  }
  onAuthHeaders(h) {
    this._auth.registerHeadersHook(h);
  }
  /** @internal ValidationManager is internal; tests may reach via (client as any)._validation */
  /** Access a scoped logger (internal & future user emission). */
  logger(scope) {
    return scope ? this._log.scope(scope) : this._log;
  }
  /** Internal accessor (read-only) for eventual consistency error mode. */
  getErrorMode() {
    return this._errorMode;
  }
  /** Internal accessor for support logger (no public API commitment yet). */
  _getSupportLogger() {
    return this._supportLogger;
  }
  /**
   * Emit the standard support log preamble & redacted configuration to the current support logger.
   * Safe to call multiple times; subsequent calls are ignored (idempotent).
   * Useful when a custom supportLogger was injected and you still want the canonical header & config dump.
   */
  emitSupportLogPreamble() {
    try {
      writeSupportLogPreamble(this._supportLogger, this._config);
    } catch (e) {
      this._log.debug(() => ["supportLog.preamble.error", e]);
    }
  }
  // Run a function with a correlation ID (manual propagation phase 1)
  withCorrelation(id, fn) {
    return withCorrelation(id, fn);
  }
  // Helper for detecting documented void responses (stable public contract)
  // Referenced from generated code - DO NOT REMOVE
  _isVoidResponse(name) {
    try {
      return zod_gen_exports[name]?.type === "void";
    } catch {
      return false;
    }
  }
  /** Internal invocation helper to apply global backpressure gating + retry + normalization */
  async _invokeWithRetry(op, opts) {
    const { opId, exempt, classify } = opts;
    const signal = void 0;
    if (!exempt) {
      await this._bp.acquire(signal);
    }
    try {
      const result = await executeWithHttpRetry(
        async () => op(),
        this._config.httpRetry,
        this._log.scope(opId),
        (err) => {
          const decision = classify ? classify(err) : defaultHttpClassifier(err);
          if (decision && decision.retryable && /backpressure|http-429/.test(decision.reason)) {
            this._bp.recordBackpressure();
          }
          return decision;
        }
      );
      this._bp.recordHealthyHint();
      return result;
    } catch (e) {
      if (e && e.status && e.status === 429) this._bp.recordBackpressure();
      throw normalizeError(e, { opId });
    } finally {
      if (!exempt) this._bp.release();
    }
  }
  /** Shared evaluation for raw transport responses (throwOnError:false) */
  _evaluateResponse(raw, opId, buildBackpressureError) {
    return evaluateSdkResponse(raw, { opId, buildBackpressureError });
  }
  /** Public accessor for current backpressure adaptive limiter state (stable) */
  getBackpressureState() {
    try {
      return this._bp.getState();
    } catch (e) {
      this._log.error("Error retrieving backpressure state", e);
      return {
        severity: "healthy",
        permitsMax: null,
        permitsCurrent: 0,
        consecutive: 0,
        waiters: 0
      };
    }
  }
  /** Return a read-only snapshot of currently registered job workers. */
  getWorkers() {
    return [...this._workers];
  }
  /** Stop all registered job workers (best-effort). */
  stopAllWorkers() {
    for (const w of this._workers) {
      try {
        if (typeof w.stop === "function") w.stop();
      } catch (e) {
        this._log.warn("worker.stop.error", e);
      }
    }
  }
  activateAdHocSubProcessActivities(arg) {
    return toCancelable2(async (signal) => {
      const { adHocSubProcessInstanceKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { adHocSubProcessInstanceKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("activateAdHocSubProcessActivities", zActivateAdHocSubProcessActivitiesData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await activateAdHocSubProcessActivities(opts);
          let data = this._evaluateResponse(_raw, "activateAdHocSubProcessActivities", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zActivateAdHocSubProcessActivitiesResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zActivateAdHocSubProcessActivitiesResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("activateAdHocSubProcessActivities", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "activateAdHocSubProcessActivities", exempt: false });
    });
  }
  activateJobs(arg) {
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("activateJobs", zActivateJobsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await activateJobs(opts);
          let data = this._evaluateResponse(_raw, "activateJobs", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zActivateJobsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zActivateJobsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("activateJobs", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          if (data && data.jobs) {
            data.jobs = data.jobs.map((j) => enrichActivatedJob(j, this, this.logger().scope(`job:${j.jobKey}`)));
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "activateJobs", exempt: false });
    });
  }
  assignClientToGroup(arg) {
    return toCancelable2(async (signal) => {
      const { groupId, clientId } = arg || {};
      let envelope = {};
      envelope.path = { groupId, clientId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("assignClientToGroup", zAssignClientToGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await assignClientToGroup(opts);
          let data = this._evaluateResponse(_raw, "assignClientToGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zAssignClientToGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zAssignClientToGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("assignClientToGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "assignClientToGroup", exempt: false });
    });
  }
  assignClientToTenant(arg) {
    return toCancelable2(async (signal) => {
      const { tenantId, clientId } = arg || {};
      let envelope = {};
      envelope.path = { tenantId, clientId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("assignClientToTenant", zAssignClientToTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await assignClientToTenant(opts);
          let data = this._evaluateResponse(_raw, "assignClientToTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zAssignClientToTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zAssignClientToTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("assignClientToTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "assignClientToTenant", exempt: false });
    });
  }
  assignGroupToTenant(arg) {
    return toCancelable2(async (signal) => {
      const { tenantId, groupId } = arg || {};
      let envelope = {};
      envelope.path = { tenantId, groupId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("assignGroupToTenant", zAssignGroupToTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await assignGroupToTenant(opts);
          let data = this._evaluateResponse(_raw, "assignGroupToTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zAssignGroupToTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zAssignGroupToTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("assignGroupToTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "assignGroupToTenant", exempt: false });
    });
  }
  assignMappingRuleToGroup(arg) {
    return toCancelable2(async (signal) => {
      const { groupId, mappingRuleId } = arg || {};
      let envelope = {};
      envelope.path = { groupId, mappingRuleId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("assignMappingRuleToGroup", zAssignMappingRuleToGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await assignMappingRuleToGroup(opts);
          let data = this._evaluateResponse(_raw, "assignMappingRuleToGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zAssignMappingRuleToGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zAssignMappingRuleToGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("assignMappingRuleToGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "assignMappingRuleToGroup", exempt: false });
    });
  }
  assignMappingRuleToTenant(arg) {
    return toCancelable2(async (signal) => {
      const { tenantId, mappingRuleId } = arg || {};
      let envelope = {};
      envelope.path = { tenantId, mappingRuleId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("assignMappingRuleToTenant", zAssignMappingRuleToTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await assignMappingRuleToTenant(opts);
          let data = this._evaluateResponse(_raw, "assignMappingRuleToTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zAssignMappingRuleToTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zAssignMappingRuleToTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("assignMappingRuleToTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "assignMappingRuleToTenant", exempt: false });
    });
  }
  assignRoleToClient(arg) {
    return toCancelable2(async (signal) => {
      const { roleId, clientId } = arg || {};
      let envelope = {};
      envelope.path = { roleId, clientId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("assignRoleToClient", zAssignRoleToClientData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await assignRoleToClient(opts);
          let data = this._evaluateResponse(_raw, "assignRoleToClient", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zAssignRoleToClientResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zAssignRoleToClientResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("assignRoleToClient", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "assignRoleToClient", exempt: false });
    });
  }
  assignRoleToGroup(arg) {
    return toCancelable2(async (signal) => {
      const { roleId, groupId } = arg || {};
      let envelope = {};
      envelope.path = { roleId, groupId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("assignRoleToGroup", zAssignRoleToGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await assignRoleToGroup(opts);
          let data = this._evaluateResponse(_raw, "assignRoleToGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zAssignRoleToGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zAssignRoleToGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("assignRoleToGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "assignRoleToGroup", exempt: false });
    });
  }
  assignRoleToMappingRule(arg) {
    return toCancelable2(async (signal) => {
      const { roleId, mappingRuleId } = arg || {};
      let envelope = {};
      envelope.path = { roleId, mappingRuleId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("assignRoleToMappingRule", zAssignRoleToMappingRuleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await assignRoleToMappingRule(opts);
          let data = this._evaluateResponse(_raw, "assignRoleToMappingRule", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zAssignRoleToMappingRuleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zAssignRoleToMappingRuleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("assignRoleToMappingRule", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "assignRoleToMappingRule", exempt: false });
    });
  }
  assignRoleToTenant(arg) {
    return toCancelable2(async (signal) => {
      const { tenantId, roleId } = arg || {};
      let envelope = {};
      envelope.path = { tenantId, roleId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("assignRoleToTenant", zAssignRoleToTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await assignRoleToTenant(opts);
          let data = this._evaluateResponse(_raw, "assignRoleToTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zAssignRoleToTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zAssignRoleToTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("assignRoleToTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "assignRoleToTenant", exempt: false });
    });
  }
  assignRoleToUser(arg) {
    return toCancelable2(async (signal) => {
      const { roleId, username } = arg || {};
      let envelope = {};
      envelope.path = { roleId, username };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("assignRoleToUser", zAssignRoleToUserData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await assignRoleToUser(opts);
          let data = this._evaluateResponse(_raw, "assignRoleToUser", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zAssignRoleToUserResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zAssignRoleToUserResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("assignRoleToUser", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "assignRoleToUser", exempt: false });
    });
  }
  assignUserTask(arg) {
    return toCancelable2(async (signal) => {
      const { userTaskKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { userTaskKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("assignUserTask", zAssignUserTaskData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await assignUserTask(opts);
          let data = this._evaluateResponse(_raw, "assignUserTask", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zAssignUserTaskResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zAssignUserTaskResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("assignUserTask", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "assignUserTask", exempt: false });
    });
  }
  assignUserToGroup(arg) {
    return toCancelable2(async (signal) => {
      const { groupId, username } = arg || {};
      let envelope = {};
      envelope.path = { groupId, username };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("assignUserToGroup", zAssignUserToGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await assignUserToGroup(opts);
          let data = this._evaluateResponse(_raw, "assignUserToGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zAssignUserToGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zAssignUserToGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("assignUserToGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "assignUserToGroup", exempt: false });
    });
  }
  assignUserToTenant(arg) {
    return toCancelable2(async (signal) => {
      const { tenantId, username } = arg || {};
      let envelope = {};
      envelope.path = { tenantId, username };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("assignUserToTenant", zAssignUserToTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await assignUserToTenant(opts);
          let data = this._evaluateResponse(_raw, "assignUserToTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zAssignUserToTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zAssignUserToTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("assignUserToTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "assignUserToTenant", exempt: false });
    });
  }
  broadcastSignal(arg) {
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (envelope.body && (envelope.body.tenantId === void 0 || envelope.body.tenantId === null)) {
        envelope.body.tenantId = this._config.defaultTenantId;
        this._log.trace(() => ["tenant.default.inject", { op: "broadcastSignal", tenant: this._config.defaultTenantId }]);
      }
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("broadcastSignal", zBroadcastSignalData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await broadcastSignal(opts);
          let data = this._evaluateResponse(_raw, "broadcastSignal", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zBroadcastSignalResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zBroadcastSignalResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("broadcastSignal", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "broadcastSignal", exempt: false });
    });
  }
  cancelBatchOperation(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { batchOperationKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { batchOperationKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("cancelBatchOperation", zCancelBatchOperationData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await cancelBatchOperation(opts);
          let data = this._evaluateResponse(_raw, "cancelBatchOperation", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCancelBatchOperationResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCancelBatchOperationResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("cancelBatchOperation", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("cancelBatchOperation", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  cancelProcessInstance(arg) {
    return toCancelable2(async (signal) => {
      const { processInstanceKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { processInstanceKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("cancelProcessInstance", zCancelProcessInstanceData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await cancelProcessInstance(opts);
          let data = this._evaluateResponse(_raw, "cancelProcessInstance", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCancelProcessInstanceResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCancelProcessInstanceResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("cancelProcessInstance", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "cancelProcessInstance", exempt: false });
    });
  }
  cancelProcessInstancesBatchOperation(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("cancelProcessInstancesBatchOperation", zCancelProcessInstancesBatchOperationData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await cancelProcessInstancesBatchOperation(opts);
          let data = this._evaluateResponse(_raw, "cancelProcessInstancesBatchOperation", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCancelProcessInstancesBatchOperationResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCancelProcessInstancesBatchOperationResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("cancelProcessInstancesBatchOperation", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("cancelProcessInstancesBatchOperation", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  completeJob(arg) {
    return toCancelable2(async (signal) => {
      const { jobKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { jobKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("completeJob", zCompleteJobData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await completeJob(opts);
          let data = this._evaluateResponse(_raw, "completeJob", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCompleteJobResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCompleteJobResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("completeJob", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "completeJob", exempt: true });
    });
  }
  completeUserTask(arg) {
    return toCancelable2(async (signal) => {
      const { userTaskKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { userTaskKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("completeUserTask", zCompleteUserTaskData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await completeUserTask(opts);
          let data = this._evaluateResponse(_raw, "completeUserTask", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCompleteUserTaskResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCompleteUserTaskResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("completeUserTask", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "completeUserTask", exempt: true });
    });
  }
  correlateMessage(arg) {
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (envelope.body && (envelope.body.tenantId === void 0 || envelope.body.tenantId === null)) {
        envelope.body.tenantId = this._config.defaultTenantId;
        this._log.trace(() => ["tenant.default.inject", { op: "correlateMessage", tenant: this._config.defaultTenantId }]);
      }
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("correlateMessage", zCorrelateMessageData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await correlateMessage(opts);
          let data = this._evaluateResponse(_raw, "correlateMessage", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCorrelateMessageResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCorrelateMessageResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("correlateMessage", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "correlateMessage", exempt: false });
    });
  }
  createAdminUser(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("createAdminUser", zCreateAdminUserData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await createAdminUser(opts);
          let data = this._evaluateResponse(_raw, "createAdminUser", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCreateAdminUserResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCreateAdminUserResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("createAdminUser", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("createAdminUser", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  createAuthorization(arg) {
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("createAuthorization", zCreateAuthorizationData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await createAuthorization(opts);
          let data = this._evaluateResponse(_raw, "createAuthorization", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCreateAuthorizationResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCreateAuthorizationResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("createAuthorization", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "createAuthorization", exempt: false });
    });
  }
  createDeployment(arg) {
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (envelope.body && (envelope.body.tenantId === void 0 || envelope.body.tenantId === null)) {
        envelope.body.tenantId = this._config.defaultTenantId;
        this._log.trace(() => ["tenant.default.inject", { op: "createDeployment", tenant: this._config.defaultTenantId }]);
      }
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("createDeployment", zCreateDeploymentData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await createDeployment(opts);
          let data = this._evaluateResponse(_raw, "createDeployment", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCreateDeploymentResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCreateDeploymentResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("createDeployment", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          if (data) {
            const base = data;
            const ext = { ...base, processes: [], decisions: [], decisionRequirements: [], forms: [], resources: [] };
            if (Array.isArray(base.deployments)) {
              for (const d of base.deployments) {
                if (d?.processDefinition) ext.processes.push(d.processDefinition);
                if (d?.decisionDefinition) ext.decisions.push(d.decisionDefinition);
                if (d?.decisionRequirements) ext.decisionRequirements.push(d.decisionRequirements);
                if (d?.form) ext.forms.push(d.form);
                if (d?.resource) ext.resources.push(d.resource);
              }
            }
            data = ext;
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "createDeployment", exempt: false });
    });
  }
  createDocument(arg) {
    return toCancelable2(async (signal) => {
      const { storeId, documentId, ..._body } = arg || {};
      let envelope = {};
      envelope.query = { storeId, documentId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("createDocument", zCreateDocumentData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.query) opts.query = envelope.query;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await createDocument(opts);
          let data = this._evaluateResponse(_raw, "createDocument", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCreateDocumentResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCreateDocumentResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("createDocument", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "createDocument", exempt: false });
    });
  }
  createDocumentLink(arg) {
    return toCancelable2(async (signal) => {
      const { documentId, storeId, contentHash, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { documentId };
      envelope.query = { storeId, contentHash };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("createDocumentLink", zCreateDocumentLinkData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.query) opts.query = envelope.query;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await createDocumentLink(opts);
          let data = this._evaluateResponse(_raw, "createDocumentLink", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCreateDocumentLinkResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCreateDocumentLinkResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("createDocumentLink", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "createDocumentLink", exempt: false });
    });
  }
  createDocuments(arg) {
    return toCancelable2(async (signal) => {
      const { storeId, ..._body } = arg || {};
      let envelope = {};
      envelope.query = { storeId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("createDocuments", zCreateDocumentsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.query) opts.query = envelope.query;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await createDocuments(opts);
          let data = this._evaluateResponse(_raw, "createDocuments", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCreateDocumentsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCreateDocumentsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("createDocuments", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "createDocuments", exempt: false });
    });
  }
  createElementInstanceVariables(arg) {
    return toCancelable2(async (signal) => {
      const { elementInstanceKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { elementInstanceKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("createElementInstanceVariables", zCreateElementInstanceVariablesData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await createElementInstanceVariables(opts);
          let data = this._evaluateResponse(_raw, "createElementInstanceVariables", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCreateElementInstanceVariablesResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCreateElementInstanceVariablesResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("createElementInstanceVariables", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "createElementInstanceVariables", exempt: false });
    });
  }
  createGroup(arg) {
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("createGroup", zCreateGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await createGroup(opts);
          let data = this._evaluateResponse(_raw, "createGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCreateGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCreateGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("createGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "createGroup", exempt: false });
    });
  }
  createMappingRule(arg) {
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("createMappingRule", zCreateMappingRuleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await createMappingRule(opts);
          let data = this._evaluateResponse(_raw, "createMappingRule", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCreateMappingRuleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCreateMappingRuleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("createMappingRule", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "createMappingRule", exempt: false });
    });
  }
  createProcessInstance(arg) {
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("createProcessInstance", zCreateProcessInstanceData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await createProcessInstance(opts);
          let data = this._evaluateResponse(_raw, "createProcessInstance", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCreateProcessInstanceResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCreateProcessInstanceResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("createProcessInstance", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "createProcessInstance", exempt: false });
    });
  }
  createRole(arg) {
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("createRole", zCreateRoleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await createRole(opts);
          let data = this._evaluateResponse(_raw, "createRole", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCreateRoleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCreateRoleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("createRole", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "createRole", exempt: false });
    });
  }
  createTenant(arg) {
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("createTenant", zCreateTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await createTenant(opts);
          let data = this._evaluateResponse(_raw, "createTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCreateTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCreateTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("createTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "createTenant", exempt: false });
    });
  }
  createUser(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("createUser", zCreateUserData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await createUser(opts);
          let data = this._evaluateResponse(_raw, "createUser", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zCreateUserResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zCreateUserResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("createUser", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("createUser", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  deleteAuthorization(arg) {
    return toCancelable2(async (signal) => {
      const { authorizationKey } = arg || {};
      let envelope = {};
      envelope.path = { authorizationKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("deleteAuthorization", zDeleteAuthorizationData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await deleteAuthorization(opts);
          let data = this._evaluateResponse(_raw, "deleteAuthorization", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zDeleteAuthorizationResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zDeleteAuthorizationResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("deleteAuthorization", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "deleteAuthorization", exempt: false });
    });
  }
  deleteDocument(arg) {
    return toCancelable2(async (signal) => {
      const { documentId, storeId } = arg || {};
      let envelope = {};
      envelope.path = { documentId };
      envelope.query = { storeId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("deleteDocument", zDeleteDocumentData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.query) opts.query = envelope.query;
      const call = async () => {
        try {
          const _raw = await deleteDocument(opts);
          let data = this._evaluateResponse(_raw, "deleteDocument", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zDeleteDocumentResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zDeleteDocumentResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("deleteDocument", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "deleteDocument", exempt: false });
    });
  }
  deleteGroup(arg) {
    return toCancelable2(async (signal) => {
      const { groupId } = arg || {};
      let envelope = {};
      envelope.path = { groupId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("deleteGroup", zDeleteGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await deleteGroup(opts);
          let data = this._evaluateResponse(_raw, "deleteGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zDeleteGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zDeleteGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("deleteGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "deleteGroup", exempt: false });
    });
  }
  deleteMappingRule(arg) {
    return toCancelable2(async (signal) => {
      const { mappingRuleId } = arg || {};
      let envelope = {};
      envelope.path = { mappingRuleId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("deleteMappingRule", zDeleteMappingRuleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await deleteMappingRule(opts);
          let data = this._evaluateResponse(_raw, "deleteMappingRule", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zDeleteMappingRuleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zDeleteMappingRuleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("deleteMappingRule", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "deleteMappingRule", exempt: false });
    });
  }
  deleteResource(arg) {
    return toCancelable2(async (signal) => {
      const { resourceKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { resourceKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("deleteResource", zDeleteResourceData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await deleteResource(opts);
          let data = this._evaluateResponse(_raw, "deleteResource", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zDeleteResourceResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "deleteResource", exempt: false });
    });
  }
  deleteRole(arg) {
    return toCancelable2(async (signal) => {
      const { roleId } = arg || {};
      let envelope = {};
      envelope.path = { roleId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("deleteRole", zDeleteRoleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await deleteRole(opts);
          let data = this._evaluateResponse(_raw, "deleteRole", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zDeleteRoleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zDeleteRoleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("deleteRole", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "deleteRole", exempt: false });
    });
  }
  deleteTenant(arg) {
    return toCancelable2(async (signal) => {
      const { tenantId } = arg || {};
      let envelope = {};
      envelope.path = { tenantId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("deleteTenant", zDeleteTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await deleteTenant(opts);
          let data = this._evaluateResponse(_raw, "deleteTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zDeleteTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zDeleteTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("deleteTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "deleteTenant", exempt: false });
    });
  }
  deleteUser(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { username } = arg || {};
      let envelope = {};
      envelope.path = { username };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("deleteUser", zDeleteUserData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await deleteUser(opts);
          let data = this._evaluateResponse(_raw, "deleteUser", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zDeleteUserResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zDeleteUserResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("deleteUser", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("deleteUser", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  evaluateDecision(arg) {
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("evaluateDecision", zEvaluateDecisionData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await evaluateDecision(opts);
          let data = this._evaluateResponse(_raw, "evaluateDecision", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zEvaluateDecisionResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zEvaluateDecisionResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("evaluateDecision", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "evaluateDecision", exempt: false });
    });
  }
  failJob(arg) {
    return toCancelable2(async (signal) => {
      const { jobKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { jobKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("failJob", zFailJobData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await failJob(opts);
          let data = this._evaluateResponse(_raw, "failJob", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zFailJobResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zFailJobResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("failJob", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "failJob", exempt: true });
    });
  }
  getAuthentication(arg) {
    return toCancelable2(async (signal) => {
      const opts = { client: this._client, signal, throwOnError: false };
      const call = async () => {
        try {
          const _raw = await getAuthentication(opts);
          let data = this._evaluateResponse(_raw, "getAuthentication", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetAuthenticationResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetAuthenticationResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getAuthentication", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "getAuthentication", exempt: false });
    });
  }
  getAuthorization(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { authorizationKey } = arg || {};
      let envelope = {};
      envelope.path = { authorizationKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getAuthorization", zGetAuthorizationData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getAuthorization(opts);
          let data = this._evaluateResponse(_raw, "getAuthorization", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetAuthorizationResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetAuthorizationResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getAuthorization", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getAuthorization", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getBatchOperation(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { batchOperationKey } = arg || {};
      let envelope = {};
      envelope.path = { batchOperationKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getBatchOperation", zGetBatchOperationData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getBatchOperation(opts);
          let data = this._evaluateResponse(_raw, "getBatchOperation", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetBatchOperationResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetBatchOperationResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getBatchOperation", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getBatchOperation", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getDecisionDefinition(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { decisionDefinitionKey } = arg || {};
      let envelope = {};
      envelope.path = { decisionDefinitionKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getDecisionDefinition", zGetDecisionDefinitionData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getDecisionDefinition(opts);
          let data = this._evaluateResponse(_raw, "getDecisionDefinition", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetDecisionDefinitionResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetDecisionDefinitionResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getDecisionDefinition", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getDecisionDefinition", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getDecisionDefinitionXml(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { decisionDefinitionKey } = arg || {};
      let envelope = {};
      envelope.path = { decisionDefinitionKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getDecisionDefinitionXML", zGetDecisionDefinitionXmlData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getDecisionDefinitionXml(opts);
          let data = this._evaluateResponse(_raw, "getDecisionDefinitionXML", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetDecisionDefinitionXmlResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetDecisionDefinitionXmlResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getDecisionDefinitionXML", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getDecisionDefinitionXML", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getDecisionInstance(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { decisionEvaluationInstanceKey } = arg || {};
      let envelope = {};
      envelope.path = { decisionEvaluationInstanceKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getDecisionInstance", zGetDecisionInstanceData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getDecisionInstance(opts);
          let data = this._evaluateResponse(_raw, "getDecisionInstance", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetDecisionInstanceResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetDecisionInstanceResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getDecisionInstance", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getDecisionInstance", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getDecisionRequirements(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { decisionRequirementsKey } = arg || {};
      let envelope = {};
      envelope.path = { decisionRequirementsKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getDecisionRequirements", zGetDecisionRequirementsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getDecisionRequirements(opts);
          let data = this._evaluateResponse(_raw, "getDecisionRequirements", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetDecisionRequirementsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetDecisionRequirementsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getDecisionRequirements", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getDecisionRequirements", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getDecisionRequirementsXml(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { decisionRequirementsKey } = arg || {};
      let envelope = {};
      envelope.path = { decisionRequirementsKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getDecisionRequirementsXML", zGetDecisionRequirementsXmlData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getDecisionRequirementsXml(opts);
          let data = this._evaluateResponse(_raw, "getDecisionRequirementsXML", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetDecisionRequirementsXmlResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetDecisionRequirementsXmlResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getDecisionRequirementsXML", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getDecisionRequirementsXML", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getDocument(arg) {
    return toCancelable2(async (signal) => {
      const { documentId, storeId, contentHash } = arg || {};
      let envelope = {};
      envelope.path = { documentId };
      envelope.query = { storeId, contentHash };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getDocument", zGetDocumentData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.query) opts.query = envelope.query;
      const call = async () => {
        try {
          const _raw = await getDocument(opts);
          let data = this._evaluateResponse(_raw, "getDocument", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetDocumentResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetDocumentResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getDocument", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "getDocument", exempt: false });
    });
  }
  getElementInstance(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { elementInstanceKey } = arg || {};
      let envelope = {};
      envelope.path = { elementInstanceKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getElementInstance", zGetElementInstanceData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getElementInstance(opts);
          let data = this._evaluateResponse(_raw, "getElementInstance", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetElementInstanceResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetElementInstanceResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getElementInstance", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getElementInstance", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getGroup(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { groupId } = arg || {};
      let envelope = {};
      envelope.path = { groupId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getGroup", zGetGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getGroup(opts);
          let data = this._evaluateResponse(_raw, "getGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getGroup", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getIncident(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { incidentKey } = arg || {};
      let envelope = {};
      envelope.path = { incidentKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getIncident", zGetIncidentData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getIncident(opts);
          let data = this._evaluateResponse(_raw, "getIncident", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetIncidentResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetIncidentResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getIncident", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getIncident", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getLicense(arg) {
    return toCancelable2(async (signal) => {
      const opts = { client: this._client, signal, throwOnError: false };
      const call = async () => {
        try {
          const _raw = await getLicense(opts);
          let data = this._evaluateResponse(_raw, "getLicense", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetLicenseResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetLicenseResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getLicense", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "getLicense", exempt: false });
    });
  }
  getMappingRule(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { mappingRuleId } = arg || {};
      let envelope = {};
      envelope.path = { mappingRuleId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getMappingRule", zGetMappingRuleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getMappingRule(opts);
          let data = this._evaluateResponse(_raw, "getMappingRule", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetMappingRuleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetMappingRuleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getMappingRule", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getMappingRule", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getProcessDefinition(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { processDefinitionKey } = arg || {};
      let envelope = {};
      envelope.path = { processDefinitionKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getProcessDefinition", zGetProcessDefinitionData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getProcessDefinition(opts);
          let data = this._evaluateResponse(_raw, "getProcessDefinition", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetProcessDefinitionResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetProcessDefinitionResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getProcessDefinition", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getProcessDefinition", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getProcessDefinitionStatistics(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { processDefinitionKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { processDefinitionKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getProcessDefinitionStatistics", zGetProcessDefinitionStatisticsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await getProcessDefinitionStatistics(opts);
          let data = this._evaluateResponse(_raw, "getProcessDefinitionStatistics", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetProcessDefinitionStatisticsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetProcessDefinitionStatisticsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getProcessDefinitionStatistics", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getProcessDefinitionStatistics", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getProcessDefinitionXml(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { processDefinitionKey } = arg || {};
      let envelope = {};
      envelope.path = { processDefinitionKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getProcessDefinitionXML", zGetProcessDefinitionXmlData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getProcessDefinitionXml(opts);
          let data = this._evaluateResponse(_raw, "getProcessDefinitionXML", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetProcessDefinitionXmlResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetProcessDefinitionXmlResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getProcessDefinitionXML", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getProcessDefinitionXML", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getProcessInstance(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { processInstanceKey } = arg || {};
      let envelope = {};
      envelope.path = { processInstanceKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getProcessInstance", zGetProcessInstanceData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getProcessInstance(opts);
          let data = this._evaluateResponse(_raw, "getProcessInstance", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetProcessInstanceResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetProcessInstanceResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getProcessInstance", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getProcessInstance", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getProcessInstanceCallHierarchy(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { processInstanceKey } = arg || {};
      let envelope = {};
      envelope.path = { processInstanceKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getProcessInstanceCallHierarchy", zGetProcessInstanceCallHierarchyData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getProcessInstanceCallHierarchy(opts);
          let data = this._evaluateResponse(_raw, "getProcessInstanceCallHierarchy", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetProcessInstanceCallHierarchyResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetProcessInstanceCallHierarchyResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getProcessInstanceCallHierarchy", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getProcessInstanceCallHierarchy", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getProcessInstanceSequenceFlows(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { processInstanceKey } = arg || {};
      let envelope = {};
      envelope.path = { processInstanceKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getProcessInstanceSequenceFlows", zGetProcessInstanceSequenceFlowsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getProcessInstanceSequenceFlows(opts);
          let data = this._evaluateResponse(_raw, "getProcessInstanceSequenceFlows", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetProcessInstanceSequenceFlowsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetProcessInstanceSequenceFlowsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getProcessInstanceSequenceFlows", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getProcessInstanceSequenceFlows", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getProcessInstanceStatistics(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { processInstanceKey } = arg || {};
      let envelope = {};
      envelope.path = { processInstanceKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getProcessInstanceStatistics", zGetProcessInstanceStatisticsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getProcessInstanceStatistics(opts);
          let data = this._evaluateResponse(_raw, "getProcessInstanceStatistics", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetProcessInstanceStatisticsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetProcessInstanceStatisticsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getProcessInstanceStatistics", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getProcessInstanceStatistics", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getResource(arg) {
    return toCancelable2(async (signal) => {
      const { resourceKey } = arg || {};
      let envelope = {};
      envelope.path = { resourceKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getResource", zGetResourceData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getResource(opts);
          let data = this._evaluateResponse(_raw, "getResource", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetResourceResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetResourceResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getResource", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "getResource", exempt: false });
    });
  }
  getResourceContent(arg) {
    return toCancelable2(async (signal) => {
      const { resourceKey } = arg || {};
      let envelope = {};
      envelope.path = { resourceKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getResourceContent", zGetResourceContentData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getResourceContent(opts);
          let data = this._evaluateResponse(_raw, "getResourceContent", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetResourceContentResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetResourceContentResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getResourceContent", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "getResourceContent", exempt: false });
    });
  }
  getRole(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { roleId } = arg || {};
      let envelope = {};
      envelope.path = { roleId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getRole", zGetRoleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getRole(opts);
          let data = this._evaluateResponse(_raw, "getRole", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetRoleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetRoleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getRole", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getRole", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getStartProcessForm(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { processDefinitionKey } = arg || {};
      let envelope = {};
      envelope.path = { processDefinitionKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getStartProcessForm", zGetStartProcessFormData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getStartProcessForm(opts);
          let data = this._evaluateResponse(_raw, "getStartProcessForm", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetStartProcessFormResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetStartProcessFormResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getStartProcessForm", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getStartProcessForm", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getStatus(arg) {
    return toCancelable2(async (signal) => {
      const opts = { client: this._client, signal, throwOnError: false };
      const call = async () => {
        try {
          const _raw = await getStatus(opts);
          let data = this._evaluateResponse(_raw, "getStatus", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetStatusResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetStatusResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getStatus", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "getStatus", exempt: false });
    });
  }
  getTenant(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { tenantId } = arg || {};
      let envelope = {};
      envelope.path = { tenantId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getTenant", zGetTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getTenant(opts);
          let data = this._evaluateResponse(_raw, "getTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getTenant", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getTopology(arg) {
    return toCancelable2(async (signal) => {
      const opts = { client: this._client, signal, throwOnError: false };
      const call = async () => {
        try {
          const _raw = await getTopology(opts);
          let data = this._evaluateResponse(_raw, "getTopology", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetTopologyResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetTopologyResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getTopology", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "getTopology", exempt: false });
    });
  }
  getUsageMetrics(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { startTime, endTime, tenantId, withTenants } = arg || {};
      let envelope = {};
      envelope.query = { startTime, endTime, tenantId, withTenants };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getUsageMetrics", zGetUsageMetricsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.query) opts.query = envelope.query;
      const call = async () => {
        try {
          const _raw = await getUsageMetrics(opts);
          let data = this._evaluateResponse(_raw, "getUsageMetrics", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetUsageMetricsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetUsageMetricsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getUsageMetrics", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getUsageMetrics", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getUser(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { username } = arg || {};
      let envelope = {};
      envelope.path = { username };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getUser", zGetUserData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getUser(opts);
          let data = this._evaluateResponse(_raw, "getUser", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetUserResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetUserResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getUser", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getUser", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getUserTask(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { userTaskKey } = arg || {};
      let envelope = {};
      envelope.path = { userTaskKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getUserTask", zGetUserTaskData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getUserTask(opts);
          let data = this._evaluateResponse(_raw, "getUserTask", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetUserTaskResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetUserTaskResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getUserTask", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getUserTask", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getUserTaskForm(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { userTaskKey } = arg || {};
      let envelope = {};
      envelope.path = { userTaskKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getUserTaskForm", zGetUserTaskFormData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getUserTaskForm(opts);
          let data = this._evaluateResponse(_raw, "getUserTaskForm", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetUserTaskFormResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetUserTaskFormResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getUserTaskForm", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getUserTaskForm", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  getVariable(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { variableKey } = arg || {};
      let envelope = {};
      envelope.path = { variableKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("getVariable", zGetVariableData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await getVariable(opts);
          let data = this._evaluateResponse(_raw, "getVariable", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zGetVariableResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zGetVariableResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("getVariable", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("getVariable", true, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  migrateProcessInstance(arg) {
    return toCancelable2(async (signal) => {
      const { processInstanceKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { processInstanceKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("migrateProcessInstance", zMigrateProcessInstanceData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await migrateProcessInstance(opts);
          let data = this._evaluateResponse(_raw, "migrateProcessInstance", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zMigrateProcessInstanceResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zMigrateProcessInstanceResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("migrateProcessInstance", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "migrateProcessInstance", exempt: false });
    });
  }
  migrateProcessInstancesBatchOperation(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("migrateProcessInstancesBatchOperation", zMigrateProcessInstancesBatchOperationData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await migrateProcessInstancesBatchOperation(opts);
          let data = this._evaluateResponse(_raw, "migrateProcessInstancesBatchOperation", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zMigrateProcessInstancesBatchOperationResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zMigrateProcessInstancesBatchOperationResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("migrateProcessInstancesBatchOperation", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("migrateProcessInstancesBatchOperation", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  modifyProcessInstance(arg) {
    return toCancelable2(async (signal) => {
      const { processInstanceKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { processInstanceKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("modifyProcessInstance", zModifyProcessInstanceData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await modifyProcessInstance(opts);
          let data = this._evaluateResponse(_raw, "modifyProcessInstance", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zModifyProcessInstanceResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zModifyProcessInstanceResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("modifyProcessInstance", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "modifyProcessInstance", exempt: false });
    });
  }
  modifyProcessInstancesBatchOperation(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("modifyProcessInstancesBatchOperation", zModifyProcessInstancesBatchOperationData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await modifyProcessInstancesBatchOperation(opts);
          let data = this._evaluateResponse(_raw, "modifyProcessInstancesBatchOperation", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zModifyProcessInstancesBatchOperationResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zModifyProcessInstancesBatchOperationResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("modifyProcessInstancesBatchOperation", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("modifyProcessInstancesBatchOperation", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  pinClock(arg) {
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("pinClock", zPinClockData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await pinClock(opts);
          let data = this._evaluateResponse(_raw, "pinClock", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zPinClockResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zPinClockResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("pinClock", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "pinClock", exempt: false });
    });
  }
  publishMessage(arg) {
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (envelope.body && (envelope.body.tenantId === void 0 || envelope.body.tenantId === null)) {
        envelope.body.tenantId = this._config.defaultTenantId;
        this._log.trace(() => ["tenant.default.inject", { op: "publishMessage", tenant: this._config.defaultTenantId }]);
      }
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("publishMessage", zPublishMessageData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await publishMessage(opts);
          let data = this._evaluateResponse(_raw, "publishMessage", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zPublishMessageResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zPublishMessageResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("publishMessage", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "publishMessage", exempt: false });
    });
  }
  resetClock(arg) {
    return toCancelable2(async (signal) => {
      const opts = { client: this._client, signal, throwOnError: false };
      const call = async () => {
        try {
          const _raw = await resetClock(opts);
          let data = this._evaluateResponse(_raw, "resetClock", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zResetClockResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zResetClockResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("resetClock", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "resetClock", exempt: false });
    });
  }
  resolveIncident(arg) {
    return toCancelable2(async (signal) => {
      const { incidentKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { incidentKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("resolveIncident", zResolveIncidentData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await resolveIncident(opts);
          let data = this._evaluateResponse(_raw, "resolveIncident", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zResolveIncidentResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zResolveIncidentResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("resolveIncident", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "resolveIncident", exempt: false });
    });
  }
  resolveIncidentsBatchOperation(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("resolveIncidentsBatchOperation", zResolveIncidentsBatchOperationData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await resolveIncidentsBatchOperation(opts);
          let data = this._evaluateResponse(_raw, "resolveIncidentsBatchOperation", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zResolveIncidentsBatchOperationResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zResolveIncidentsBatchOperationResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("resolveIncidentsBatchOperation", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("resolveIncidentsBatchOperation", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  resumeBatchOperation(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { batchOperationKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { batchOperationKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("resumeBatchOperation", zResumeBatchOperationData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await resumeBatchOperation(opts);
          let data = this._evaluateResponse(_raw, "resumeBatchOperation", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zResumeBatchOperationResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zResumeBatchOperationResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("resumeBatchOperation", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("resumeBatchOperation", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchAuthorizations(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchAuthorizations", zSearchAuthorizationsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchAuthorizations(opts);
          let data = this._evaluateResponse(_raw, "searchAuthorizations", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchAuthorizationsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchAuthorizationsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchAuthorizations", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchAuthorizations", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchBatchOperationItems(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchBatchOperationItems", zSearchBatchOperationItemsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchBatchOperationItems(opts);
          let data = this._evaluateResponse(_raw, "searchBatchOperationItems", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchBatchOperationItemsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchBatchOperationItemsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchBatchOperationItems", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchBatchOperationItems", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchBatchOperations(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchBatchOperations", zSearchBatchOperationsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchBatchOperations(opts);
          let data = this._evaluateResponse(_raw, "searchBatchOperations", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchBatchOperationsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchBatchOperationsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchBatchOperations", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchBatchOperations", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchClientsForGroup(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { groupId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { groupId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchClientsForGroup", zSearchClientsForGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchClientsForGroup(opts);
          let data = this._evaluateResponse(_raw, "searchClientsForGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchClientsForGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchClientsForGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchClientsForGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchClientsForGroup", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchClientsForRole(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { roleId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { roleId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchClientsForRole", zSearchClientsForRoleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchClientsForRole(opts);
          let data = this._evaluateResponse(_raw, "searchClientsForRole", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchClientsForRoleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchClientsForRoleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchClientsForRole", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchClientsForRole", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchClientsForTenant(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { tenantId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { tenantId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchClientsForTenant", zSearchClientsForTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchClientsForTenant(opts);
          let data = this._evaluateResponse(_raw, "searchClientsForTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchClientsForTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchClientsForTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchClientsForTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchClientsForTenant", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchCorrelatedMessageSubscriptions(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchCorrelatedMessageSubscriptions", zSearchCorrelatedMessageSubscriptionsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchCorrelatedMessageSubscriptions(opts);
          let data = this._evaluateResponse(_raw, "searchCorrelatedMessageSubscriptions", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchCorrelatedMessageSubscriptionsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchCorrelatedMessageSubscriptionsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchCorrelatedMessageSubscriptions", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchCorrelatedMessageSubscriptions", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchDecisionDefinitions(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchDecisionDefinitions", zSearchDecisionDefinitionsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchDecisionDefinitions(opts);
          let data = this._evaluateResponse(_raw, "searchDecisionDefinitions", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchDecisionDefinitionsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchDecisionDefinitionsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchDecisionDefinitions", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchDecisionDefinitions", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchDecisionInstances(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchDecisionInstances", zSearchDecisionInstancesData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchDecisionInstances(opts);
          let data = this._evaluateResponse(_raw, "searchDecisionInstances", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchDecisionInstancesResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchDecisionInstancesResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchDecisionInstances", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchDecisionInstances", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchDecisionRequirements(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchDecisionRequirements", zSearchDecisionRequirementsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchDecisionRequirements(opts);
          let data = this._evaluateResponse(_raw, "searchDecisionRequirements", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchDecisionRequirementsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchDecisionRequirementsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchDecisionRequirements", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchDecisionRequirements", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchElementInstances(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchElementInstances", zSearchElementInstancesData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchElementInstances(opts);
          let data = this._evaluateResponse(_raw, "searchElementInstances", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchElementInstancesResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchElementInstancesResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchElementInstances", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchElementInstances", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchGroupIdsForTenant(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { tenantId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { tenantId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchGroupIdsForTenant", zSearchGroupIdsForTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchGroupIdsForTenant(opts);
          let data = this._evaluateResponse(_raw, "searchGroupIdsForTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchGroupIdsForTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchGroupIdsForTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchGroupIdsForTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchGroupIdsForTenant", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchGroups(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchGroups", zSearchGroupsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchGroups(opts);
          let data = this._evaluateResponse(_raw, "searchGroups", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchGroupsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchGroupsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchGroups", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchGroups", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchGroupsForRole(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { roleId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { roleId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchGroupsForRole", zSearchGroupsForRoleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchGroupsForRole(opts);
          let data = this._evaluateResponse(_raw, "searchGroupsForRole", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchGroupsForRoleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchGroupsForRoleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchGroupsForRole", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchGroupsForRole", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchIncidents(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchIncidents", zSearchIncidentsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchIncidents(opts);
          let data = this._evaluateResponse(_raw, "searchIncidents", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchIncidentsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchIncidentsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchIncidents", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchIncidents", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchJobs(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchJobs", zSearchJobsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchJobs(opts);
          let data = this._evaluateResponse(_raw, "searchJobs", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchJobsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchJobsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchJobs", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchJobs", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchMappingRule(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchMappingRule", zSearchMappingRuleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchMappingRule(opts);
          let data = this._evaluateResponse(_raw, "searchMappingRule", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchMappingRuleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchMappingRuleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchMappingRule", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchMappingRule", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchMappingRulesForGroup(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { groupId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { groupId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchMappingRulesForGroup", zSearchMappingRulesForGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchMappingRulesForGroup(opts);
          let data = this._evaluateResponse(_raw, "searchMappingRulesForGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchMappingRulesForGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchMappingRulesForGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchMappingRulesForGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchMappingRulesForGroup", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchMappingRulesForRole(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { roleId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { roleId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchMappingRulesForRole", zSearchMappingRulesForRoleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchMappingRulesForRole(opts);
          let data = this._evaluateResponse(_raw, "searchMappingRulesForRole", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchMappingRulesForRoleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchMappingRulesForRoleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchMappingRulesForRole", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchMappingRulesForRole", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchMappingRulesForTenant(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { tenantId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { tenantId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchMappingRulesForTenant", zSearchMappingRulesForTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchMappingRulesForTenant(opts);
          let data = this._evaluateResponse(_raw, "searchMappingRulesForTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchMappingRulesForTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchMappingRulesForTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchMappingRulesForTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchMappingRulesForTenant", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchMessageSubscriptions(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchMessageSubscriptions", zSearchMessageSubscriptionsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchMessageSubscriptions(opts);
          let data = this._evaluateResponse(_raw, "searchMessageSubscriptions", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchMessageSubscriptionsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchMessageSubscriptionsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchMessageSubscriptions", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchMessageSubscriptions", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchProcessDefinitions(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchProcessDefinitions", zSearchProcessDefinitionsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchProcessDefinitions(opts);
          let data = this._evaluateResponse(_raw, "searchProcessDefinitions", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchProcessDefinitionsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchProcessDefinitionsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchProcessDefinitions", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchProcessDefinitions", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchProcessInstanceIncidents(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { processInstanceKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { processInstanceKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchProcessInstanceIncidents", zSearchProcessInstanceIncidentsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchProcessInstanceIncidents(opts);
          let data = this._evaluateResponse(_raw, "searchProcessInstanceIncidents", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchProcessInstanceIncidentsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchProcessInstanceIncidentsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchProcessInstanceIncidents", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchProcessInstanceIncidents", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchProcessInstances(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchProcessInstances", zSearchProcessInstancesData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchProcessInstances(opts);
          let data = this._evaluateResponse(_raw, "searchProcessInstances", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchProcessInstancesResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchProcessInstancesResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchProcessInstances", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchProcessInstances", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchRoles(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchRoles", zSearchRolesData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchRoles(opts);
          let data = this._evaluateResponse(_raw, "searchRoles", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchRolesResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchRolesResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchRoles", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchRoles", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchRolesForGroup(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { groupId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { groupId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchRolesForGroup", zSearchRolesForGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchRolesForGroup(opts);
          let data = this._evaluateResponse(_raw, "searchRolesForGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchRolesForGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchRolesForGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchRolesForGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchRolesForGroup", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchRolesForTenant(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { tenantId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { tenantId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchRolesForTenant", zSearchRolesForTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchRolesForTenant(opts);
          let data = this._evaluateResponse(_raw, "searchRolesForTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchRolesForTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchRolesForTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchRolesForTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchRolesForTenant", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchTenants(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchTenants", zSearchTenantsData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchTenants(opts);
          let data = this._evaluateResponse(_raw, "searchTenants", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchTenantsResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchTenantsResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchTenants", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchTenants", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchUsers(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchUsers", zSearchUsersData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchUsers(opts);
          let data = this._evaluateResponse(_raw, "searchUsers", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchUsersResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchUsersResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchUsers", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchUsers", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchUsersForGroup(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { groupId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { groupId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchUsersForGroup", zSearchUsersForGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchUsersForGroup(opts);
          let data = this._evaluateResponse(_raw, "searchUsersForGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchUsersForGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchUsersForGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchUsersForGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchUsersForGroup", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchUsersForRole(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { roleId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { roleId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchUsersForRole", zSearchUsersForRoleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchUsersForRole(opts);
          let data = this._evaluateResponse(_raw, "searchUsersForRole", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchUsersForRoleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchUsersForRoleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchUsersForRole", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchUsersForRole", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchUsersForTenant(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { tenantId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { tenantId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchUsersForTenant", zSearchUsersForTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchUsersForTenant(opts);
          let data = this._evaluateResponse(_raw, "searchUsersForTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchUsersForTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchUsersForTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchUsersForTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchUsersForTenant", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchUserTasks(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchUserTasks", zSearchUserTasksData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchUserTasks(opts);
          let data = this._evaluateResponse(_raw, "searchUserTasks", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchUserTasksResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchUserTasksResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchUserTasks", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchUserTasks", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchUserTaskVariables(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { userTaskKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { userTaskKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchUserTaskVariables", zSearchUserTaskVariablesData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchUserTaskVariables(opts);
          let data = this._evaluateResponse(_raw, "searchUserTaskVariables", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchUserTaskVariablesResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchUserTaskVariablesResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchUserTaskVariables", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchUserTaskVariables", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  searchVariables(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const _body = arg;
      let envelope = {};
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("searchVariables", zSearchVariablesData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await searchVariables(opts);
          let data = this._evaluateResponse(_raw, "searchVariables", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSearchVariablesResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSearchVariablesResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("searchVariables", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("searchVariables", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  suspendBatchOperation(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { batchOperationKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { batchOperationKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("suspendBatchOperation", zSuspendBatchOperationData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await suspendBatchOperation(opts);
          let data = this._evaluateResponse(_raw, "suspendBatchOperation", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zSuspendBatchOperationResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zSuspendBatchOperationResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("suspendBatchOperation", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("suspendBatchOperation", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  throwJobError(arg) {
    return toCancelable2(async (signal) => {
      const { jobKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { jobKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("throwJobError", zThrowJobErrorData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await throwJobError(opts);
          let data = this._evaluateResponse(_raw, "throwJobError", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zThrowJobErrorResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zThrowJobErrorResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("throwJobError", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "throwJobError", exempt: true });
    });
  }
  unassignClientFromGroup(arg) {
    return toCancelable2(async (signal) => {
      const { groupId, clientId } = arg || {};
      let envelope = {};
      envelope.path = { groupId, clientId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("unassignClientFromGroup", zUnassignClientFromGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await unassignClientFromGroup(opts);
          let data = this._evaluateResponse(_raw, "unassignClientFromGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUnassignClientFromGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUnassignClientFromGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("unassignClientFromGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "unassignClientFromGroup", exempt: false });
    });
  }
  unassignClientFromTenant(arg) {
    return toCancelable2(async (signal) => {
      const { tenantId, clientId } = arg || {};
      let envelope = {};
      envelope.path = { tenantId, clientId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("unassignClientFromTenant", zUnassignClientFromTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await unassignClientFromTenant(opts);
          let data = this._evaluateResponse(_raw, "unassignClientFromTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUnassignClientFromTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUnassignClientFromTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("unassignClientFromTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "unassignClientFromTenant", exempt: false });
    });
  }
  unassignGroupFromTenant(arg) {
    return toCancelable2(async (signal) => {
      const { tenantId, groupId } = arg || {};
      let envelope = {};
      envelope.path = { tenantId, groupId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("unassignGroupFromTenant", zUnassignGroupFromTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await unassignGroupFromTenant(opts);
          let data = this._evaluateResponse(_raw, "unassignGroupFromTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUnassignGroupFromTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUnassignGroupFromTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("unassignGroupFromTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "unassignGroupFromTenant", exempt: false });
    });
  }
  unassignMappingRuleFromGroup(arg) {
    return toCancelable2(async (signal) => {
      const { groupId, mappingRuleId } = arg || {};
      let envelope = {};
      envelope.path = { groupId, mappingRuleId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("unassignMappingRuleFromGroup", zUnassignMappingRuleFromGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await unassignMappingRuleFromGroup(opts);
          let data = this._evaluateResponse(_raw, "unassignMappingRuleFromGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUnassignMappingRuleFromGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUnassignMappingRuleFromGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("unassignMappingRuleFromGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "unassignMappingRuleFromGroup", exempt: false });
    });
  }
  unassignMappingRuleFromTenant(arg) {
    return toCancelable2(async (signal) => {
      const { tenantId, mappingRuleId } = arg || {};
      let envelope = {};
      envelope.path = { tenantId, mappingRuleId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("unassignMappingRuleFromTenant", zUnassignMappingRuleFromTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await unassignMappingRuleFromTenant(opts);
          let data = this._evaluateResponse(_raw, "unassignMappingRuleFromTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUnassignMappingRuleFromTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUnassignMappingRuleFromTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("unassignMappingRuleFromTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "unassignMappingRuleFromTenant", exempt: false });
    });
  }
  unassignRoleFromClient(arg) {
    return toCancelable2(async (signal) => {
      const { roleId, clientId } = arg || {};
      let envelope = {};
      envelope.path = { roleId, clientId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("unassignRoleFromClient", zUnassignRoleFromClientData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await unassignRoleFromClient(opts);
          let data = this._evaluateResponse(_raw, "unassignRoleFromClient", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUnassignRoleFromClientResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUnassignRoleFromClientResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("unassignRoleFromClient", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "unassignRoleFromClient", exempt: false });
    });
  }
  unassignRoleFromGroup(arg) {
    return toCancelable2(async (signal) => {
      const { roleId, groupId } = arg || {};
      let envelope = {};
      envelope.path = { roleId, groupId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("unassignRoleFromGroup", zUnassignRoleFromGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await unassignRoleFromGroup(opts);
          let data = this._evaluateResponse(_raw, "unassignRoleFromGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUnassignRoleFromGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUnassignRoleFromGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("unassignRoleFromGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "unassignRoleFromGroup", exempt: false });
    });
  }
  unassignRoleFromMappingRule(arg) {
    return toCancelable2(async (signal) => {
      const { roleId, mappingRuleId } = arg || {};
      let envelope = {};
      envelope.path = { roleId, mappingRuleId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("unassignRoleFromMappingRule", zUnassignRoleFromMappingRuleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await unassignRoleFromMappingRule(opts);
          let data = this._evaluateResponse(_raw, "unassignRoleFromMappingRule", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUnassignRoleFromMappingRuleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUnassignRoleFromMappingRuleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("unassignRoleFromMappingRule", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "unassignRoleFromMappingRule", exempt: false });
    });
  }
  unassignRoleFromTenant(arg) {
    return toCancelable2(async (signal) => {
      const { tenantId, roleId } = arg || {};
      let envelope = {};
      envelope.path = { tenantId, roleId };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("unassignRoleFromTenant", zUnassignRoleFromTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await unassignRoleFromTenant(opts);
          let data = this._evaluateResponse(_raw, "unassignRoleFromTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUnassignRoleFromTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUnassignRoleFromTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("unassignRoleFromTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "unassignRoleFromTenant", exempt: false });
    });
  }
  unassignRoleFromUser(arg) {
    return toCancelable2(async (signal) => {
      const { roleId, username } = arg || {};
      let envelope = {};
      envelope.path = { roleId, username };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("unassignRoleFromUser", zUnassignRoleFromUserData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await unassignRoleFromUser(opts);
          let data = this._evaluateResponse(_raw, "unassignRoleFromUser", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUnassignRoleFromUserResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUnassignRoleFromUserResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("unassignRoleFromUser", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "unassignRoleFromUser", exempt: false });
    });
  }
  unassignUserFromGroup(arg) {
    return toCancelable2(async (signal) => {
      const { groupId, username } = arg || {};
      let envelope = {};
      envelope.path = { groupId, username };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("unassignUserFromGroup", zUnassignUserFromGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await unassignUserFromGroup(opts);
          let data = this._evaluateResponse(_raw, "unassignUserFromGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUnassignUserFromGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUnassignUserFromGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("unassignUserFromGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "unassignUserFromGroup", exempt: false });
    });
  }
  unassignUserFromTenant(arg) {
    return toCancelable2(async (signal) => {
      const { tenantId, username } = arg || {};
      let envelope = {};
      envelope.path = { tenantId, username };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("unassignUserFromTenant", zUnassignUserFromTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await unassignUserFromTenant(opts);
          let data = this._evaluateResponse(_raw, "unassignUserFromTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUnassignUserFromTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUnassignUserFromTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("unassignUserFromTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "unassignUserFromTenant", exempt: false });
    });
  }
  unassignUserTask(arg) {
    return toCancelable2(async (signal) => {
      const { userTaskKey } = arg || {};
      let envelope = {};
      envelope.path = { userTaskKey };
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("unassignUserTask", zUnassignUserTaskData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      const call = async () => {
        try {
          const _raw = await unassignUserTask(opts);
          let data = this._evaluateResponse(_raw, "unassignUserTask", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUnassignUserTaskResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUnassignUserTaskResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("unassignUserTask", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "unassignUserTask", exempt: false });
    });
  }
  updateAuthorization(arg) {
    return toCancelable2(async (signal) => {
      const { authorizationKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { authorizationKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("updateAuthorization", zUpdateAuthorizationData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await updateAuthorization(opts);
          let data = this._evaluateResponse(_raw, "updateAuthorization", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUpdateAuthorizationResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUpdateAuthorizationResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("updateAuthorization", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "updateAuthorization", exempt: false });
    });
  }
  updateGroup(arg) {
    return toCancelable2(async (signal) => {
      const { groupId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { groupId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("updateGroup", zUpdateGroupData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await updateGroup(opts);
          let data = this._evaluateResponse(_raw, "updateGroup", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUpdateGroupResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUpdateGroupResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("updateGroup", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "updateGroup", exempt: false });
    });
  }
  updateJob(arg) {
    return toCancelable2(async (signal) => {
      const { jobKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { jobKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("updateJob", zUpdateJobData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await updateJob(opts);
          let data = this._evaluateResponse(_raw, "updateJob", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUpdateJobResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUpdateJobResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("updateJob", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "updateJob", exempt: false });
    });
  }
  updateMappingRule(arg) {
    return toCancelable2(async (signal) => {
      const { mappingRuleId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { mappingRuleId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("updateMappingRule", zUpdateMappingRuleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await updateMappingRule(opts);
          let data = this._evaluateResponse(_raw, "updateMappingRule", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUpdateMappingRuleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUpdateMappingRuleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("updateMappingRule", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "updateMappingRule", exempt: false });
    });
  }
  updateRole(arg) {
    return toCancelable2(async (signal) => {
      const { roleId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { roleId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("updateRole", zUpdateRoleData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await updateRole(opts);
          let data = this._evaluateResponse(_raw, "updateRole", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUpdateRoleResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUpdateRoleResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("updateRole", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "updateRole", exempt: false });
    });
  }
  updateTenant(arg) {
    return toCancelable2(async (signal) => {
      const { tenantId, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { tenantId };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("updateTenant", zUpdateTenantData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await updateTenant(opts);
          let data = this._evaluateResponse(_raw, "updateTenant", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUpdateTenantResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUpdateTenantResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("updateTenant", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "updateTenant", exempt: false });
    });
  }
  updateUser(arg, consistencyManagement) {
    if (!consistencyManagement) throw new Error("Missing consistencyManagement parameter for eventually consistent endpoint");
    const useConsistency = consistencyManagement.consistency;
    return toCancelable2(async (signal) => {
      const { username, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { username };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("updateUser", zUpdateUserData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await updateUser(opts);
          let data = this._evaluateResponse(_raw, "updateUser", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUpdateUserResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUpdateUserResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("updateUser", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      const invoke = () => toCancelable2(() => call());
      if (useConsistency) return eventualPoll("updateUser", false, invoke, { ...useConsistency, logger: this._log });
      return invoke();
    });
  }
  updateUserTask(arg) {
    return toCancelable2(async (signal) => {
      const { userTaskKey, ..._body } = arg || {};
      let envelope = {};
      envelope.path = { userTaskKey };
      envelope.body = _body;
      if (this._validation.settings.req !== "none") {
        const maybe = await this._validation.gateRequest("updateUserTask", zUpdateUserTaskData, envelope);
        if (this._validation.settings.req === "strict") envelope = maybe;
      }
      const opts = { client: this._client, signal, throwOnError: false };
      if (envelope.path) opts.path = envelope.path;
      if (envelope.body !== void 0) opts.body = envelope.body;
      const call = async () => {
        try {
          const _raw = await updateUserTask(opts);
          let data = this._evaluateResponse(_raw, "updateUserTask", (resp) => {
            const st = resp.status ?? resp.response?.status;
            if (!st) return void 0;
            const candidate = st === 429 || st === 503 || st === 500;
            if (!candidate) return void 0;
            let prob = void 0;
            if (resp.error && typeof resp.error === "object") prob = resp.error;
            const err = new Error(prob && (prob.title || prob.detail) ? prob.title || prob.detail : "HTTP " + st);
            err.status = st;
            err.name = "HttpSdkError";
            if (prob) {
              for (const k of ["type", "title", "detail", "instance"]) if (prob[k] !== void 0) err[k] = prob[k];
            }
            const isBp = st === 429 || st === 503 && err.title === "RESOURCE_EXHAUSTED" || st === 500 && (typeof err.detail === "string" && /RESOURCE_EXHAUSTED/.test(err.detail));
            if (!isBp) err.nonRetryable = true;
            return err;
          });
          const _respSchemaName = "zUpdateUserTaskResponse";
          if (this._isVoidResponse(_respSchemaName)) {
            data = void 0;
          }
          if (this._validation.settings.res !== "none") {
            const _schema = zUpdateUserTaskResponse;
            if (_schema) {
              const maybeR = await this._validation.gateResponse("updateUserTask", _schema, data);
              if (this._validation.settings.res === "strict") data = maybeR;
            }
          }
          return data;
        } catch (e) {
          throw e;
        }
      };
      return this._invokeWithRetry(() => call(), { opId: "updateUserTask", exempt: false });
    });
  }
  // === AUTO-GENERATED CAMUNDA METHODS END ===
  /**
   * Create a job worker that activates and processes jobs of the given type.
   * @param cfg Worker configuration
   */
  createJobWorker(cfg) {
    const worker = new JobWorker(this, cfg);
    this._workers.push(worker);
    return worker;
  }
  /**
   * Node-only convenience: deploy resources from local filesystem paths.
   * @param resourceFilenames Absolute or relative file paths to BPMN/DMN/form/resource files.
   * @param options Optional: tenantId.
   * @returns ExtendedDeploymentResult
   */
  deployResourcesFromFiles(resourceFilenames, options) {
    return toCancelable2(async (_signal) => {
      if (!Array.isArray(resourceFilenames) || resourceFilenames.length === 0) {
        throw new Error("resourceFilenames must be a non-empty string[]");
      }
      if (typeof process === "undefined" || !process.versions?.node) {
        throw new Error("deployResourcesFromFiles is only available in Node.js environments");
      }
      const [{ readFile }, pathMod] = await Promise.all([
        import("fs/promises"),
        import("path")
      ]);
      const mimeFor = (filename) => {
        const ext = filename.toLowerCase().split(".").pop() || "";
        switch (ext) {
          case "bpmn":
          case "dmn":
          case "xml":
            return "application/xml";
          case "json":
          case "form":
            return "application/json";
          default:
            return "application/octet-stream";
        }
      };
      if (typeof File !== "function") {
        throw new Error(
          "Global File constructor not available. Requires Node 18+ (fetch experimental) or Node 20+"
        );
      }
      const files = [];
      for (const p of resourceFilenames) {
        if (typeof p !== "string" || !p) throw new Error("Invalid resource filename encountered");
        const data = await readFile(p);
        const name = pathMod.basename(p);
        files.push(new File([data], name, { type: mimeFor(name) }));
      }
      const payload = {
        resources: files,
        ...options?.tenantId ? { tenantId: options.tenantId } : {}
      };
      return this.createDeployment(payload);
    });
  }
};

// src/fp-ts.ts
var left = (e) => ({ _tag: "Left", left: e });
var right = (a) => ({ _tag: "Right", right: a });
var isLeft = (e) => e._tag === "Left";
var isRight = (e) => e._tag === "Right";
function toDomainError(err) {
  if (err instanceof CamundaValidationError) return err;
  if (err instanceof EventualConsistencyTimeoutError) return err;
  if (err instanceof Error) return err;
  if (typeof err === "object") return err;
  return { message: String(err) };
}
function classifyDomainError(err) {
  if (err instanceof CamundaValidationError) return "validation";
  if (err instanceof EventualConsistencyTimeoutError) return "timeout";
  if (!(err instanceof Error) || err.status !== void 0) return "http";
  return "generic";
}
function foldDomainError(handlers) {
  return (err) => {
    switch (classifyDomainError(err)) {
      case "validation":
        return handlers.validation(err);
      case "timeout":
        return handlers.timeout(err);
      case "http":
        return handlers.http(err);
      case "generic":
        return handlers.generic(err);
    }
  };
}
function isPromiseLike(v) {
  return v && typeof v.then === "function";
}
function createCamundaFpClient(options) {
  const base = createCamundaClient(options);
  const cache = /* @__PURE__ */ new Map();
  function wrap(fn) {
    return (...args) => async () => {
      try {
        const r = fn.apply(base, args);
        const val = isPromiseLike(r) ? await r : r;
        return right(val);
      } catch (e) {
        return left(toDomainError(e));
      }
    };
  }
  const handler = {
    get(_t, prop) {
      if (prop === "inner") return base;
      if (cache.has(prop)) return cache.get(prop);
      const value = base[prop];
      if (typeof value === "function") {
        const w = wrap(value);
        cache.set(prop, w);
        return w;
      }
      cache.set(prop, value);
      return value;
    }
  };
  return new Proxy({}, handler);
}
function retryTE(task, opts) {
  const { max, baseDelayMs = 100, shouldRetry } = opts;
  return async () => {
    let attempt = 0;
    let lastLeft;
    while (attempt < max) {
      const res = await task();
      if (isRight(res)) return res;
      lastLeft = res;
      attempt++;
      const retry = attempt < max && (shouldRetry ? await shouldRetry(res.left, attempt) : true);
      if (!retry) return res;
      const delay = Math.min(2e3, baseDelayMs * Math.pow(2, attempt - 1));
      await new Promise((r) => setTimeout(r, delay));
    }
    return lastLeft;
  };
}
function withTimeoutTE(task, ms, onTimeout) {
  return async () => {
    let settled = false;
    const t = task().then((r) => {
      settled = true;
      return r;
    });
    const timeout = new Promise(
      (res) => setTimeout(() => {
        if (!settled)
          res(left(onTimeout ? onTimeout() : new Error(`Timeout after ${ms}ms`)));
      }, ms)
    );
    return Promise.race([t, timeout]);
  };
}
function eventuallyTE(thunk, predicate, opts) {
  const { intervalMs = 500, waitUpToMs } = opts;
  return async () => {
    const start = Date.now();
    let attempt = 0;
    while (true) {
      attempt++;
      try {
        const val = await thunk();
        if (await predicate(val)) return right(val);
      } catch (e) {
        return left(e);
      }
      const elapsed = Date.now() - start;
      if (elapsed >= waitUpToMs)
        return left(
          new EventualConsistencyTimeoutError({ attempts: attempt, elapsedMs: elapsed })
        );
      await new Promise((r) => setTimeout(r, intervalMs));
    }
  };
}

export {
  CamundaValidationError,
  EventualConsistencyTimeoutError,
  JobActionReceipt,
  createCamundaClient,
  CamundaClient,
  isLeft,
  isRight,
  classifyDomainError,
  foldDomainError,
  createCamundaFpClient,
  retryTE,
  withTimeoutTE,
  eventuallyTE
};
//# sourceMappingURL=chunk-7RIALC7K.js.map