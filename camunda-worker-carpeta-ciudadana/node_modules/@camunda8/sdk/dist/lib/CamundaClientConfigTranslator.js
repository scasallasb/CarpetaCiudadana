"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateToOcaEnvOverrides = translateToOcaEnvOverrides;
const Configuration_1 = require("./Configuration");
/** Log level mapping SDK -> OCA */
const LOG_LEVEL_MAP = {
    none: 'silent',
    error: 'error',
    warn: 'warn',
    info: 'info',
    http: 'debug', // Decision: treat http as debug detail
    verbose: 'debug',
    debug: 'debug',
    silly: 'trace',
};
function normalizeEmpty(v) {
    if (v === undefined || v === null)
        return undefined;
    const s = String(v).trim();
    return s === '' ? undefined : s;
}
function appendV2IfNeeded(address) {
    if (!address)
        return address;
    const lower = address.toLowerCase();
    // If already contains /v2 segment (end or mid-path) do nothing
    if (/(\/v2(\/|$))/i.test(lower))
        return address;
    // Ensure single trailing slash semantics
    return address.endsWith('/') ? `${address}v2` : `${address}/v2`;
}
/**
 * Translate merged SDK configuration into OCA EnvOverrides
 */
function translateToOcaEnvOverrides(options) {
    const { sdkConfig, ocaOverrides, env } = options;
    const sourceEnv = env ?? process.env;
    const explicitEnvProvided = env !== undefined;
    // Merge SDK config with environment
    const mergedSdk = Configuration_1.CamundaEnvironmentConfigurator.mergeConfigWithEnvironment(sdkConfig ?? {});
    const overrides = ocaOverrides ? { ...ocaOverrides } : {};
    const setIfAbsent = (key, value) => {
        // If already explicitly overridden, skip
        if (overrides[key] !== undefined)
            return;
        const existingEnv = normalizeEmpty(sourceEnv[key]);
        if (explicitEnvProvided) {
            // Explicit env argument wins over derived value
            if (existingEnv !== undefined) {
                overrides[key] = existingEnv;
                return;
            }
            if (value !== undefined) {
                overrides[key] = value;
            }
            return;
        }
        // No explicit env provided: derived value wins over process.env, unless derived is undefined.
        if (value !== undefined) {
            overrides[key] = value;
            return;
        }
        if (existingEnv !== undefined) {
            overrides[key] = existingEnv;
        }
    };
    // Auth strategy
    const sdkAuth = (normalizeEmpty(mergedSdk.CAMUNDA_AUTH_STRATEGY) || 'NONE').toUpperCase();
    if (!['NONE', 'OAUTH', 'BASIC'].includes(sdkAuth)) {
        throw new Error(`Unsupported auth strategy for OCA translation: ${sdkAuth}. Supported: NONE|OAUTH|BASIC.`);
    }
    setIfAbsent('CAMUNDA_AUTH_STRATEGY', sdkAuth);
    // Client credentials
    const deriveClientId = () => {
        const envClientId = normalizeEmpty(sourceEnv.CAMUNDA_CLIENT_ID);
        const sdkProvided = sdkConfig ? Object.keys(sdkConfig) : [];
        const zeebeExplicit = sdkProvided.includes('ZEEBE_CLIENT_ID');
        const sdkZeebe = zeebeExplicit
            ? normalizeEmpty(mergedSdk.ZEEBE_CLIENT_ID)
            : undefined; // ignore environment-sourced Zeebe ID if not explicitly provided
        const sdkConsole = normalizeEmpty(mergedSdk.CAMUNDA_CONSOLE_CLIENT_ID);
        if (explicitEnvProvided && envClientId)
            return envClientId; // explicit env wins
        if (sdkZeebe)
            return sdkZeebe; // Zeebe credentials take precedence
        if (sdkConsole)
            return sdkConsole; // fallback to console client id
        if (!explicitEnvProvided && envClientId)
            return envClientId; // ambient env last resort
        return undefined;
    };
    const resolvedClientId = deriveClientId();
    if (resolvedClientId)
        overrides.CAMUNDA_CLIENT_ID = resolvedClientId;
    const clientSecret = normalizeEmpty(mergedSdk.ZEEBE_CLIENT_SECRET) ??
        normalizeEmpty(mergedSdk.CAMUNDA_CONSOLE_CLIENT_SECRET);
    setIfAbsent('CAMUNDA_CLIENT_SECRET', clientSecret);
    // Audience
    const audience = normalizeEmpty(mergedSdk.CAMUNDA_ZEEBE_OAUTH_AUDIENCE) ??
        normalizeEmpty(mergedSdk.ZEEBE_TOKEN_AUDIENCE);
    setIfAbsent('CAMUNDA_TOKEN_AUDIENCE', audience);
    // OAuth URL & scope
    setIfAbsent('CAMUNDA_OAUTH_URL', normalizeEmpty(mergedSdk.CAMUNDA_OAUTH_URL));
    setIfAbsent('CAMUNDA_OAUTH_SCOPE', normalizeEmpty(mergedSdk.CAMUNDA_TOKEN_SCOPE));
    // Cache dir (skip if disk cache disabled)
    if (!mergedSdk.CAMUNDA_TOKEN_DISK_CACHE_DISABLE) {
        setIfAbsent('CAMUNDA_OAUTH_CACHE_DIR', normalizeEmpty(mergedSdk.CAMUNDA_TOKEN_CACHE_DIR));
    }
    // Basic auth supplementary fields
    if (sdkAuth === 'BASIC') {
        setIfAbsent('CAMUNDA_BASIC_AUTH_USERNAME', normalizeEmpty(mergedSdk.CAMUNDA_BASIC_AUTH_USERNAME));
        setIfAbsent('CAMUNDA_BASIC_AUTH_PASSWORD', normalizeEmpty(mergedSdk.CAMUNDA_BASIC_AUTH_PASSWORD));
    }
    // Tenant
    setIfAbsent('CAMUNDA_DEFAULT_TENANT_ID', normalizeEmpty(mergedSdk.CAMUNDA_TENANT_ID));
    // Log level mapping
    const rawLevel = normalizeEmpty(mergedSdk.CAMUNDA_LOG_LEVEL) || 'error';
    const mappedLevel = LOG_LEVEL_MAP[rawLevel] ?? 'error';
    setIfAbsent('CAMUNDA_SDK_LOG_LEVEL', mappedLevel);
    // REST address
    const restBase = normalizeEmpty(mergedSdk.ZEEBE_REST_ADDRESS) || 'http://localhost:8080';
    setIfAbsent('CAMUNDA_REST_ADDRESS', appendV2IfNeeded(restBase));
    // mTLS (path precedence)
    const certPath = normalizeEmpty(mergedSdk.CAMUNDA_CUSTOM_CERT_CHAIN_PATH);
    const keyPath = normalizeEmpty(mergedSdk.CAMUNDA_CUSTOM_PRIVATE_KEY_PATH);
    const caPath = normalizeEmpty(mergedSdk.CAMUNDA_CUSTOM_ROOT_CERT_PATH);
    const caInline = normalizeEmpty(mergedSdk.CAMUNDA_CUSTOM_ROOT_CERT_STRING);
    if (certPath)
        setIfAbsent('CAMUNDA_MTLS_CERT_PATH', certPath);
    if (keyPath)
        setIfAbsent('CAMUNDA_MTLS_KEY_PATH', keyPath);
    if (caPath)
        setIfAbsent('CAMUNDA_MTLS_CA_PATH', caPath);
    else if (caInline)
        setIfAbsent('CAMUNDA_MTLS_CA', caInline);
    return overrides;
}
/** Convenience wrapper returning hydrated configuration directly */
exports.default = {
    translateToOcaEnvOverrides,
};
//# sourceMappingURL=CamundaClientConfigTranslator.js.map